#+title: Exercise 77
* Prompt
The ~integral~ procedure used above was analogous to the "implicit" definition of the inifinite stream of integers in Section 3.5.2. Alternatively, we can give a definition of ~integral~ that is more like ~integers-starting-from~ (also in section 3.5.2):

#+begin_src scheme :exports code
(define (integral integrand initial-value dt)
  (cons-stream
   initial-value
   (if (stream-null? integrand)
       the-empty-stream
       (integral (stream-cdr integrand)
                 (+ (* dt (stream-car integrand))
                    initial-value)
                 dt))))
#+end_src

When used in systems with loops, this procedure has the same problem as does our original version of ~integral~. Modify the procedure so that it expects the ~integrand~ as a delayed argument and hence can be used in the ~solve~ procedure shown above.
* Solution
:properties:
:header-args:racket: :tangle ./src/exercise-77.rkt :comments yes
:end:

#+begin_src racket :exports none
#lang sicp
#+end_src

#+begin_src racket :exports none
;; This segment handles module imports
(#%require "modules/stream-base.rkt"
           "modules/stream-combinator.rkt"
           "modules/stream-generator.rkt"
           "modules/assert-tool.rkt")
#+end_src

Here is the modified version of the ~integral~ procedure.

#+begin_src racket :exports code
(define (integral delayed-integrand initial-value dt)
  (cons-stream initial-value
               (let ([integrand (force delayed-integrand)])
                 (if (stream-null? integrand)
                     the-empty-stream
                     (integral (delay
                                 (stream-cdr integrand))
                               (+ (* dt (stream-car integrand)) initial-value)
                               dt)))))
#+end_src
** Testing
For testing, we are going to duplicate the computation that resulted in the approximation of Euler's number.
*** Building dependent procedures

#+begin_src racket :exports code
;; This solves a differential equation
(define (solve f y0 dt)
  (letrec ([y (integral (delay
                          dy)
                        y0
                        dt)]
           [dy (stream-map f y)])
    y))

(define euler-stream (solve (lambda (y) y) 1 0.001))
#+end_src
*** Application of the test

#+begin_src racket :exports code
(newline)
(display "computing Euler's number")
(stream-ref euler-stream 1000)
#+end_src
** Result
#+begin_src bash :exports both :results output
racket ./src/exercise-77.rkt
#+end_src

#+RESULTS:

This code fails to run in Racket. There might be some quirk with how the language is implemented, but that is not the purpose of this exercise. I will now proceed to move on.
