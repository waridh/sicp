#+title: Exercise 66
* Prompt
Examine the stream ~(pairs integers integers)~. Can you make any general comments about the order in which the pairs are placed into the stream? For example, approximately how many pairs precede the pair $(1,100)$? The pair $(99, 100)$? The pair $(100,100)$? (If you can make precise mathematical statements here, all the better. But feel free to give more qualitative answers if you find yourself getting bogged down.)
* Solution
:properties:
:header-args:racket: :tangle ./src/exercise-66.rkt :comments yes
:end:

#+begin_src racket :exports none
#lang sicp
(#%require "modules/stream-base.rkt"
           "modules/stream-combinator.rkt"
           "modules/stream-generator.rkt"
           "modules/assert-tool.rkt")
#+end_src

For reference, we shall show the ~pairs~ procedure here.

#+begin_src racket :exports code
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
#+end_src

Now, we should write some code to observe the behavior of the system.

#+begin_src racket :exports code
(define pairs-integer-integer (pairs integers integers))
(define (hline)
  (newline)
  (display "--------"))
(newline)
(display "experimental print of the stream from 0 to 20")
(newline)
(display-stream-range 0 100 pairs-integer-integer)
(hline)

#+end_src

The result from displaying this value shows the works of the interleave. The following explanation requires that the reader has read the chapter on the /infinite streams of pairs/ chapter of SICP.

Here, we see that the first row of pairs are interleaved every other case. Elements of the first row denoted with $e1_n$, and the elements of the other rows are denoted with $e1'_m$. The currently pattern looks like the following:

$$
e1_1 e1'_1 e1_2 e1'_2 \dots
$$

Then, if we filter out all elements $e1_n$ from the sequence, and then denote the elements of the second row as $e2_n$, and elements that are not present on the second row as $e2_m'$, then the remaining sequence will be of the form:

$$
e2_1 e2'_1 e2_2 e2'_2 \dots
$$

From here, we are able to keep applying this logic. This is the pattern in the location of the elements from each of the rows as the sequence is evaluated.

** How many pairs precede?

In this section, we are going to write a program that will count the number of pairs that precedes a target pair. We will make an iterative process that will iterate through the provided stream to find the target resulting pair

*** Counter function

#+begin_src racket :exports code
(define (count-preceding-pairs target-pair s)
  (let ([first-ele (car target-pair)]
        [second-ele (cadr target-pair)])
    (define (iter acc tail)
      (if (stream-null? tail)
          acc
          (let ([head (stream-car tail)])
            (if (and (= (car head) first-ele) (= (cadr head) second-ele))
                acc
                (iter (+ acc 1) (stream-cdr tail))))))
    (iter 0 s)))
(define (run-bulk-count pairs s)
  (define (run-once pair)
    (newline)
    (display "finding the number of preceding pairs for ")
    (display pair)
    (newline)
    (display (count-preceding-pairs pair s))
    (hline))
  (define (iter tail)
    (if (null? tail)
        'done
        (begin (run-once (car tail))
               (iter (cdr tail)))))
  (iter pairs))
#+end_src
*** Testing

#+begin_src racket :exports code
(run-bulk-count '((1 100)) pairs-integer-integer)
;; (display "finding the number preceding the pair (99, 100)")
;; (newline)
;; (count-preceding-pairs (list 99 100) pairs-integer-integer)
;; (newline)
;; (hline)
;; (newline)
;; (display "finding the number preceding the pair (100, 100)")
;; (newline)
;; (count-preceding-pairs (list 100 100) pairs-integer-integer)
#+end_src

Actually, we found out that we cannot compute the two values. We must actually use a different strategy to approximate the target value. We could start by looking at the numerical relationship between the first element of the list, the second element of the list, and the number of preceding values.

#+begin_src racket :exports code
(run-bulk-count '((2 100) (3 100) (10 10)) pairs-integer-integer)

#+end_src

Okay, with this value, we are able to establish the following idea. The number of preceding pairs for a certain pair could be approximated by taking the product of two to the power of the first element with the second element.

Here are the next experiments to see if there are some missed edge cases.

#+begin_src racket :exports code
(newline)
(display "testing (3 3)")
(newline)
(count-preceding-pairs (list 3 3) pairs-integer-integer)
(hline)
#+end_src

Wait, a more accurate pattern might be revealing itself. For the input of ~(3 3)~ instead of the resulting value being ~(* (expt 2 first-element) second-element)~, it may be more accurate to say that the number of preceding pairs is ~(- (* (expt 2 first-element) (- second-element first-element)) 2)~.

We can show this by writing a procedure that computes such a value, run some assertion suite, an then use it to compute the number of preceding pairs for (99 100) and (100 100).

#+begin_src racket :exports code
(define (fast-expt b n)
  (define (square x) (* x x))
  (define (even? x) (= (remainder x 2) 0))
  (define (fast-expt-iter b n a)
    (if (= n 0) a (if (even? n)
                      (fast-expt-iter (square b) (/ n 2) a)
                      (fast-expt-iter b (- n 1) (* a b)))))
  (fast-expt-iter b n 1))
(define (compute-preceding-pairs pair)
  (let ([first-ele (car pair)]
        [second-ele (cadr pair)])
    (- (* (fast-expt 2 first-ele) (- second-ele (- first-ele 1))) 2)))
(define (bulk-compute-preceding-pairs pair-sequence)
  (define (run-once pair)
    (newline)
    (display "out approx of ") (display pair)
    (newline)
    (display (compute-preceding-pairs pair))
    (hline))
  (define (iter tail)
    (if (null? tail)
        'done
        (begin (run-once (car tail))
               (iter (cdr tail)))))
  (iter pair-sequence))
#+end_src

#+begin_src racket :exports code
(bulk-compute-preceding-pairs (list (list 3 3) (list 2 2) (list 1 1) (list 10 10) (list 1 100) (list 2 100) (list 3 100)))
#+end_src

Well, it looks like there is one more property that we missed. It is that the number subtracted is not hard coded to 2, but will actually grow as there are more rows added below the current row being calculated. Since I have places to be, and things to do, I will not be spending the time to write that. Instead, I will present the approximation for the number of pairs in front of ~(99 100)~ and ~(100 100)~

#+begin_src racket :exports code
(bulk-compute-preceding-pairs '((99 100) (100 100)))
#+end_src

The approximations are around the same here, but we are missing one of the decremental terms.

** Result

#+begin_src bash :exports both :results output
racket ./src/exercise-66.rkt
#+end_src

#+RESULTS:
#+begin_example

experimental print of the stream from 0 to 20
( (1 1) (1 2) (2 2) (1 3) (2 3) (1 4) (3 3) (1 5) (2 4) (1 6) (3 4) (1 7) (2 5) (1 8) (4 4) (1 9) (2 6) (1 10) (3 5) (1 11) (2 7) (1 12) (4 5) (1 13) (2 8) (1 14) (3 6) (1 15) (2 9) (1 16) (5 5) (1 17) (2 10) (1 18) (3 7) (1 19) (2 11) (1 20) (4 6) (1 21) (2 12) (1 22) (3 8) (1 23) (2 13) (1 24) (5 6) (1 25) (2 14) (1 26) (3 9) (1 27) (2 15) (1 28) (4 7) (1 29) (2 16) (1 30) (3 10) (1 31) (2 17) (1 32) (6 6) (1 33) (2 18) (1 34) (3 11) (1 35) (2 19) (1 36) (4 8) (1 37) (2 20) (1 38) (3 12) (1 39) (2 21) (1 40) (5 7) (1 41) (2 22) (1 42) (3 13) (1 43) (2 23) (1 44) (4 9) (1 45) (2 24) (1 46) (3 14) (1 47) (2 25) (1 48) (6 7) (1 49) (2 26) (1 50) (3 15) (1 51) (2 27))
--------
finding the number of preceding pairs for (1 100)
197
--------done

finding the number of preceding pairs for (2 100)
392
--------
finding the number of preceding pairs for (3 100)
778
--------
finding the number of preceding pairs for (10 10)
1022
--------done

testing (3 3)
6

--------
out approx of (3 3)
6
--------
out approx of (2 2)
2
--------
out approx of (1 1)
0
--------
out approx of (10 10)
1022
--------
out approx of (1 100)
198
--------
out approx of (2 100)
394
--------
out approx of (3 100)
782
--------done

out approx of (99 100)
1267650600228229401496703205374
--------
out approx of (100 100)
1267650600228229401496703205374
--------done
#+end_example

With this result, we conclude this exercise.
