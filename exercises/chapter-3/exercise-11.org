#+title: Exercise 11
* Prompt
We saw how the environment model described the behavior of procedures with local state. Now we have seen how internal definitions work. a typical message-passing procedure contains both of these aspects. Consider the bank account procedure from the text:
#+begin_src racket :exports code
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond [(eq? m 'withdraw) withdraw]
          [(eq? m 'deposit) deposit]
          [else
           (error "unknown request: MAKE-ACCOUNT" m)]))
  dispatch)
#+end_src

Show the environment structure generated by the sequence of interactions

#+begin_src racket :exports code
(define acc (make-account 50))
((acc 'deposit) 40)
((acc 'withdraw) 60)
#+end_src

Where is the local state for ~acc~ kept? Suppose we define another account

#+begin_src racket :exports code
(define acc2 (make-account 100))
#+end_src

How are the local states for the two accounts kept distinct? Which parts of the environment structure are shared between ~acc~ and ~acc2~?

* Solution

For the environment modeling of the three statements, we are only going to take the environment snapshot for each one. I don't think we have to constantly do the same song and dance.

** Environment modeling

*** Step 1

#+begin_src plantuml :exports results :results file :file ./images/3.11-env1.png
@startuml
card global_env {
        label "make-account" as make_account
        label "acc" as global_acc
}
rectangle "make-account pair" as make_acc_pair
card make_acc_proc [
parameters: balance
body:(define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond [(eq? m 'withdraw) withdraw]
          [(eq? m 'deposit) deposit]
          [else
           (error "unknown request: MAKE-ACCOUNT" m)]))
  dispatch
]

card "E1" as e1_env {
        label "withdraw" as e1_withdraw
        label "deposit" as e1_deposit
        label "dispatch" as e1_dispatch
        label "balance: 50" as e1_balance
}

rectangle "withdraw pair" as e1_withdraw_pair
rectangle "deposit pair" as e1_deposit_pair
rectangle "dispatch pair" as e1_dispatch_pair

card e1_withdraw_proc [
parameters: amount
body: (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")
]
card e1_deposit_proc [
parameters: amount
body: (set! balance (+ balance amount))
    balance
]
card e1_dispatch_proc [
parameters: m
body: (cond [(eq? m 'withdraw) withdraw]
          [(eq? m 'deposit) deposit]
          [else
           (error "unknown request: MAKE-ACCOUNT" m)])
]

make_account -down-> make_acc_pair
make_acc_pair -up-> global_env
make_acc_pair -down-> make_acc_proc

e1_withdraw -down-> e1_withdraw_pair
e1_withdraw_pair -up-> e1_env
e1_withdraw_pair -down-> e1_withdraw_proc

e1_deposit -down-> e1_deposit_pair
e1_deposit_pair -up-> e1_env
e1_deposit_pair -down-> e1_deposit_proc

global_acc -right-> e1_dispatch_pair
e1_dispatch -down-> e1_dispatch_pair
e1_dispatch_pair -up-> e1_env
e1_dispatch_pair -down-> e1_dispatch_proc

e1_env -left-> global_env
@enduml
#+end_src

#+RESULTS:
[[file:./images/3.11-env1.png]]

Here, we have described the environment that is present after evaluating src_racket{(define acc (make-account 50))}

*** Step 2

Now, we will show the environment after evaluating src_racket{((acc 'deposit) 40)}.

#+begin_src plantuml :exports results :results file :file ./images/3.11-env2.png
@startuml
card global_env {
        label "make-account" as make_account
        label "acc" as global_acc
}
rectangle "make-account pair" as make_acc_pair
card make_acc_proc [
parameters: balance
body:(define (withdraw amount)
(if (>= balance amount)
(begin (set! balance (- balance amount))
balance)
"Insufficient funds"))
(define (deposit amount)
(set! balance (+ balance amount))
balance)
(define (dispatch m)
(cond [(eq? m 'withdraw) withdraw]
[(eq? m 'deposit) deposit]
[else
(error "unknown request: MAKE-ACCOUNT" m)]))
dispatch
]

card "E1" as e1_env {
        label "withdraw" as e1_withdraw
        label "deposit" as e1_deposit
        label "dispatch" as e1_dispatch
        label "balance: 90" as e1_balance
}

rectangle "withdraw pair" as e1_withdraw_pair
rectangle "deposit pair" as e1_deposit_pair
rectangle "dispatch pair" as e1_dispatch_pair

card e1_withdraw_proc [
parameters: amount
body: (if (>= balance amount)
(begin (set! balance (- balance amount))
balance)
"Insufficient funds")
]
card e1_deposit_proc [
parameters: amount
body: (set! balance (+ balance amount))
balance
]
card e1_dispatch_proc [
parameters: m
body: (cond [(eq? m 'withdraw) withdraw]
[(eq? m 'deposit) deposit]
[else
(error "unknown request: MAKE-ACCOUNT" m)])
]

card e2_env [
E2
===
m: 'deposit
body: deposit
]

note top of e2_env: The evaluation of the first element of the combination,\nwhich is the dispatch procedure. After calling, we no longer need this\nenvironment frame.

card e3_env [
E3
===
amount: 40
body: 90
]

note bottom of e3_env: The application of deposit on the argument of 40 would reach\ninto the enveloping environment, which is E1, and then mutate the value\nof the balance.


make_account -down-> make_acc_pair
make_acc_pair -up-> global_env
make_acc_pair -down-> make_acc_proc

e1_withdraw -down-> e1_withdraw_pair
e1_withdraw_pair -up-> e1_env
e1_withdraw_pair -down-> e1_withdraw_proc

e1_deposit -down-> e1_deposit_pair
e1_deposit_pair -up-> e1_env
e1_deposit_pair -down-> e1_deposit_proc

global_acc -right-> e1_dispatch_pair
e1_dispatch -down-> e1_dispatch_pair
e1_dispatch_pair -up-> e1_env
e1_dispatch_pair -down-> e1_dispatch_proc

e1_env -left-> global_env
e2_env -left-> e1_env
e3_env -right-> e1_env
@enduml
#+end_src

#+RESULTS:
[[file:./images/3.11-env2.png]]

Now, we have deposited 40 to a balance of 50, increasing the balance to 90.
*** Step 3
Now, we are going to show evaluation of the src_racket{((acc 'withdraw') 60)} line.

#+begin_src plantuml :exports results :results file :file ./images/3.11-env3.png
@startuml
card global_env {
        label "make-account" as make_account
        label "acc" as global_acc
}
rectangle "make-account pair" as make_acc_pair
card make_acc_proc [
parameters: balance
body:(define (withdraw amount)
(if (>= balance amount)
(begin (set! balance (- balance amount))
balance)
"Insufficient funds"))
(define (deposit amount)
(set! balance (+ balance amount))
balance)
(define (dispatch m)
(cond [(eq? m 'withdraw) withdraw]
[(eq? m 'deposit) deposit]
[else
(error "unknown request: MAKE-ACCOUNT" m)]))
dispatch
]

card "E1" as e1_env {
        label "withdraw" as e1_withdraw
        label "deposit" as e1_deposit
        label "dispatch" as e1_dispatch
        label "balance: 30" as e1_balance
}

rectangle "withdraw pair" as e1_withdraw_pair
rectangle "deposit pair" as e1_deposit_pair
rectangle "dispatch pair" as e1_dispatch_pair

card e1_withdraw_proc [
parameters: amount
body: (if (>= balance amount)
(begin (set! balance (- balance amount))
balance)
"Insufficient funds")
]
card e1_deposit_proc [
parameters: amount
body: (set! balance (+ balance amount))
balance
]
card e1_dispatch_proc [
parameters: m
body: (cond [(eq? m 'withdraw) withdraw]
[(eq? m 'deposit) deposit]
[else
(error "unknown request: MAKE-ACCOUNT" m)])
]

card e2_env [
E2
===
m: 'withdraw
body: withdraw
]

note top of e2_env: The evaluation of the first element of the combination,\nwhich is the dispatch procedure. After calling, we no longer need this\nenvironment frame.

card e3_env [
E3
===
amount: 60
body: 30
]

note bottom of e3_env: The application of withdraw on the argument of 60 would reach\ninto the enveloping environment, which is E1, and then mutate the value\nof the balance.


make_account -down-> make_acc_pair
make_acc_pair -up-> global_env
make_acc_pair -down-> make_acc_proc

e1_withdraw -down-> e1_withdraw_pair
e1_withdraw_pair -up-> e1_env
e1_withdraw_pair -down-> e1_withdraw_proc

e1_deposit -down-> e1_deposit_pair
e1_deposit_pair -up-> e1_env
e1_deposit_pair -down-> e1_deposit_proc

global_acc -right-> e1_dispatch_pair
e1_dispatch -down-> e1_dispatch_pair
e1_dispatch_pair -up-> e1_env
e1_dispatch_pair -down-> e1_dispatch_proc

e1_env -left-> global_env
e2_env -left-> e1_env
e3_env -right-> e1_env
@enduml
#+end_src

#+RESULTS:
[[file:./images/3.11-env3.png]]
*** Where is the local state kept

The local state for ~acc~ is kept in ~E1~, which is the environment frame that was created on the application of the ~make-account~ procedure to the argument of 50.


** Where is the local state, where is the shared state

Let's show the environment model diagram for when a second account is created with the following expression: src_racket{(define acc2 (make-account 100))}.
#+begin_src plantuml :exports results :results file :file ./images/3.11-env4.png
@startuml
card global_env {
        label "make-account" as make_account
        label "acc" as global_acc
        label "acc2" as global_acc2
}
rectangle "make-account pair" as make_acc_pair
card make_acc_proc [
parameters: balance
body:(define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond [(eq? m 'withdraw) withdraw]
          [(eq? m 'deposit) deposit]
          [else
           (error "unknown request: MAKE-ACCOUNT" m)]))
  dispatch
]

card "E1" as e1_env {
        label "withdraw" as e1_withdraw
        label "deposit" as e1_deposit
        label "dispatch" as e1_dispatch
        label "balance: 30" as e1_balance
}

rectangle "withdraw pair" as e1_withdraw_pair
rectangle "deposit pair" as e1_deposit_pair
rectangle "dispatch pair" as e1_dispatch_pair

card e1_withdraw_proc [
parameters: amount
body: (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")
]
card e1_deposit_proc [
parameters: amount
body: (set! balance (+ balance amount))
    balance
]
card e1_dispatch_proc [
parameters: m
body: (cond [(eq? m 'withdraw) withdraw]
          [(eq? m 'deposit) deposit]
          [else
           (error "unknown request: MAKE-ACCOUNT" m)])
]

card "E2" as e2_env {
        label "withdraw" as e2_withdraw
        label "deposit" as e2_deposit
        label "dispatch" as e2_dispatch
        label "balance: 100" as e2_balance
}

rectangle "withdraw pair" as e2_withdraw_pair
rectangle "deposit pair" as e2_deposit_pair
rectangle "dispatch pair" as e2_dispatch_pair

card e2_withdraw_proc [
parameters: amount
body: (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")
]
card e2_deposit_proc [
parameters: amount
body: (set! balance (+ balance amount))
    balance
]
card e2_dispatch_proc [
parameters: m
body: (cond [(eq? m 'withdraw) withdraw]
          [(eq? m 'deposit) deposit]
          [else
           (error "unknown request: MAKE-ACCOUNT" m)])
]


make_account -down-> make_acc_pair
make_acc_pair -up-> global_env
make_acc_pair -down-> make_acc_proc

e1_withdraw -down-> e1_withdraw_pair
e1_withdraw_pair -up-> e1_env
e1_withdraw_pair -down-> e1_withdraw_proc

e1_deposit -down-> e1_deposit_pair
e1_deposit_pair -up-> e1_env
e1_deposit_pair -down-> e1_deposit_proc

global_acc -right-> e1_dispatch_pair
e1_dispatch -down-> e1_dispatch_pair
e1_dispatch_pair -up-> e1_env
e1_dispatch_pair -down-> e1_dispatch_proc

e1_env -left-> global_env

e2_withdraw -down-> e2_withdraw_pair
e2_withdraw_pair -up-> e2_env
e2_withdraw_pair -down-> e2_withdraw_proc

e2_deposit -down-> e2_deposit_pair
e2_deposit_pair -up-> e2_env
e2_deposit_pair -down-> e2_deposit_proc

global_acc2 -right-> e2_dispatch_pair
e2_dispatch -down-> e2_dispatch_pair
e2_dispatch_pair -up-> e2_env
e2_dispatch_pair -down-> e2_dispatch_proc

e2_env -left-> global_env
@enduml
#+end_src

#+RESULTS:
[[file:./images/3.11-env4.png]]


The two account objects are kept distinct by having their own environment frame each with their own local mutable variables, and procedures bound to these environment. As a note, we could see why objects in this system could be expensive, as we are making unique instances of the object methods every time we instantiate an object.

The global environment frame is what is shared between ~acc~ and ~acc2~.
