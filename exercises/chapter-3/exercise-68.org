#+title: Exercise 68
* Prompt
Louis Reasoner thinks that building a stream of pairs from three parts is unnecessarily complicated. Instead of separating the pair $(S_0, T_0)$ from the rest of the pairs in the first row, he proposes to work with the whole first row, as follows:

#+begin_src racket :exports code
(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
#+end_src

Does this work? Consider what happens if we evaluate ~(pairs integers integers)~ using Louis's definition of ~pairs~.
* Solution
:properties:
:header-args:racket: :tangle ./src/exercise-68.rkt :comments yes
:end:

#+begin_src racket :exports none
#lang sicp
(#%require "modules/stream-base.rkt"
           "modules/stream-combinator.rkt"
           "modules/stream-generator.rkt")
#+end_src

For reference, we shall show the definition of ~pairs~ that we used previously.

#+begin_src racket :exports code
(define (pairs-old s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs-old (stream-cdr s) (stream-cdr t)))))
#+end_src

If there is an issue with this implementation, it is not immediately obvious to me. Since this is the case, I shall run some experiment to see if the implementations differ.

#+begin_src racket :exports code
(define (pairs-louis s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs-louis (stream-cdr s) (stream-cdr t))))
#+end_src

We should display both to see what the heck is going on.

#+name: display-old
#+begin_src racket :exports code
(newline)
(display "old output, 0 to 20")
(newline)
(display (display-stream-range 0 20 (pairs-old integers integers)))
#+end_src

Now for the new output.

#+begin_src racket :exports code
(newline)
(display "Louis implementation, 0 to 20")
(newline)
;; (display (display-stream-range 0 20 (pairs-louis integers integers)))
#+end_src

Actually, running that cause a blocking loop to occur.

After a little of review, the issue here is that interleave is not a special form, therefore, the order of evaluation of the arguments are eagerly evaluated, specifically the recursive application of ~pairs~ again. This means that applying ~(pairs integers integers)~ the procedure will enter an infinite loop, leaking memory, and never halting. Way to bring down the system, Louis.

#+begin_src bash :exports both :results output
racket ./src/exercise-68.rkt
#+end_src

#+RESULTS:
:
: old output, 0 to 20
: ( (1 1) (1 2) (2 2) (1 3) (2 3) (1 4) (3 3) (1 5) (2 4) (1 6) (3 4) (1 7) (2 5) (1 8) (4 4) (1 9) (2 6) (1 10) (3 5) (1 11) (2 7))#<void>
: Louis implementation, 0 to 20
