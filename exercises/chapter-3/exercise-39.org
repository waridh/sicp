#+title: Exercise 39
* Prompt

Which of the five possibilities in the parallel execution shown above remain if we instead serialize execution as follows:

#+begin_src racket :exports code
(define x 10)
(define s (make-serializer))
(parallel-execute
 (lambda () (set! x ((s (lambda () (* x x))))))
 (s (lambda () (set! x (+ x 1)))))
#+end_src
* Solution

- 101: P_1 sets x to 100, and P_2 increments x to 101
- 121: P_2 sets x to 11, and P_1 sets x to 121
- 100: P_1 calculated that it would like to write 100, and then P_2 interleaves before P_1 can set the value. P_2 writes 11, and then gets overwritten with 100 by P_2.
- 11: P_2 reads 10, P_1 writes 100, and then P_2 writes 11. The serialized section of P_1 already happened in this case

Here is a discussion on why the last case cannot happen:
- P_2 cannot read two different values of x, since both reads are in the serializer, and so mutation would not happen
