#+title: Chapter 2
#+author: Bach
* Snippets
#+name: assertion-suite
#+begin_src racket :exports code
(define (assert-predicate pred-fn test-name value expected)
  (display (if (pred-fn value expected) "pass: " "fail: "))
  (display test-name)
  (display " value: ")
  (display value)
  (display " expected: ")
  (display expected)
  (newline))

(define (assert-eq test-name value expected)
  (assert-predicate equal? test-name value expected))
(define (assert-almost-eq test-name value expected)
  (define dx 0.0001)
  (define (almost-eq? left right)
    (< (abs (- left right)) dx))
  (assert-predicate almost-eq? test-name value expected))
#+end_src
* Exercise 2.1
Make an improved ~make-rat~ that will normalize the signage of the rational number.
#+begin_src racket :exports code
#lang sicp
(define (make-rat n d)
  (define (neg? nu de)
    (or (and (> nu 0) (< de 0)) (and (< nu 0) (> de 0))))
  (define (make-rat-aux nu de)
    (let ([g (gcd nu de)]) (cons (/ nu g) (/ de g))))
  (if (neg? n d)
      (make-rat-aux (- 0 (abs n)) (abs d))
      (make-rat-aux (abs n) (abs d))))

(make-rat -4 -12)
(make-rat 4 -12)
(make-rat -4 12)
(make-rat 4 12)
#+end_src

#+RESULTS:
: (1 . 3)
: (-1 . 3)
: (-1 . 3)
: (1 . 3)

* Exercise 2.2
Design a segment, a concept where two points make up a segment. While at it, also design points, a pair of numbers. Here are the required interface:

For segment:
- Constructor
  - ~make-segment~
- Selector
  - ~start-segment~
  - ~end-segment~

For points:
- Constructor
  - ~make-point~
- Selector
  - ~x-point~
  - ~y-point~

Domain procedure:
- ~midpoint-segment~

We're provided with a print function

#+name: exercise-2.2
#+begin_src racket :exports code
;; Point printing
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
;; Point interface
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))

;; Segment interface
;; make-segment is the segment constructor that takes in a start point and an
;; end point as parameters
(define (make-segment start end)
  (cons start end))
;; start-segment takes a segment as a parameter and returns the start of the
;; segment
(define (start-segment s)
  (car s))
;; end-segment takes in a segment as parameter and returns the end point of the
;; segment
(define (end-segment s)
  (cdr s))

;; midpoint-segment takes in a segment and returns the point that represents the
;; midpoint of that segment
(define (midpoint-segment s)
  (define (average a b)
    (/ (+ a b) 2))
  (let ([start (start-segment s)]
        [end (end-segment s)])
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))
#+end_src

Testing the written values now

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<exercise-2.2>>

;; Integration test
(define test-segment-1 (make-segment (make-point -1 -2) (make-point 3 4)))
(define test-mp-1 (midpoint-segment test-segment-1))
(print-point test-mp-1)
(assert-eq "test-mp-1-x=1" (x-point test-mp-1) 1)
(assert-eq "test-mp-1-y=1" (y-point test-mp-1) 1)
#+end_src

#+RESULTS:
:
: (1,1)
: pass: test-mp-1-x=1 value: 1 expected: 1
: pass: test-mp-1-y=1 value: 1 expected: 1
* Exercise 2.3
Implement a rectangle in a plane. Write a procedure that calculates the perimeter and area of the rectangle. Then implement a different representation for a rectangle. The goal of the exercise is to abstract properly such that the perimeter and area method does not need to change.

Assuming that we are designing this datastructure to follow the rules of a two dimensional rectangle, and that we really only care about the perimeter and the area of the rectange, we really just need to be able to retrieve the height and width of the rectangle. This will be our selectors. As for conforming to the rule of the rectangle, we could make the constructor always take in less parameters, and generate the other values to follow the rules of the rectangle.

#+name: rectangle-functions
#+begin_src racket :exports code
;; We are building the rectangle for this exercise such that the interface is
;; height and width
(define (area rectangle)
  (* (width rectangle) (height rectangle)))
(define (perimeter rectangle)
  (+ (* 2 (height rectangle)) (* 2 (width rectangle))))
#+end_src

#+RESULTS: rectangle-functions

** Implementation 1
We're not doing anything fancy in this first version. Constructor will take in bottom left corner and top right corner of the rectangle, and we will use that to represent a retangular object that has it's sides parallel to the two axis of the plane. Our selectors will just be for height and length.


#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
;; Takes two points as arguments. bottom-left is the bottom left point of a
;; rectange that is parallel to the plane axis. top-right is the top right
;; point of the same rectangle
(define (make-rectangle bottom-left top-right)
  (cons bottom-left top-right))
(define (width rectangle)
  (let ([left (x-point (car rectangle))]
        [right (x-point (cdr rectangle))])
    (abs (- left right))))
(define (height rectangle)
  (let ([top (y-point (cdr rectangle))]
        [bottom (y-point (car rectangle))])
    (abs (- top bottom))))

(assert-eq "area of (0,0) (2,2) is 4" (area (make-rectangle (make-point 0 0) (make-point 2 2))) 4)
(assert-eq "perimiter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-point -1 -1) (make-point 1 1)))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimiter of (-1, -1) (1, 1) is 8 value: 8 expected: 8
** Implementation 2
Let's allow orientation. This second version takes a segment representing the base of the rectangle and an integer representing the height of the rectangle

#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
;; Takes a segment representing the base and the height as arguments
(define (make-rectangle base height)
  (cons base height))
(define (width rectangle)
  (define (position-vector segment)
    (make-segment (make-point 0 0)
                  (make-point (- (x-point (end-segment segment)) (x-point (start-segment segment)))
                              (- (y-point (end-segment segment)) (y-point (start-segment segment))))))
  (define (square x)
    (* x x))
  (define (mag x y)
    (sqrt (+ (square x) (square y))))
  (let ([pos-tip (end-segment (position-vector (car rectangle)))])
    (mag (x-point pos-tip) (y-point pos-tip))))
(define (height rectangle)
  (cdr rectangle))

(assert-eq "area of (0,0) (2,2) is 4"
           (area (make-rectangle (make-segment (make-point 0 0) (make-point 0 2)) 2))
           4)
(assert-eq "perimeter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-segment (make-point -1 -1) (make-point 1 -1)) 2))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimeter of (-1, -1) (1, 1) is 8 value: 8 expected: 8


We can see that this second implementation is importing the same rectangle functions ~area~ and ~perimeter~, and we were able to achieve the same result.
* Exercise 2.4

With the new implementation of ~cons~ and ~car~ below, implement ~cdr~.

#+name: cons-override-1
#+begin_src racket :exports code
;; Makes a lambda that accepts a procedure and applies it on both members of
;; the pairs
(define (cons x y)
  (lambda (m) (m x y)))

;; Feeds a procedure that returns the first parameter
(define (car z)
  (z (lambda (p q) p)))

;; Our implementation just needs to return the second parameter
(define (cdr z)
  (z (lambda (p q) q)))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
<<cons-override-1>>
;; Takes two points as arguments. bottom-left is the bottom left point of a
;; rectange that is parallel to the plane axis. top-right is the top right
;; point of the same rectangle
(define (make-rectangle bottom-left top-right)
  (cons bottom-left top-right))
(define (width rectangle)
  (let ([left (x-point (car rectangle))]
        [right (x-point (cdr rectangle))])
    (abs (- left right))))
(define (height rectangle)
  (let ([top (y-point (cdr rectangle))]
        [bottom (y-point (car rectangle))])
    (abs (- top bottom))))

(assert-eq "area of (0,0) (2,2) is 4" (area (make-rectangle (make-point 0 0) (make-point 2 2))) 4)
(assert-eq "perimiter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-point -1 -1) (make-point 1 1)))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimiter of (-1, -1) (1, 1) is 8 value: 8 expected: 8

* Exercise 2.5
** Prompt
Show how we can hold a pair of non-negative integers using just numbers and arithmetic operations if we represent the pair ~a~ and ~b~ as \(2^{a}3^{b}\). Make the constructor and two selectors.
** Solution
2 and 3 have non-colliding powers. We could get ~a~ just by diving the representation by 2 until the remainder is no longer 0 and count the number of applications required to get there. As for the second element, we could do the same thing as the first element, but using 3 is the target value. This just means that we need to allow the accumulation procedure to take a mod parameter.

#+name: power-integer-pairs
#+begin_src racket :exports code
(define (pcons a b)
  (* (expt 2 a) (expt 3 b)))

;; We should move to using an iterative process instead of a recursive process
;; We should do the optimization using the sqaure property.
(define (count-div base val)
  (define (iter v acc)
    (if (= (remainder v base) 0)
        (iter (/ v base) (+ acc 1))
        acc))
  (iter val 0))

(define (pcar x)
  (count-div 2 x))
(define (pcdr x)
  (count-div 3 x))
#+end_src



#+begin_src racket :exports both :noweb yes
#lang sicp
<<power-integer-pairs>>
<<assertion-suite>>

(assert-eq "pcar (2, 4) = 2" (pcar (pcons 2 4)) 2)
(assert-eq "pcdr (2, 4) = 4" (pcdr (pcons 2 4)) 4)
#+end_src

#+RESULTS:
:
: pass: pcar (2, 4) = 2 value: 2 expected: 2
: pass: pcdr (2, 4) = 4 value: 4 expected: 4
* Exercise 2.6
We're doing Church encoding, but instead of the lamda calculus representation, it is scheme. I think this is one of the few cases where scheme is less readable. Luckily, this question only ask that we show the representation of one, two, and the actual definition of the addition procedure.

#+begin_src racket :exports code
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

Let's find one using ~add-1~ on ~zero~.

#+begin_src racket :exports code
(add-1 zero)
(add-1 (lambda (f) (lambda (x) x)))
(lambda (f) (lambda (x) (f ((lambda (f) (lambda (x) x))) f) x))
(lambda (f) (lambda (x) (f ((lambda (x) x) x) )))
(lambda (f) (lambda (x) (f x)))

(define one (lambda (f) (lambda (x) (f x))))
#+end_src

From doing this, we see that ~one~ is represented as a function that takes in a function ~f~ and create a new function that applies ~f~ once on the parameter.

#+begin_src racket :exports code
(add-1 one)
(add-1 (lambda (f) (lambda (x) (f x))))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (f (f x))))

(define two (lambda (f) (lambda (x) (f (f x)))))
#+end_src

Encoding for two is a higher order procedure that takes in a procedure ~f~ and produces a procedure that applies ~f~ twice on a parameter.

We can continue this line of reasoning to say that Church encoding of a non-negative integer ~n~ is a higher order procedure that takes in a procedure ~f~ and produces a procedure that applies ~f~ ~n~ times. Now to define addition in Scheme.

#+begin_src racket :exports code
(define (add a b)
  (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+end_src

To prove that this addition procedure works, we'll evaluate this with ~a~ as ~one~ and ~b~ as ~two~, and we should see that it evaluates to ~(lambda (f) (lambda (x) (f (f (f x)))))~.

#+begin_src racket :exports code
(add one two)
(add (lambda (f) (lambda (x) (f x))) (lambda (f) (lambda (x) (f (f x)))))
(lambda (f)
  (lambda (x) (((lambda (f) (lambda (x) (f x))) f) (((lambda (f) (lambda (x) (f (f x)))) f) x))))
(lambda (f) (lambda (x) ((lambda (x) (f x)) ((lambda (x) (f (f x))) x))))
(lambda (f) (lambda (x) ((lambda (x) (f x)) (f (f x)))))
(lambda (f) (lambda (x) (f (f (f x)))))
#+end_src

And as we expected, adding one and two gets us three.
* Exercise 2.7
Implement Alyssa P. Hacker's datastructure for interval operations.

#+name: interval-data-struct
#+begin_src racket :exports code
(define (make-interval a b) (cons a b))
(define (upper-bound z)
  (max (car z) (cdr z)))
(define (lower-bound z)
  (min (car z) (cdr z)))
#+end_src
* Exercise 2.8
** Prompt
Make a subtraction analogous for the interval datastructure.
** Solution
#+name: exercise-2.8
#+begin_src racket :exports code
(define (sub-interval a b)
  (make-interval (- (upper-bound a) (lower-bound b))
                 (- (lower-bound a) (upper-bound b))))
(define (add-interval a b)
  (make-interval (+ (upper-bound a) (upper-bound b))
                 (+ (lower-bound a) (lower-bound b))))

#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<interval-data-struct>>
<<exercise-2.8>>

(assert-eq "upper bound of [-2, 2] - [-8, 4] is 10"
           (upper-bound (sub-interval (make-interval 2 -2) (make-interval 4 -8)))
           10)
(assert-eq "upper bound of [-8, 4] - [-2, 2] is 6"
           (upper-bound (sub-interval (make-interval 4 -8) (make-interval 2 -2)))
           6)
#+end_src

#+RESULTS:
:
: pass: upper bound of [-2, 2] - [-8, 4] is 10 value: 10 expected: 10
: pass: upper bound of [-8, 4] - [-2, 2] is 6 value: 6 expected: 6
* Exercise 2.9
** Prompt
The width of an interval is half the difference of the upper and lower bound. For some arithmetic functions, the width of combining two variables is a function of only the width of the argument intervals while for some other arithmetic operations, this is not the case.

Show that for addition, the sum's interval is a function of only the widths of the argument intervals. After showing this, show that this is not the case for multiplication or division.
** Solution
Let's have a look at an example problem using addition.

\[\begin{aligned}
\text{let}~w = f_{w}(i) = \frac{u - l}{2},~ \text{where}~[l, u] = i \\
i_{3} = i_{1} + i_{2} = [l_{1} + l_{2}, u_{1} + u_{2} ] = [l_{3}, u_{3}] ~ \text{where}~ l_{3} = l_{1} + l_{2}, u_{3} = u_{1} + u_{2} \\
  \text{We will show that } w_{3} = w_{1} + w_{2} = f_{w}(i_{3}) \\
  f_{w}(i_{3}) = \frac{l_{3} + u_{3}}{2} = \frac{(l_{1} + u_{1}) + (l_{2} + u_{2}) }{2} \\
  \text{Knowing that}~ w_{1} = \frac{l_{1} + u_{1}}{2}, w_{2} = \frac{l_{2} + u_{2}}{2} \\
  f_{w}(i_{3}) = w_{1} + w_{2}
\end{aligned}\]

Now we will show that this is not the case for multiplication.

\[\begin{aligned}
		\text{We just need to show one case where the result width is not a function of the input width} \\
		i_{1} = \left[ 8, 10 \right], i_{2} = \left[ 2, 5 \right]                                        \\
		w_{1} = 1, w_{2} = 1.5; w_{1} \times w_{2} = 1.5                                                 \\
		i_{3} = i_{1} * i_{2} = \left[ 16, 50 \right]                                                    \\
		w_{3} = 17 != w_{1} \times w_{2}
	\end{aligned}\]

Did not think that it was necessary to show the same property for division since division is just a multiplication against a reciprocal.
* Exercise 2.10
** Prompt
Thanks to Ben Bitdiddle, we realize that we should be treating a division against an interval that spans zero as an error. Modify the procedure the Alyssa P. Hacker wrote to do this error handling.
** Solution
#+name: alyssa-multiplication
#+begin_src racket :exports code
(define (mul-interval x y)
  (let ([p1 (* (lower-bound x) (lower-bound y))]
        [p2 (* (lower-bound x) (upper-bound y))]
        [p3 (* (upper-bound x) (lower-bound y))]
        [p4 (* (upper-bound x) (upper-bound y))])
    (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4))))
#+end_src

#+name: exercise-2.10
#+begin_src racket :exports code
(define (div-interval x y)
  (define (zero-interval? a)
    (and (< (lower-bound a) 0) (> (upper-bound a) 0)))
  (let ([reciprocal-y (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))])
    (if (zero-interval? reciprocal-y)
        (error "cannot divide by zero")
        (mul-interval x reciprocal-y))))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<interval-data-struct>>
<<alyssa-multiplication>>
<<exercise-2.10>>

(assert-almost-eq "lower [8, 10] / [2, 4] is 2" (lower-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 2.0)
(assert-almost-eq "upper [8, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 5.0)

;; The following line should throw an error
(div-interval (make-interval 8 9) (make-interval -1 0.1))
#+end_src

#+RESULTS:
:
: pass: lower [8, 10] / [2, 4] is 2 value: 2.0 expected: 2.0
: pass: upper [8, 10] / [2, 4] is 5 value: 5.0 expected: 5.0

We see that the procedure will operate normally when not dividing by zero, and thrown an error if it does divide by an interval that covers zero.
* Exercise 2.11
** Prompt
We can make the ~mul-interval~ procedure use less multiplication operations by breaking it down into 9 cases. Only one of these cases will require more than two multiplication. Implementate this improved version of ~mul-interval~.

** Solution
#+name: exercise-2.11
#+begin_src racket :exports code
(define (mul-interval x y)
  (let ([a (lower-bound x)]
        [b (upper-bound x)]
        [c (lower-bound y)]
        [d (upper-bound y)])
    (cond
      [(and (>= a 0) (>= b 0) (>= c 0) (>= d 0)) (make-interval (* a c) (* b d))]
      [(and (< a 0) (>= b 0) (>= c 0) (>= d 0)) (make-interval (* a d) (* b d))]
      [(and (>= a 0) (>= b 0) (< c 0) (>= d 0)) (make-interval (* c b) (* b d))]
      [(and (< a 0) (< b 0) (>= c 0) (>= d 0)) (make-interval (* a d) (* b c))]
      [(and (>= a 0) (>= b 0) (< c 0) (< d 0)) (make-interval (* b c) (* a d))]
      [(and (< a 0) (>= b 0) (< c 0) (>= d 0))
       (make-interval (min (* a d) (* c b)) (max (* a c) (* b d)))]
      [(and (< a 0) (>= b 0) (< c 0) (< d 0)) (make-interval (* b c) (* a c))]
      [(and (< a 0) (< b 0) (< c 0) (>= d 0)) (make-interval (* a d) (* a c))]
      [(and (< a 0) (< b 0) (< c 0) (< d 0)) (make-interval (* b d) (* a c))])))
#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<exercise-2.11>>
<<assertion-suite>>
<<interval-data-struct>>
<<exercise-2.10>>

(assert-almost-eq "lower [8, 10] / [2, 4] is 2" (lower-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 2.0)
(assert-almost-eq "upper [8, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 5.0)
(assert-almost-eq "lower [-10, 10] / [2, 4] is -5" (lower-bound (div-interval (make-interval -10 10) (make-interval 2 4))) -5)
(assert-almost-eq "upper [-10, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval -10 10) (make-interval 2 4))) 5)
(assert-almost-eq "lower [-10, 10] * [-20, 14] is -200" (lower-bound (mul-interval (make-interval -10 10) (make-interval -20 14))) -200)
(assert-almost-eq "upper [-10, 10] * [-20, 14] is 200" (upper-bound (mul-interval (make-interval -10 10) (make-interval -20 14))) 200)

;; The following line should throw an error
(div-interval (make-interval 8 9) (make-interval -1 0.1))
#+end_src

#+RESULTS:
:
: pass: lower [8, 10] / [2, 4] is 2 value: 2.0 expected: 2.0
: pass: upper [8, 10] / [2, 4] is 5 value: 5.0 expected: 5.0
: pass: lower [-10, 10] / [2, 4] is -5 value: -5.0 expected: -5
: pass: upper [-10, 10] / [2, 4] is 5 value: 5.0 expected: 5
: pass: lower [-10, 10] * [-20, 14] is -200 value: -200 expected: -200
: pass: upper [-10, 10] * [-20, 14] is 200 value: 200 expected: 200
* Exercise 2.12
** Prompt
Alyssa made an alternate constructor and selectors that represents the following \(c \pm w\). Now make a version that does percentage tolerance in the following form. \(c \pm p \%\). Also provide the percent selector.
** Solution
#+name: center-width-rep
#+begin_src racket :exports code
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (center x)
  (/ (+ (upper-bound x) (lower-bound x)) 2))
(define (width x)
  (/ (- (upper-bound x) (lower-bound x)) 2))
#+end_src

#+name: exercise-2.12
#+begin_src racket :exports code
(define (percent i)
  (* 100 (/ (width i) (abs (center i)))))

(define (make-center-percent c p)
  (let ([width (* (abs c) (/ p 100))]) (make-center-width c width)))
#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<interval-data-struct>>
<<center-width-rep>>
<<exercise-2.12>>
<<assertion-suite>>

(assert-eq "construct and then assert" (percent (make-center-percent 10 10)) 10)
#+end_src

#+RESULTS:
:
: pass: construct and then assert value: 10 expected: 10
* Exercise 2.13
** Prompt
Show that under small percentage tolerance, there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors.
** Solution
By working on exercise 2.14, we know exactly what this approximation is. At small percentage, the percentage tolerance of the product is equal to the sum of the percentage tolerance of the operands. At larger values, this breaks down.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<interval-data-struct>>
<<center-width-rep>>
<<exercise-2.12>>
<<exercise-2.11>>
<<exercise-2.10>>
<<exercise-2.8>>
<<assertion-suite>>
(define a (make-center-percent 80 0.5))
(define b (make-center-percent 210 0.8))

(assert-almost-eq "the percentage tolerance of a * b should be very close to percent tolerance a + percent tolerance b" (percent (mul-interval a b)) (+ (percent a) (percent b)))
#+end_src

#+RESULTS:
:
: pass: the percentage tolerance of a * b should be very close to percent tolerance a + percent tolerance b value: 1.2999480020799254 expected: 1.3000000000000105

* Exercise 2.14
** Prompt
The previous implementation of interval was flawed in that it was unable to give the same answer in two equivalent but different equation for the parallel resistor. Run some experiment and investigate why this issue is occurring.
** Investigation
#+begin_src racket :exports code
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2) (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ([one (make-interval 1 1)])
    (div-interva
#+end_src
*** Experiments
#+begin_src racket :exports both :noweb yes
#lang sicp
<<interval-data-struct>>
<<center-width-rep>>
<<exercise-2.12>>
<<exercise-2.11>>
<<exercise-2.10>>
<<exercise-2.8>>
(define a (make-center-percent 80 0.5))
(define b (make-center-percent 210 0.8))
(define a-prime (make-center-percent 80 40))
(define b-prime (make-center-percent 210 60))
(define c (make-center-percent 80 0.7))

(center (div-interval a a))
(percent (div-interval a a))
(center (div-interval a b))
(percent (div-interval a b))
(newline)
(display "210 +- 8% / 80 +- 5%")
(newline)
(center (div-interval a-prime b-prime))
(percent (div-interval a-prime b-prime))

(center (div-interval b a))
(percent (div-interval b a))
(center (div-interval c c))
(percent (div-interval c c))
(center (add-interval c c))
(percent (add-interval c c))
(center (add-interval c a))
(percent (add-interval c a))
(center (add-interval b a))
(percent (add-interval b a))
(center (sub-interval b a))
(percent (sub-interval b a))
(newline)
(display "210 +- 0.8% - 80 +- 0.7%")
(newline)
(center (sub-interval b c))
(percent (sub-interval b c))
(center (mul-interval c c))
(percent (mul-interval c c))
#+end_src

#+RESULTS:
#+begin_example
1.000050001250031
0.9999750006249956
0.38099200253578136
1.2999480020799312

210 +- 8% / 80 +- 5%
0.738095238095238
80.64516129032259
2.6251706292657317
1.299948002079925
1.0000980048022352
1.3999314033612358
160.0
0.7000000000000028
160.0
0.600000000000005
290.0
0.7172413793103589
130.0
1.6000000000000099

210 +- 0.8% - 80 +- 0.7%
130.0
1.7230769230769298
6400.3136
1.399931403361241
#+end_example

Interesting. In the previous implementation of the interval class, addition will cause the sum's percent to be the weighted average of the two operands. Multiplication and division will cause the product and quotient to have a percent tolerance that is the sum of the operands. Subtraction will see the tolerance increase due to multiple factors.
* Exercise 2.15
** Prompt
Eva Lu Ator says that since different intervals are calculated when using different but algebraically equivalent expressions. Eva then claims that using forms that do not repeat the same uncertain variable would produce a tighter output uncertainty, and that therefore, this is the better method. Is she correct? Why?
** Solution
Problem was that the implementation is not consistent between different equivalent algebraic problems. There should not be a better method, but Eva is correct, using this implementation, we should operate on the unique variables with uncertainty once. Specifically, what seems to be happening is that repeated operations seem to assume that there are more than one uncertain variables.
* Exercise 2.16
** Prompt
Explain why different equivalent algebraic expressions will result in different result interval. Can we devise a package that can solve this problem? Given with warning that this is a difficult task.
** Solution
I will not be attempting to build my own library for intervals, as I have things to be and placed to do. As stated in the 2.15 solution, if the same interval object is used in multiple placed, it eventually propagates its uncertainty back on itself as if they are not the same value. I am choosing to not continue to dwell on this topic, as I have places to do, and things to be.
* Exercise 2.17
** Prompt
Implement a procedure called ~last-pair~ that will return the last element of a list.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (last-pair items)
  (cond ((null? items) items)
        ((null? (cdr items)) (car items))
        (else (last-pair (cdr items)))))
(last-pair (list 1 2 43 5 12 90 58))
#+end_src

#+RESULTS:
: 58
* Exercise 2.18
** Prompt
Define reverse that will reverse a list
** Solution
Will be solving this problem using an iterative process
#+begin_src racket :exports both
#lang sicp
(define (reverse items)
  (define (iter acc nav)
    (if (null? nav)
        acc
        (iter (cons (car nav) acc) (cdr nav))))
  (iter nil items)
  )

(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)
* Exercise 2.19
** Prompt
Upgrade change counting algorithm to take the coin value as parameter as well.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (cc amount coin-values)
  (define (except-first-denomination items)
    (cdr items))
  (define (first-denomination items)
    (car items))
  (define (no-more? items)
    (null? items))
  (cond
    [(= amount 0) 1]
    [(or (< amount 0) (no-more? coin-values)) 0]
    [else
     (+ (cc amount (except-first-denomination coin-values))
        (cc (- amount (first-denomination coin-values)) coin-values))]))

(define us-coin (list 25 10 50 5 1))
(define uk-coin (list 100 50 20 10 5 2 1 0.5))

(cc 100 us-coin)
#+end_src

#+RESULTS:
: 292

Here is the learning from doing this exercise. Yes we could have just done the low level list access procedures in the cc procedure, but by defining these external access methods, we are abstracting out the lower level implementation. It is up to us to think about whether our data structure would need an abstraction layer or not.

This is a combination problem, the order of the elements in the list do not matter. If this is incorrect, and you are looking at my github, please create an issue to address this.
* Exercise 2.20
** Prompt
We can see that there are procedures in scheme that can take in a dynamic number of arguments. Well, we're going to learn how to do that here.

We can achieve this by using ~define~ with a /dotted-tail/ notation.

#+begin_src racket :exports code
(define (f a b c . z) (<body>))
(define (g . x) (<body>))
#+end_src

Semantically, this is the same as doing the following in Python. Excuse me for not just explaining it in plain English.

#+begin_src python :exports code
def f(a, b, c, *z):
    ...

def g(*x):
    ...
#+end_src

Now build a procedure called same parity that takes in a dynamic number of input and then only return the content of the input that matches the parity of the input.

** Solution
#+begin_src racket :exports both
#lang sicp
(define (same-parity x . y)
  (define (choose-predicate a)
    (if (even? a) even? odd?))
  ;; I suppose that I really just made filter. Whoops.
  (define (choose predicate items)
    (cond ((null? items) nil)
          ((predicate (car items))
           (cons (car items) (choose predicate (cdr items))))
          (else (choose predicate (cdr items)))))
  (choose (choose-predicate x) (cons x y)))

(same-parity 1 2 3 4 5 6 7)
(same-parity 2 3 4 5 6 7)
#+end_src

#+RESULTS:
: (1 3 5 7)
: (2 4 6)
* Exercise 2.21
** Prompt
Make the two implementation of ~square-list~ that will take a list of numbers and return a list of the square of those numbers.
** Solution
*** First solution
First implementation without using ~map~.
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
(define (square-list items)
  (if (null? items)
      nil
      (cons (square (car items)) (square-list (cdr items)))))
(square-list (list 1 2 3 4))
#+end_src

#+RESULTS:
: (1 4 9 16)
*** Map solution
Yes, the map solution is cleaner, why wouldn't it be?
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
(define (square-list items)
  (map square items))
(square-list (list 1 2 3 4))
#+end_src

#+RESULTS:
: (1 4 9 16)
* Exercise 2.22
** Prompt
Louis Reasoner tried to make the ~square-list~ function and his implementation produces a list in reverse order. Why is this the case? Then he made a second version of the code that does not work. Listings available below.
#+caption: Reversed list output
#+begin_src racket :exports code
#lang sicp
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
#+end_src

#+caption: Just does not work
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things) (cons answer (square (car things))))))
  (iter items nil))

(square-list (list 1 2 3 4))
#+end_src

#+RESULTS:
: ((((() . 1) . 4) . 9) . 16)

** Solution
The first listing is reversed because our Scheme list implementation only allows for appending from one direction. This means the iterative algorithms that builds a list as it is traversing another one will build a reversed list.

The second listing does not work because we are no longer following the semantics of a Scheme list. The list is being built in reverse order.
* Exercise 2.23
** Prompt
We learn what a ~for-each~ is, which is just ~map~ but no return. Good for just doin(define (make-from-real-imag
         x y)
  (define (dispatch op)
    (cond [(eq? op 'real-part) x]
          [(eq? op 'imag-part) y]
          [(eq? op 'magnitude) (sqrt (+ (square x) (square y)))]
          [(eq? op 'angle) (atan y x)]
          [else (error "unknown op: MAKE-FROM-REAL-IMAG" op)]))
  dispatch)g side effects. Make an implementation of ~for-each~
** Solution
We have an implementation of ~for-each~ using the ~let~ procedure.
#+begin_src racket :exports both
#lang sicp
(define (for-each f items)
  (if (not (null? items))
      (let ([app (f (car items))]) (for-each f (cdr items)))))

(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
#+end_src

#+RESULTS:
:
: 57
: 321
: 88
* Exercise 2.24
** Prompt
Show the result of ~(list 1 (list 2 (list 3 4)))~ from the interpreter, followed by the box and pointer diagram and the tree diagram of the structure.
** Solution
For the first part, I will just let the interpreter do the printing for me.

#+begin_src racket :exports both
#lang sicp
(list 1 (list 2 (list 3 4)))
#+end_src

#+RESULTS:
: (1 (2 (3 4)))

Second and third part will be done using uml.

#+caption: Box and pointer diagram of the given structure.
#+begin_src plantuml :exports results :file ./images/exercise-2.24-1.png
@startuml
rectangle p00
rectangle p01
rectangle p10
rectangle p11
rectangle p20
rectangle p21

p00 --> 1
p00 -> p01
p01 --> p10

p10 --> 2
p10 -> p11
p11 --> p20

p20 --> 3
p20 -> p21
p21 --> 4

@enduml
#+end_src

#+caption: Box and pointer diagram of the given structure.
#+RESULTS:
[[file:./images/exercise-2.24-1.png]]

Box and pointer representation does hide the fact that the hierarchical structure is built on top of the Scheme pairs.

#+caption: Tree representation of the given structure.
#+begin_src plantuml :exports results :file ./images/exercise-2.24-2.png
@startuml
rectangle "(list 1 (list 2 (list 3 4)))" as p0
rectangle "(list 2 (list 3 4))" as p1
rectangle "(list 3 4)" as p2

p0 --> 1
p0 --> p1

p1 --> 2
p1 --> p2

p2 --> 3
p2 --> 4

@enduml
#+end_src

#+caption: Tree representation of the given structure.
#+RESULTS:
[[file:./images/exercise-2.24-2.png]]

Tree representation abstracts away the implementation detail of using pairs.
* Exercise 2.25
** Prompt
Pick 7 from the following list using ~car~ and ~cdr~.
#+begin_src racket :exports code
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
#+end_src
** Solution
Here are the calls using just ~car~ and ~cdr~ to get the 7 in each of the lists.
#+begin_src racket :exports both
#lang sicp
(define first (list 1 3 (list 5 7) 9))
(define second (list (list 7)))
(define third (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))

(car (cdr (car (cdr (cdr first)))))
(car (car second))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr third))))))))))))
#+end_src

#+RESULTS:
: 7
: 7
: 7
* Exercise 2.26
** Prompt
Say what the output of the following list manipulation procedures.

#+begin_src racket :exports code
(define x (list 1 2 3))
(define y (list 4 5 6))
#+end_src

#+begin_src racket :exports code
(append x y)
(cons x y)
(list x y)
#+end_src
** Solution
I am writing what I see as the solution before evaluating these procedures using the interpreter.

#+begin_src racket :exports code
(1 2 3 4 5 6)
;; This is a pair, and I know that this is how racket displays this
((1 2 3) . (4 5 6))
((1 2 3) (4 5 6))
#+end_src

Now we can evaluate for proof.

#+begin_src racket :exports both
#lang sicp
(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y)
(cons x y)
(list x y)
#+end_src

#+RESULTS:
: (1 2 3 4 5 6)
: ((1 2 3) 4 5 6)
: ((1 2 3) (4 5 6))

Alright, I must admit that I was wrong. Here is what we can see. The second line is using ~cons~ on two list. Remembering what ~cons~ does, with respect to the abstraction of list, we know that ~cons~ actually appends to the front of the list. This is why we see ~x~ as the new first element of list ~y~.
* Exercise 2.27
** Prompt
Modify the solution to [[*Exercise 2.18][Exercise 2.18]] to make a procedure called ~deep-reverse~ that will reverse the main list, as well as the sub-lists.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (deep-reverse items)
  (define (iter acc nav)
    (cond ((null? nav) acc)
          ((pair? (car nav)) (iter (cons (deep-reverse (car nav)) acc) (cdr nav)))
          (else (iter (cons (car nav) acc) (cdr nav)))))
  (iter nil items)
  )

(deep-reverse (list 1 2 3 4))
(deep-reverse (list (list 1 2) (list 3 4)))
#+end_src

#+RESULTS:
: (4 3 2 1)
: ((4 3) (2 1))

This is working as expected.
* Exercise 2.28
** Prompt
Make a procedure called ~fringe~ that takes a tree make of list as input, and then outputs a list with all the leaves arranged from left to right order.
** Solution
We could re-frame the problem into flattening a list. Since I have done some of Cornell's cs3110, I know the spoiler of having to reverse the list if it is generated recursively.

#+begin_src racket :exports both
#lang sicp

(define (reverse items)
  (define (iter acc nav)
    (if (null? nav)
        acc
        (iter (cons (car nav) acc) (cdr nav))))
  (iter nil items))

(define (fringe tree)
  (define (iter acc sub-tree)
    (cond
      [(null? sub-tree) acc]
      [(pair? (car sub-tree)) (iter (iter acc (car sub-tree)) (cdr sub-tree))]
      [else (iter (cons (car sub-tree) acc) (cdr sub-tree))]))
  (reverse (iter nil tree)))

(define x (list (list 1 2) (list 3 4)))
(fringe x)
(fringe (list x x))
(let ([y (list x x)]) (fringe (list y y)))
#+end_src

#+RESULTS:
: (1 2 3 4)
: (1 2 3 4 1 2 3 4)
: (1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4)

This is lovely, but the downside is that it is not truly an iterative process, since there are branches that would cause the previous scope to wait for a new iterative process to finish evaluation. Still, this lowers the growth of memory when there are long lists in the tree.
* Exercise 2.29
** Prompt
Working with the concept of a binary mobile, which has the following constructors.
#+begin_src racket :exports code
;; make-mobile makes a binary mobile. left and right are branches.
(define (make-mobile left right) (list left right))
;; make-branch is the constructor for a branch. length must be an integer, and
;; structure could either be a number or another mobile
(define (make-branch length structure) (list length structure))
#+end_src
*** Local Analysis
This problem is introducing the concept of indirect recursive data structure.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (make-mobile left right)
  (list left right))
(define (make-branch length structure)
  (list length structure))

;; Part a. make a selector for mobile called left-branch and right-branch.
;; Make a selector for branches called branch-length and branch-structure
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile)))

(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (car (cdr branch)))

(left-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))
(right-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))

(branch-length (make-branch 2 4))
(branch-structure (make-branch 2 4))

;; Part b. define a procedure called total weight that will return the total
;; weight of the mobile.
;; We're really looking to accumulate the sum of the weights, with the
;; assumption that the mobile type does not have a weight associated with it.
;; Branches are actually tagged unions, so we should have a predicate that
;; determines the type. Base case is that we have reached a branch that is a
;; weight, then we could return the value.

(define (mobile? x)
  (pair? x))

(define (total-weight mobile)
  (define (total-weight-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (total-weight local-structure)
          local-structure)))
  (+ (total-weight-branch (left-branch mobile)) (total-weight-branch (right-branch mobile))))

(define test-mobile-1
  (make-mobile
   (make-branch 4 (make-mobile (make-branch 2 2) (make-branch 4 2)))
   (make-branch 7
                (make-mobile (make-branch 3 (make-mobile (make-branch 3 3) (make-branch 3 12)))
                             (make-branch 2 2)))))

;; expect the total-weight to be 21 for test-mobile-1
(total-weight test-mobile-1)

;; Part c. Make a predicate that will determine if the mobile is balanced,
;; where balanced means that the torque of the left and right branch is
;; equal, and all the mobiles underneath are balanced as well. As a reminder,
;; torque is the product of the length of the rod and the weight it is
;; carrying.
;; For the sake of computational efficiency, we're going to calculate this
;; predicate as we traverse the tree
(define (balanced? mobile)
  (define (get-torque x)
    (car x))
  (define (get-branch-weight x)
    (cdr x))
  ;; handle-branch should return a pair of the torque and weight or propagate a
  ;; nil
  (define (handle-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (let ([mobile-return (handle-mobile local-structure)])
            (if (null? mobile-return)
                mobile-return
                (cons (* (branch-length branch) mobile-return) mobile-return)))
          (cons (* (branch-length branch) local-structure) local-structure))))
  ;; handle-mobile should either return a nil if it does not find the mobile
  ;; parameter to be balanced, else return the sum of the weight of the
  ;; two branches.
  (define (handle-mobile mobile)
    (let ([left (handle-branch (left-branch mobile))]
          [right (handle-branch (right-branch mobile))])
      (cond
        [(or (null? left) (null? right)) nil]
        [(= (get-torque left) (get-torque right))
         (+ (get-branch-weight left) (get-branch-weight right))]
        [else nil])))
  (not (null? (handle-mobile mobile))))

(balanced? test-mobile-1)
(balanced? (make-mobile (make-branch 1 1)
                        (make-branch 1 1)))
(balanced? (make-mobile (make-branch 1 8)
                        (make-branch 2 4)))
(balanced? (make-mobile (make-branch 1 (make-mobile (make-branch 1 4)
                                                    (make-branch 1 4)))
                        (make-branch 2 4)))


#+end_src

#+RESULTS:
: (2 2)
: (3 3)
: 2
: 4
: 21
: #f
: #t
: #t
: #t

In part d of the exercise, we are changing the implementation of the constructor. How many procedures must change to keep the functionality the same?

#+caption: Constructor and data structure representation changes.
#+begin_src racket :exports code
(define (make-mobile left right) (cons left right))
(define (make-branch length structure) (cons length structure))
#+end_src

The answer is just the ~cdr~ selectors, since we are using the abstraction for data structure access in all higher level procedures that work with this system. Swapping from list to pair means that you no longer need the ~car~ to access the second element, since the pair here does not need the facility to allow for dynamic extension.

#+begin_src racket :exports both
#lang sicp
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))

;; Part a. make a selector for mobile called left-branch and right-branch.
;; Make a selector for branches called branch-length and branch-structure
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))

(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))

(left-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))
(right-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))

(branch-length (make-branch 2 4))
(branch-structure (make-branch 2 4))

;; Part b. define a procedure called total weight that will return the total
;; weight of the mobile.
;; We're really looking to accumulate the sum of the weights, with the
;; assumption that the mobile type does not have a weight associated with it.
;; Branches are actually tagged unions, so we should have a predicate that
;; determines the type. Base case is that we have reached a branch that is a
;; weight, then we could return the value.

(define (mobile? x)
  (pair? x))

(define (total-weight mobile)
  (define (total-weight-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (total-weight local-structure)
          local-structure)))
  (+ (total-weight-branch (left-branch mobile)) (total-weight-branch (right-branch mobile))))

(define test-mobile-1
  (make-mobile
   (make-branch 4 (make-mobile (make-branch 2 2) (make-branch 4 2)))
   (make-branch 7
                (make-mobile (make-branch 3 (make-mobile (make-branch 3 3) (make-branch 3 12)))
                             (make-branch 2 2)))))

;; expect the total-weight to be 21 for test-mobile-1
(total-weight test-mobile-1)

;; Part c. Make a predicate that will determine if the mobile is balanced,
;; where balanced means that the torque of the left and right branch is
;; equal, and all the mobiles underneath are balanced as well. As a reminder,
;; torque is the product of the length of the rod and the weight it is
;; carrying.
;; For the sake of computational efficiency, we're going to calculate this
;; predicate as we traverse the tree
(define (balanced? mobile)
  (define (get-torque x)
    (car x))
  (define (get-branch-weight x)
    (cdr x))
  ;; handle-branch should return a pair of the torque and weight or propagate a
  ;; nil
  (define (handle-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (let ([mobile-return (handle-mobile local-structure)])
            (if (null? mobile-return)
                mobile-return
                (cons (* (branch-length branch) mobile-return) mobile-return)))
          (cons (* (branch-length branch) local-structure) local-structure))))
  ;; handle-mobile should either return a nil if it does not find the mobile
  ;; parameter to be balanced, else return the sum of the weight of the
  ;; two branches.
  (define (handle-mobile mobile)
    (let ([left (handle-branch (left-branch mobile))]
          [right (handle-branch (right-branch mobile))])
      (cond
        [(or (null? left) (null? right)) nil]
        [(= (get-torque left) (get-torque right))
         (+ (get-branch-weight left) (get-branch-weight right))]
        [else nil])))
  (not (null? (handle-mobile mobile))))

(balanced? test-mobile-1)
(balanced? (make-mobile (make-branch 1 1) (make-branch 1 1)))
(balanced? (make-mobile (make-branch 1 8) (make-branch 2 4)))
(balanced? (make-mobile (make-branch 1 (make-mobile (make-branch 1 4) (make-branch 1 4)))
                        (make-branch 2 4)))
#+end_src

#+RESULTS:
: (2 . 2)
: (3 . 3)
: 2
: 4
: 21
: #f
: #t
: #t
: #t

And we can see that this was an acceptable refactor. We changed 2 procedures to accommodate for the change in the data structure representation.
* Exercise 2.30
** Prompt
Make a procedure ~square-tree~ that is analogous to the ~square-list~ procedure in exercise [[*Exercise 2.21][Exercise 2.21]]. Do this exercise with and without the ~map~ procedure.
** Solution
#+caption: Square tree without using map
#+begin_src racket :exports both
#lang sicp

(define (square x)
  (* x x))
(define (square-tree tree)
  (cond
    [(null? tree) nil]
    [(pair? tree) (cons (square-tree (car tree)) (square-tree (cdr tree)))]
    [else (square tree)]))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

#+caption: Square tree using map
#+begin_src racket :exports both
#lang sicp

(define (square x)
  (* x x))
(define (square-tree tree)
  (map (lambda (x)
         (if (pair? x)
             (square-tree x)
             (square x)))
       tree))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

I'll say, the ~map~ version of the implementation was actually easier to reason about.
* Exercise 2.31
** Prompt
Abstract tree map out of the previous implementation. Design such that the definition of ~square-tree~ from [[*Exercise 2.30][Exercise 2.30]] looks like the following code block.
#+begin_src racket :exports code
(define (square-tree tree) (tree-map square tree))
#+end_src
** Solution
For the sake of reuse, I'll implement this using the pre-existing ~map~ procedure.

#+begin_src racket :exports both
#lang sicp

(define (tree-map f items)
  (map (lambda (x)
         (if (pair? x)
             (tree-map f x)
             (f x)))
       items))

(define (square x)
  (* x x))
(define (square-tree tree)
  (tree-map square tree))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

Just like that, we have a clean and efficient implementation of tree map.
* Exercise 2.32
** Prompt
Knowing the definition of a set, make a procedure that generates a set of subsets using the given code.
** Solution
#+begin_src racket :exports both
#lang sicp

;; Invariant, s is a set that is represented as a list. This means that this
;; list should have no duplicate elements.
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ([rest (subsets (cdr s))]) (append rest (map (lambda (x) (cons (car s) x)) rest)))))

;; this should return (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
(subsets (list 3))
(subsets (list 2 3))
(subsets (list 1 2 3))
#+end_src

#+RESULTS:
: (() (3))
: (() (3) (2) (2 3))
: (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))

In this problem, we are working with a power set. The pattern is that we want the combination of all the elements of the input set. Recursive approach is the following. Since we are returning a set of set, the base case is the very last element of the input set, which is nil. Then the recursion case goes back one layer, where we are working with an input set of 3 and nil. This layer has two elements in the input set, and we have the power-set of the tail of the input set. Now we generate the next layer output by appending the power-set of the tail with a set of the head of the set with the power-set of the tail. The set of the head appended to the power-set of the tail will create the rest of the elements that would appear upon adding the head element to the input set. Excuse the less than clear explanation, the writer of this file did not have a very formal mathematical background.
* Exercise 2.33
** Prompt
This is the first element after learning about sequence operations and how it contributes to modular design. Task for this exercise is to define ~map~, ~append~, and ~length~ in terms of accumulate.
** Solution
This exercise makes us use right fold to achieve different solutions.
#+begin_src racket :exports both
#lang sicp
;; Accumulate designed as right fold
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))

(accumulate (lambda (x y) (+ x y)) 0 (list 1 2 3 4))

;; This implementation requires that the accumulate function be a right fold,
;; else we would not be able to build like this.
(define (map p sequence)
  (accumulate (lambda (x y)
                (cons (p x) y))
              nil
              sequence))

(map (lambda (x) (* x x)) (list 1 2 3 4))

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(append (list 1 2) (list 3 4))

(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))

(length nil)
(length (list 1 2 2 2 2))
#+end_src

#+RESULTS:
: 10
: (1 4 9 16)
: (1 2 3 4)
: 0
: 5
* Exercise 2.34
** Prompt
Using Horner's rule, evaluate the polynomial as an accumulation.

\[a_{n} x^{n} + a_{n-1}x^{n -1} + \cdots + a_{1} x + a_{0} \rightarrow \left( \cdots \left( a_{n} x + a_{n-1} \right) x + \cdots + a_{1} \right) x + a_{0}\]
** Solution
Horner's rule brings the evaluation of the \(x\) term into a recursive case, which also reduces the number of multiplication that is happening. This can be done in a single accumulation sequence operation.

#+begin_src racket :exports both
#lang sicp
;; Accumulate designed as right fold
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))

;; coefficient-sequence is given in order or a_0 to a_n
(define (horner-eval x coefficient-sequence)
  ;; accumulate must be a right fold for this implementation
  (accumulate (lambda (curr-coefficient accumulation) (+ curr-coefficient (* x accumulation)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 1 1))
(horner-eval 2 (list 1 3 0 5 0 1))
#+end_src

#+RESULTS:
: 7
: 79

Cool note. Horner's rule is the most optimal algorithm for polynomial evaluation.
* Exercise 2.35
** Prompt
Redefine ~count-leaves~ from section 2.2.2 as an accumulation.
** Solution
#+begin_src racket :exports both
#lang sicp

;; still using right fold for accumulation
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))
;; Procedure under test
(define (count-leaves t)
  (accumulate +
              0
              (map (lambda (x)
                     (if (pair? x)
                         (count-leaves x)
                         1))
                   t)))

(count-leaves (list 1 (list 3 4) 5))
#+end_src

#+RESULTS:
: 4

Modularity is a powerful tool for designing software.
* Exercise 2.36
** prompt
Make a procedure called ~accumulate-n~ where the third parameter is a sequence of equal length sequences. The accumulation will now happen on the different sequences at the same index.

#+caption: Example output
#+begin_src racket :exports code
(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
(22 26 30)
#+end_src

A template for the solution was provided. Work within the constraint.
** Solution

#+begin_src racket :exports both
#lang sicp

;; still using right fold for accumulation
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))
(define (accumulate-n op initial seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op initial (map car seqs))
            (accumulate-n op initial (map cdr seqs)))))

(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
#+end_src

#+RESULTS:
: (22 26 30)

Our solution uses sequence operators to quickly build this system. Hoping that this is sufficiently modular.
* Exercise 2.37
** Prompt
Matrix operation. Vectors \(v\) are sequences of numbers and matrices are sequence of equal length vectors. Implement ~dot-product~, ~matrix-*-vector~, ~matrix-*-matrix~, and ~transpose~. Note that the implementation of the matrix is a list of list by rows.
** Solution
#+begin_src racket :exports both
#lang sicp
;; still using right fold for accumulation
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))
;; Need to use this for transpose
(define (accumulate-n op initial seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op initial (map car seqs)) (accumulate-n op initial (map cdr seqs)))))

(define (dot-product v w)
  (accumulate + 0 (map * v w))) ;; This is using expanded map

(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))
;; This implementation is reliant on accumulate-n being a right fold.
(define (transpose mat)
  (accumulate-n cons nil mat))

(define (matrix-*-matrix m n)
  (let ([cols (transpose n)])
    (map (lambda (x) (matrix-*-vector cols x)) m)))

(dot-product (list 1 2 3) (list 4 5 6))
(matrix-*-vector (list (list 1 2) (list 3 4)) (list 5 6))
(transpose (list (list 1 2) (list 3 4)))
(matrix-*-matrix (list (list 1 2) (list 3 4)) (list (list 5 6) (list 7 8)))
#+end_src

#+RESULTS:
: 32
: (17 39)
: ((1 3) (2 4))
: ((19 22) (43 50))

We got the expected values out of this implementation. This implementation does not focus on getting the best cache hits, but instead it was all about modularity and reusing abstractions created as we implement each of the matrix operations.
* Exercise 2.38
** Prompt
We realize that we were using a right fold for accumulate previously. Now we introduce a fold left procedure that operates from left to right. This implementation is an iterative process.
#+caption: Implementation of fold left and fold right
#+begin_src racket :exports code
(define (fold-right p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (fold-right p initial (cdr sequence)))))

(define (fold-left op initial seq)
  (define (iter acc s)
    (if (null? s)
        acc
        (iter (op acc (car s))
              (cdr s))))
  (iter initial seq))
#+end_src

Find the value of the following operations.
#+begin_src racket :exports code
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#+end_src
** Solution
#+caption: Solution (before verifying)
#+begin_src racket :exports code
;; (fold-right / 1 (list 1 2 3))
(/ 1 (/ 2 (/ 3 1)))
(3/2)
;; (fold-left / 1 (list 1 2 3))
(/ (/ (/ 1 1) 2) 3)
(1/6)
;; (fold-right list nil (list 1 2 3))
(list 1 (list 2 (list 3 nil)))
(1 (2 (3 ())))
;; (fold-left list nil (list 1 2 3))
(list (list (list nil 1) 2) 3)
(((() 1) 2) 3)
#+end_src

With that solution done, we should verify the result.

#+begin_src racket :exports both
#lang sicp
(define (fold-right p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (fold-right p initial (cdr sequence)))))

(define (fold-left op initial seq)
  (define (iter acc s)
    (if (null? s)
        acc
        (iter (op acc (car s))
              (cdr s))))
  (iter initial seq))
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#+end_src

#+RESULTS:
: 3/2
: 1/6
: (1 (2 (3 ())))
: (((() 1) 2) 3)

Nice, we were correct about the semantics of the problem. Now to talk about the property of the operator that would make ~fold-left~ and ~fold-right~ return the same value. That operator property is the commutative property. Commutative property is a property that means that the operator will produce the same output if you swap the position of the operands.
* Exercise 2.39
** Prompt
Define ~reverse~ using both ~fold-left~ and ~fold-right~.
** Solution
#+caption: Fold right implementation of reverse.
#+begin_src racket :exports both
#lang sicp
(define (fold-right p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (fold-right p initial (cdr sequence)))))

(define (reverse seq)
  (fold-right (lambda (x y) (if (null? y)
                                (cons x nil)
                                (append y (cons x nil)))) nil seq))

(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)

The fold right implementation requires the use of the append procedure, which is inefficient.

#+caption: Fold left implementation of reverse.
#+begin_src racket :exports both
#lang sicp
(define (fold-left op initial seq)
  (define (iter acc s)
    (if (null? s)
        acc
        (iter (op acc (car s))
              (cdr s))))
  (iter initial seq))

(define (reverse seq)
  (fold-left (lambda (x y) (cons y x)) nil seq))
(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)

Fold left is much more efficient for reversing a list, as it is an iterative process, and it avoids append.
* Exercise 2.40
** Prompt
This problem goes into the application of the ~flatmap~. Define a procedure called ~unique-map~ that when given an integer ~n~, generate the sequence of pairs (i, j) with 1 <= j < i <= n. Use this to simplify the definition of ~prime-sum-pairs~.
** Solution
#+begin_src racket :exports both
#lang sicp
;; Importing prime?
(define (square x) (* x x))
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? x y) (= (remainder y x) 0))
(define (prime? n)
  (= n (smallest-divisor n)))

(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))

(define (filter predicate seq)
  (fold-right (lambda (x y) (if (predicate x) (cons x y) y)) nil seq))


(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))

(define (unique-pairs n)
  (flatmap (lambda (x) (map (lambda (y) (list x y)) (enumerate-range 1 (- x 1))))
           (enumerate-range 2 n)))

(define (make-pair-sum pair)
  (let ((left (car pair)) (right (car (cdr pair))))
    (list left right (+ left right))))
(define (prime-sum-pairs n)
  (define (prime-sum? x) (prime? (+ (car x) (car (cdr x) ))))
  (map make-pair-sum (filter prime-sum? (unique-pairs n))))

(unique-pairs 8)
(prime-sum-pairs 8)
#+end_src

#+RESULTS:
: ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3) (5 1) (5 2) (5 3) (5 4) (6 1) (6 2) (6 3) (6 4) (6 5) (7 1) (7 2) (7 3) (7 4) (7 5) (7 6) (8 1) (8 2) (8 3) (8 4) (8 5) (8 6) (8 7))
: ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11) (7 4 11) (7 6 13) (8 3 11) (8 5 13))
* Exercise 2.41
** Prompt
Write a procedure to find all ordered triples of distinct positive integers i, j, and k less than or equal to a given integer n that sum to a given integer s
** Solution
We are looking for all ordered integers of distinct positive integers. Distinct means that we will not accept cases where i, j, or k are equal. Furthermore, the values no longer has to be less than each other, they just need to be distinct. We'd usually generate this with three for loops. Next, we will filter by summing.

#+begin_src racket :exports both
#lang sicp
(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))

(define (filter predicate seq)
  (fold-right (lambda (x y)
                (if (predicate x)
                    (cons x y)
                    y))
              nil
              seq))

(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))

;; This procedure checks if the target value is contained inside the sequence
;; Currently only comparing numerical contents
(define (contains? target seq)
  (fold-right (lambda (left right)
                (cond
                  [(= left target) #t]
                  [else right]))
              #f
              seq))

;; Enumerates from 1 to n, inclusive, but do not include the values in the
;; excl dynamic parameter.
(define (enumerate-exclusion n . excl)
  (define (enumerate-exclusion-aux lower)
    (cond
      [(> lower n) nil]
      [(contains? lower excl) (enumerate-exclusion-aux (+ lower 1))]
      [else (cons lower (enumerate-exclusion-aux (+ lower 1)))]))
  (enumerate-exclusion-aux 1))

;; constructor and selector for the triple
(define (make-triple a b c)
  (list a b c))
(define (first x)
  (car x))
(define (second x)
  (car (cdr x)))
(define (third x)
  (car (cdr (cdr x))))

;; Main function should do the following to reduce work. Only enumerate through
;; what is possible to get to the target sum. If we cannot get to the target
;; sum, then move on to the next iteration.
(define (ordered-triple-sum n s)
  (flatmap (lambda (x)
             (flatmap (lambda (y)
                        (map (lambda (z) (make-triple x y z))
                             (filter (lambda (c) (= (+ x y c) s)) (enumerate-exclusion n x y))))
                      (filter (lambda (b) (< (+ x b) s)) (enumerate-exclusion n x))))
           ;; We could subtract two from the first case because the smallest
           ;; increase with two more value is 1 + 2
           (filter (lambda (a) (< a (- s 2))) (enumerate-range 1 n))))

(ordered-triple-sum 8 11)
#+end_src

#+RESULTS:
: ((1 2 8) (1 3 7) (1 4 6) (1 6 4) (1 7 3) (1 8 2) (2 1 8) (2 3 6) (2 4 5) (2 5 4) (2 6 3) (2 8 1) (3 1 7) (3 2 6) (3 6 2) (3 7 1) (4 1 6) (4 2 5) (4 5 2) (4 6 1) (5 2 4) (5 4 2) (6 1 4) (6 2 3) (6 3 2) (6 4 1) (7 1 3) (7 3 1) (8 1 2) (8 2 1))

For the sake of performance, instead of building all the permuatations first, and then filtering them out, we could reduce the permutation problem size by filtering the enumeration out as we go.
* Exercise 2.42
** Prompt
This is the eight queens problem, which asks how to place 8 queens on a chessboard. Strategy being asked of us is to place a queen in each column. For the k-th queen, check we can place a queen in a row that will not conflict with the previously placed queens. To do this, we are asked to keep track of all the previous legal moves, and as we move forward, filter out the ones that are not legal. On the k-th queen, don't just produce one legal position, but all of them. Actually, the generalization will be done for a square chessboard of equal size. The following is the provided code, implement the rest.

#+begin_src racket :exports code
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter (lambda (positions) (safe? k positions))
                (flatmap
                 (lambda (rest-of-queens)
                   (map (lambda (new-row)
                          (adjoin-position
                           new-row k rest-of-queens))
                        (enumerate-interval 1 board-size)))
                 (queen-cols (- k 1))))))
  (queen-cols board-size))
#+end_src
** Solution
We can make our solution more flexible by making the underlying representation a pair, and forgo the index. This way, the previous queens do not have to be ordered. Our recusions could be much more efficient with this strategy of implementing this.
#+begin_src racket :exports both
#lang sicp
;; unit testing
(define (assert-predicate pred-fn test-name value expected)
  (display (if (pred-fn value expected) "pass: " "fail: "))
  (display test-name)
  (display " value: ")
  (display value)
  (display " expected: ")
  (display expected)
  (newline))
(define (assert-eq test-name value expected)
  (assert-predicate eq? test-name value expected))
(define (assert-almost-eq test-name value expected)
  (define dx 0.0001)
  (define (almost-eq? left right)
    (< (abs (- left right)) dx))
  (assert-predicate almost-eq? test-name value expected))

;; Common sequence operators
(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))
(define (fold-left op initial seq)
  (define (iter acc remaining)
    (if (null? remaining)
        acc
        (iter (op (car remaining) acc) (cdr remaining))))
  (iter initial seq))
(define (filter predicate seq)
  (fold-right (lambda (x y)
                (if (predicate x)
                    (cons x y)
                    y))
              nil
              seq))

(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))
(define (enumerate-interval lower upper)
  (enumerate-range lower upper))

;; Need to implement the representation of the queens on the board. We can
;; make this representation unordered if we store the col and row information
;; with the queen
(define empty-board nil)
(define (make-queen row col)
  (cons row col))
(define (get-row queen)
  (car queen))
(define (get-col queen)
  (cdr queen))
;; Looks like k actually does nothing for us yet
(define (adjoin-position nr k roq)
  (cons (make-queen nr k) roq))

(define (safe? k positions)
  (define (get-queen)
    (fold-left (lambda (x acc)
                 (if (null? acc)
                     (if (= (get-col x) k) x acc)
                     acc))
               nil
               positions))
  ;; check if the two queens are diag from each other
  (define (diag? a b)
    (= (abs (- (get-col a)
               (get-col b)))
     (abs (- (get-row a)
             (get-row b)))))
  ;; where target is the queen that is being tested against
  (define (safe?-aux target roq)
    (define (iter rest-of-queens)
      (cond
        [(null? rest-of-queens) #t]
        [(= (get-row target) (get-row (car rest-of-queens))) #f]
        [(= (get-col target) (get-col (car rest-of-queens))) #f]
        [(diag? target (car rest-of-queens)) #f]
        [else (iter (cdr rest-of-queens))]))
    (iter roq))
  (let ((k-queen (get-queen))) (safe?-aux k-queen
                                          (filter (lambda (x) (not (and (= (get-col x)
                                                                           (get-col k-queen))
                                                                        (= (get-row x)
                                                                           (get-row k-queen)))))
                                                  positions))))

(display "testing safe?")
(newline)
(define base-1 (adjoin-position 7 3 (adjoin-position 5 2 (adjoin-position 1 1 empty-board))))
(define base-2 (adjoin-position 1 1 empty-board))
(assert-eq "horizontal collision" (safe? 4 (adjoin-position 1 4 base-1)) #f)
(assert-eq "no collision" (safe? 4 (adjoin-position 2 4 base-1)) #t)
(assert-eq "diagonal collision 1" (safe? 4 (adjoin-position 3 4 base-1)) #f)
(assert-eq "diagonal collision 2" (safe? 4 (adjoin-position 6 4 base-1)) #f)
(assert-eq "diagonal collision 3" (safe? 4 (adjoin-position 4 4 base-1)) #f)
(assert-eq "fail by horizontal collision" (safe? 2 (adjoin-position 1 2 base-2)) #f)
(assert-eq "fail by diagonal collision" (safe? 2 (adjoin-position 2 2 base-2)) #f)
(assert-eq "safe 1" (safe? 2 (adjoin-position 3 2 base-2)) #t)
(assert-eq "safe 2" (safe? 2 (adjoin-position 4 2 base-2)) #t)
(assert-eq "safe 3" (safe? 2 (adjoin-position 5 2 base-2)) #t)
(assert-eq "safe 4" (safe? 2 (adjoin-position 6 2 base-2)) #t)
(assert-eq "safe 5" (safe? 2 (adjoin-position 7 2 base-2)) #t)
(assert-eq "safe 6" (safe? 2 (adjoin-position 8 2 base-2)) #t)
(newline)

;; We are using board-size as a local global (all the other recursion will use
;; this value to test if the system is working as intended)
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        ;; Making the base board
        (list empty-board)
        ;; filter, safe? is given the current col being tested, and positions
        ;; actually already includes the parameter
        (filter (lambda (positions) (safe? k positions))
                (flatmap (lambda (rest-of-queens)
                           (map (lambda (new-row) (adjoin-position new-row k rest-of-queens))
                                (enumerate-interval 1 board-size)))
                         (queen-cols (- k 1))))))
  (queen-cols board-size))

(display "one queens")
(newline)
(queens 1)
(display "four queens")
(newline)
(queens 4)
(display "five queens")
(newline)
(queens 5)
(display "eight queens")
(newline)
(queens 8)
#+end_src

#+RESULTS:
#+begin_example
testing safe?
pass: horizontal collision value: #f expected: #f
pass: no collision value: #t expected: #t
pass: diagonal collision 1 value: #f expected: #f
pass: diagonal collision 2 value: #f expected: #f
pass: diagonal collision 3 value: #f expected: #f
pass: fail by horizontal collision value: #f expected: #f
pass: fail by diagonal collision value: #f expected: #f
pass: safe 1 value: #t expected: #t
pass: safe 2 value: #t expected: #t
pass: safe 3 value: #t expected: #t
pass: safe 4 value: #t expected: #t
pass: safe 5 value: #t expected: #t
pass: safe 6 value: #t expected: #t

one queens
(((1 . 1)))
four queens
(((3 . 4) (1 . 3) (4 . 2) (2 . 1)) ((2 . 4) (4 . 3) (1 . 2) (3 . 1)))
five queens
(((4 . 5) (2 . 4) (5 . 3) (3 . 2) (1 . 1)) ((3 . 5) (5 . 4) (2 . 3) (4 . 2) (1 . 1)) ((5 . 5) (3 . 4) (1 . 3) (4 . 2) (2 . 1)) ((4 . 5) (1 . 4) (3 . 3) (5 . 2) (2 . 1)) ((5 . 5) (2 . 4) (4 . 3) (1 . 2) (3 . 1)) ((1 . 5) (4 . 4) (2 . 3) (5 . 2) (3 . 1)) ((2 . 5) (5 . 4) (3 . 3) (1 . 2) (4 . 1)) ((1 . 5) (3 . 4) (5 . 3) (2 . 2) (4 . 1)) ((3 . 5) (1 . 4) (4 . 3) (2 . 2) (5 . 1)) ((2 . 5) (4 . 4) (1 . 3) (3 . 2) (5 . 1)))
eight queens
(((4 . 8) (2 . 7) (7 . 6) (3 . 5) (6 . 4) (8 . 3) (5 . 2) (1 . 1)) ((5 . 8) (2 . 7) (4 . 6) (7 . 5) (3 . 4) (8 . 3) (6 . 2) (1 . 1)) ((3 . 8) (5 . 7) (2 . 6) (8 . 5) (6 . 4) (4 . 3) (7 . 2) (1 . 1)) ((3 . 8) (6 . 7) (4 . 6) (2 . 5) (8 . 4) (5 . 3) (7 . 2) (1 . 1)) ((5 . 8) (7 . 7) (1 . 6) (3 . 5) (8 . 4) (6 . 3) (4 . 2) (2 . 1)) ((4 . 8) (6 . 7) (8 . 6) (3 . 5) (1 . 4) (7 . 3) (5 . 2) (2 . 1)) ((3 . 8) (6 . 7) (8 . 6) (1 . 5) (4 . 4) (7 . 3) (5 . 2) (2 . 1)) ((5 . 8) (3 . 7) (8 . 6) (4 . 5) (7 . 4) (1 . 3) (6 . 2) (2 . 1)) ((5 . 8) (7 . 7) (4 . 6) (1 . 5) (3 . 4) (8 . 3) (6 . 2) (2 . 1)) ((4 . 8) (1 . 7) (5 . 6) (8 . 5) (6 . 4) (3 . 3) (7 . 2) (2 . 1)) ((3 . 8) (6 . 7) (4 . 6) (1 . 5) (8 . 4) (5 . 3) (7 . 2) (2 . 1)) ((4 . 8) (7 . 7) (5 . 6) (3 . 5) (1 . 4) (6 . 3) (8 . 2) (2 . 1)) ((6 . 8) (4 . 7) (2 . 6) (8 . 5) (5 . 4) (7 . 3) (1 . 2) (3 . 1)) ((6 . 8) (4 . 7) (7 . 6) (1 . 5) (8 . 4) (2 . 3) (5 . 2) (3 . 1)) ((1 . 8) (7 . 7) (4 . 6) (6 . 5) (8 . 4) (2 . 3) (5 . 2) (3 . 1)) ((6 . 8) (8 . 7) (2 . 6) (4 . 5) (1 . 4) (7 . 3) (5 . 2) (3 . 1)) ((6 . 8) (2 . 7) (7 . 6) (1 . 5) (4 . 4) (8 . 3) (5 . 2) (3 . 1)) ((4 . 8) (7 . 7) (1 . 6) (8 . 5) (5 . 4) (2 . 3) (6 . 2) (3 . 1)) ((5 . 8) (8 . 7) (4 . 6) (1 . 5) (7 . 4) (2 . 3) (6 . 2) (3 . 1)) ((4 . 8) (8 . 7) (1 . 6) (5 . 5) (7 . 4) (2 . 3) (6 . 2) (3 . 1)) ((2 . 8) (7 . 7) (5 . 6) (8 . 5) (1 . 4) (4 . 3) (6 . 2) (3 . 1)) ((1 . 8) (7 . 7) (5 . 6) (8 . 5) (2 . 4) (4 . 3) (6 . 2) (3 . 1)) ((2 . 8) (5 . 7) (7 . 6) (4 . 5) (1 . 4) (8 . 3) (6 . 2) (3 . 1)) ((4 . 8) (2 . 7) (7 . 6) (5 . 5) (1 . 4) (8 . 3) (6 . 2) (3 . 1)) ((5 . 8) (7 . 7) (1 . 6) (4 . 5) (2 . 4) (8 . 3) (6 . 2) (3 . 1)) ((6 . 8) (4 . 7) (1 . 6) (5 . 5) (8 . 4) (2 . 3) (7 . 2) (3 . 1)) ((5 . 8) (1 . 7) (4 . 6) (6 . 5) (8 . 4) (2 . 3) (7 . 2) (3 . 1)) ((5 . 8) (2 . 7) (6 . 6) (1 . 5) (7 . 4) (4 . 3) (8 . 2) (3 . 1)) ((6 . 8) (3 . 7) (7 . 6) (2 . 5) (8 . 4) (5 . 3) (1 . 2) (4 . 1)) ((2 . 8) (7 . 7) (3 . 6) (6 . 5) (8 . 4) (5 . 3) (1 . 2) (4 . 1)) ((7 . 8) (3 . 7) (1 . 6) (6 . 5) (8 . 4) (5 . 3) (2 . 2) (4 . 1)) ((5 . 8) (1 . 7) (8 . 6) (6 . 5) (3 . 4) (7 . 3) (2 . 2) (4 . 1)) ((1 . 8) (5 . 7) (8 . 6) (6 . 5) (3 . 4) (7 . 3) (2 . 2) (4 . 1)) ((3 . 8) (6 . 7) (8 . 6) (1 . 5) (5 . 4) (7 . 3) (2 . 2) (4 . 1)) ((6 . 8) (3 . 7) (1 . 6) (7 . 5) (5 . 4) (8 . 3) (2 . 2) (4 . 1)) ((7 . 8) (5 . 7) (3 . 6) (1 . 5) (6 . 4) (8 . 3) (2 . 2) (4 . 1)) ((7 . 8) (3 . 7) (8 . 6) (2 . 5) (5 . 4) (1 . 3) (6 . 2) (4 . 1)) ((5 . 8) (3 . 7) (1 . 6) (7 . 5) (2 . 4) (8 . 3) (6 . 2) (4 . 1)) ((2 . 8) (5 . 7) (7 . 6) (1 . 5) (3 . 4) (8 . 3) (6 . 2) (4 . 1)) ((3 . 8) (6 . 7) (2 . 6) (5 . 5) (8 . 4) (1 . 3) (7 . 2) (4 . 1)) ((6 . 8) (1 . 7) (5 . 6) (2 . 5) (8 . 4) (3 . 3) (7 . 2) (4 . 1)) ((8 . 8) (3 . 7) (1 . 6) (6 . 5) (2 . 4) (5 . 3) (7 . 2) (4 . 1)) ((2 . 8) (8 . 7) (6 . 6) (1 . 5) (3 . 4) (5 . 3) (7 . 2) (4 . 1)) ((5 . 8) (7 . 7) (2 . 6) (6 . 5) (3 . 4) (1 . 3) (8 . 2) (4 . 1)) ((3 . 8) (6 . 7) (2 . 6) (7 . 5) (5 . 4) (1 . 3) (8 . 2) (4 . 1)) ((6 . 8) (2 . 7) (7 . 6) (1 . 5) (3 . 4) (5 . 3) (8 . 2) (4 . 1)) ((3 . 8) (7 . 7) (2 . 6) (8 . 5) (6 . 4) (4 . 3) (1 . 2) (5 . 1)) ((6 . 8) (3 . 7) (7 . 6) (2 . 5) (4 . 4) (8 . 3) (1 . 2) (5 . 1)) ((4 . 8) (2 . 7) (7 . 6) (3 . 5) (6 . 4) (8 . 3) (1 . 2) (5 . 1)) ((7 . 8) (1 . 7) (3 . 6) (8 . 5) (6 . 4) (4 . 3) (2 . 2) (5 . 1)) ((1 . 8) (6 . 7) (8 . 6) (3 . 5) (7 . 4) (4 . 3) (2 . 2) (5 . 1)) ((3 . 8) (8 . 7) (4 . 6) (7 . 5) (1 . 4) (6 . 3) (2 . 2) (5 . 1)) ((6 . 8) (3 . 7) (7 . 6) (4 . 5) (1 . 4) (8 . 3) (2 . 2) (5 . 1)) ((7 . 8) (4 . 7) (2 . 6) (8 . 5) (6 . 4) (1 . 3) (3 . 2) (5 . 1)) ((4 . 8) (6 . 7) (8 . 6) (2 . 5) (7 . 4) (1 . 3) (3 . 2) (5 . 1)) ((2 . 8) (6 . 7) (1 . 6) (7 . 5) (4 . 4) (8 . 3) (3 . 2) (5 . 1)) ((2 . 8) (4 . 7) (6 . 6) (8 . 5) (3 . 4) (1 . 3) (7 . 2) (5 . 1)) ((3 . 8) (6 . 7) (8 . 6) (2 . 5) (4 . 4) (1 . 3) (7 . 2) (5 . 1)) ((6 . 8) (3 . 7) (1 . 6) (8 . 5) (4 . 4) (2 . 3) (7 . 2) (5 . 1)) ((8 . 8) (4 . 7) (1 . 6) (3 . 5) (6 . 4) (2 . 3) (7 . 2) (5 . 1)) ((4 . 8) (8 . 7) (1 . 6) (3 . 5) (6 . 4) (2 . 3) (7 . 2) (5 . 1)) ((2 . 8) (6 . 7) (8 . 6) (3 . 5) (1 . 4) (4 . 3) (7 . 2) (5 . 1)) ((7 . 8) (2 . 7) (6 . 6) (3 . 5) (1 . 4) (4 . 3) (8 . 2) (5 . 1)) ((3 . 8) (6 . 7) (2 . 6) (7 . 5) (1 . 4) (4 . 3) (8 . 2) (5 . 1)) ((4 . 8) (7 . 7) (3 . 6) (8 . 5) (2 . 4) (5 . 3) (1 . 2) (6 . 1)) ((4 . 8) (8 . 7) (5 . 6) (3 . 5) (1 . 4) (7 . 3) (2 . 2) (6 . 1)) ((3 . 8) (5 . 7) (8 . 6) (4 . 5) (1 . 4) (7 . 3) (2 . 2) (6 . 1)) ((4 . 8) (2 . 7) (8 . 6) (5 . 5) (7 . 4) (1 . 3) (3 . 2) (6 . 1)) ((5 . 8) (7 . 7) (2 . 6) (4 . 5) (8 . 4) (1 . 3) (3 . 2) (6 . 1)) ((7 . 8) (4 . 7) (2 . 6) (5 . 5) (8 . 4) (1 . 3) (3 . 2) (6 . 1)) ((8 . 8) (2 . 7) (4 . 6) (1 . 5) (7 . 4) (5 . 3) (3 . 2) (6 . 1)) ((7 . 8) (2 . 7) (4 . 6) (1 . 5) (8 . 4) (5 . 3) (3 . 2) (6 . 1)) ((5 . 8) (1 . 7) (8 . 6) (4 . 5) (2 . 4) (7 . 3) (3 . 2) (6 . 1)) ((4 . 8) (1 . 7) (5 . 6) (8 . 5) (2 . 4) (7 . 3) (3 . 2) (6 . 1)) ((5 . 8) (2 . 7) (8 . 6) (1 . 5) (4 . 4) (7 . 3) (3 . 2) (6 . 1)) ((3 . 8) (7 . 7) (2 . 6) (8 . 5) (5 . 4) (1 . 3) (4 . 2) (6 . 1)) ((3 . 8) (1 . 7) (7 . 6) (5 . 5) (8 . 4) (2 . 3) (4 . 2) (6 . 1)) ((8 . 8) (2 . 7) (5 . 6) (3 . 5) (1 . 4) (7 . 3) (4 . 2) (6 . 1)) ((3 . 8) (5 . 7) (2 . 6) (8 . 5) (1 . 4) (7 . 3) (4 . 2) (6 . 1)) ((3 . 8) (5 . 7) (7 . 6) (1 . 5) (4 . 4) (2 . 3) (8 . 2) (6 . 1)) ((5 . 8) (2 . 7) (4 . 6) (6 . 5) (8 . 4) (3 . 3) (1 . 2) (7 . 1)) ((6 . 8) (3 . 7) (5 . 6) (8 . 5) (1 . 4) (4 . 3) (2 . 2) (7 . 1)) ((5 . 8) (8 . 7) (4 . 6) (1 . 5) (3 . 4) (6 . 3) (2 . 2) (7 . 1)) ((4 . 8) (2 . 7) (5 . 6) (8 . 5) (6 . 4) (1 . 3) (3 . 2) (7 . 1)) ((4 . 8) (6 . 7) (1 . 6) (5 . 5) (2 . 4) (8 . 3) (3 . 2) (7 . 1)) ((6 . 8) (3 . 7) (1 . 6) (8 . 5) (5 . 4) (2 . 3) (4 . 2) (7 . 1)) ((5 . 8) (3 . 7) (1 . 6) (6 . 5) (8 . 4) (2 . 3) (4 . 2) (7 . 1)) ((4 . 8) (2 . 7) (8 . 6) (6 . 5) (1 . 4) (3 . 3) (5 . 2) (7 . 1)) ((6 . 8) (3 . 7) (5 . 6) (7 . 5) (1 . 4) (4 . 3) (2 . 2) (8 . 1)) ((6 . 8) (4 . 7) (7 . 6) (1 . 5) (3 . 4) (5 . 3) (2 . 2) (8 . 1)) ((4 . 8) (7 . 7) (5 . 6) (2 . 5) (6 . 4) (1 . 3) (3 . 2) (8 . 1)) ((5 . 8) (7 . 7) (2 . 6) (6 . 5) (3 . 4) (1 . 3) (4 . 2) (8 . 1)))
#+end_example
* Exercise 2.43
** Prompt
Louis Reasoner has a slower implementation of queens than we do. His code difference is provided. Please explain why it is running slower, and if our program queens runs in T, how long would Louis's implementation take to run?
#+begin_src racket :exports code
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
#+end_src
** Solution
Louis's queen's implementation is slow because each iteration in the recursion is calling the next recursion step multiple times, causing repeated work. This problem compounds heavily fast.

To estimate runtime differences, we should look at the different components of the program that are executed at each of the recursive stage. Let's start with our version of the program. First, at the base case of k = 0, we immediately return, preventing work from occurring. Let's call this constant cost C_{0}. In the other case, we get the result from the k - 1 recursive case of the process. Here are just some quantitative estimation of the runtime of the process. First, we can observe that the base case of ~queen-cols~ has nearly no work being done, just a single conditional, followed by the construction of an empty board. In the recursive case of the program that we implement, we see that the size of the board we are working with multiplies by the width of the board. Finally, the ~safe?~ procedure is ran on the expanding result size. This problem could be tricky to model, since the runtime of ~safe?~ will grow linearly with the size of the board that has already been built, and the number of times that ~safe?~ is called also increases as we find more permutations. Luckily, our implementation of adjoin position is a constant time operation because we have decided to keep track of both the row and column for each of the queen, opening us up to future unordered implementations, while sacrificing twice the amount of memory as other solutions. Let's write the equation for the growth of our process now.

T_{k} = T_{k - 1} + ((b * C_{1} + k * C_{2}) * N_{k})

Where N_{k} is the number of returns from ~queens~ at the problem size, b is the board size, C_{1} is the time it takes to append a new queen on to the board and C_{2} is the time it takes to check if the queen is in a valid position one a board on size one. Now we should consider the base case, T_{0} and T_{0}' for the Louis implementation. We could say that it takes constant time C_{0}, and that it is nearly 0 due to the fact that it is one conditional. As a good engineer, I will just take that as fact, and make T_{0} disappear when faced with it.

Now we'll define the expression for the Louis case, which really just multiplies the recursive case by the width of the board, along with a few difference in the nesting.

T_{k}' = b * (T_{k - 1}' + C_{1} * N_{k} ) + (k * C_{2} * N_{k})

Now we should calculate how long it takes to run the two cases for b = 8.

#+begin_src racket :exports both
#lang sicp

(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))
(define (fold-left op initial seq)
  (define (iter acc remaining)
    (if (null? remaining)
        acc
        (iter (op (car remaining) acc) (cdr remaining))))
  (iter initial seq))
(define (filter predicate seq)
  (fold-right (lambda (x y)
                (if (predicate x)
                    (cons x y)
                    y))
              nil
              seq))

(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))
(define (enumerate-interval lower upper)
  (enumerate-range lower upper))

;; Need to implement the representation of the queens on the board. We can
;; make this representation unordered if we store the col and row information
;; with the queen
(define empty-board nil)
(define (make-queen row col)
  (cons row col))
(define (get-row queen)
  (car queen))
(define (get-col queen)
  (cdr queen))
;; Looks like k actually does nothing for us yet
(define (adjoin-position nr k roq)
  (cons (make-queen nr k) roq))

(define (safe? k positions)
  (define (get-queen)
    (fold-left (lambda (x acc)
                 (if (null? acc)
                     (if (= (get-col x) k) x acc)
                     acc))
               nil
               positions))
  ;; check if the two queens are diag from each other
  (define (diag? a b)
    (= (abs (- (get-col a) (get-col b))) (abs (- (get-row a) (get-row b)))))
  ;; where target is the queen that is being tested against
  (define (safe?-aux target roq)
    (define (iter rest-of-queens)
      (cond
        [(null? rest-of-queens) #t]
        [(= (get-row target) (get-row (car rest-of-queens))) #f]
        [(= (get-col target) (get-col (car rest-of-queens))) #f]
        [(diag? target (car rest-of-queens)) #f]
        [else (iter (cdr rest-of-queens))]))
    (iter roq))
  (let ([k-queen (get-queen)])
    (safe?-aux k-queen
               (filter (lambda (x)
                         (not (and (= (get-col x) (get-col k-queen))
                                   (= (get-row x) (get-row k-queen)))))
                       positions))))

;; We are using board-size as a local global (all the other recursion will use
;; this value to test if the system is working as intended)
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        ;; Making the base board
        (list empty-board)
        ;; filter, safe? is given the current col being tested, and positions
        ;; actually already includes the parameter
        (filter (lambda (positions) (safe? k positions))
                (flatmap (lambda (rest-of-queens)
                           (map (lambda (new-row) (adjoin-position new-row k rest-of-queens))
                                (enumerate-interval 1 board-size)))
                         (queen-cols (- k 1))))))
  (queen-cols board-size))
(define (tk-prime b c1 c2)
  (define (iter k)
    (let ([nk (length (queens k))])
      (if (= k 0)
          0
          (+ (* b (+ (iter (- k 1)) (* c1 nk))) (* k c2 nk)))))
  (iter b))
(define (tk b c1 c2)
  (define (iter acc k)
    (if (> k b)
        acc
        (iter (+ acc (* (length (queens k)) (+ (* b c1) (* k c2)))) (+ k 1))))
  (iter 0 0))

(/ (tk-prime 8 0.1 0.5) (tk 8 0.1 0.5))
#+end_src

#+RESULTS
: 4135.805227781927

So we can see that the Louis implementation is approximately 3 order of magnitudes more expensive to run than our implementation.
* Exercise 2.44
** Prompt
Define ~up-split~ which is similar to ~right-split~, but upwards.
** Solution
Luckily for us, Racket's ~sicp~ package comes with the picture language, so we could just printout the solution to a file and render it on Org. In this solution, we will start to use ~org-tangle~, since it is helpful in literate programming.
#+header: :tangle ./src/exercise-2.44.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
#lang sicp
(#%require sicp-pict)
(define (up-split p n)
  (if (= n 0)
      p
      (let ((up (up-split p (- n 1))))
        (below p (beside up up)))))
(paint (up-split einstein 10))
#+end_src

#+RESULTS:
: #(struct:object:image-snip% ... ...)

#+name: higher-order-painters
#+begin_src racket :exports none
(define (up-split p n)
  (if (= n 0)
      p
      (let ((up (up-split p (- n 1))))
        (below p (beside up up)))))
(define (right-split p n)
  (if (= n 0)
      p
      (let ((right (right-split p (- n 1))))
        (beside p (below right right)))))
#+end_src


Result can be obtained through DrRacket with the ~sicp~ package.
* Exercise 2.45
** Prompt
Make ~right-split~ and ~up-split~ use a higher order procedure in it's implementation. Allow it to be built like the following.

#+begin_src racket :exports code
(define right-split (split beside below))
(define up-split (split below beside))
#+end_src
** Solution
Tangling again.

#+header: :tangle ./src/exercise-2.45.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
#lang sicp
(#%require sicp-pict)
(define (split first-proc second-proc)
  (define (proc p n)
    (if (= n 0)
        p
        (let ([rec (proc p (- n 1))]) (first-proc p (second-proc rec rec)))))
  proc)
(define right-split (split beside below))
(define up-split (split below beside))

(paint (right-split mark-of-zorro 10))
(paint (up-split einstein 10))
#+end_src

#+RESULTS:
: #(struct:object:image-snip% ... ...)
: #(struct:object:image-snip% ... ...)

Running this on DrRacket produced the expected result.
* Exercise 2.46
** Prompt
Make the constructor and selector for the vector we are working with. Following this, implement ~add-vect~, ~sub-vect~, and ~scale-vect~ that does the corresponding vector operations.
** Solution
#+name: vect-def
#+header: :tangle ./src/exercise-2.46.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (make-vect x y)
  (cons x y))
(define (xcor-vect v)
  (car v))
(define (ycor-vect v)
  (cdr v))

(define (add-vect a b)
  (make-vect (+ (xcor-vect a) (xcor-vect b)) (+ (ycor-vect a) (ycor-vect b))))
(define (sub-vect a b)
  (make-vect (- (xcor-vect a) (xcor-vect b)) (- (ycor-vect a) (ycor-vect b))))
(define (scale-vect s v)
  (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))
#+end_src
* Exercise 2.47
** Prompt
There are two possible constructors for the frames, make selectors for them.
#+caption: The two possible constructors for frames.
#+begin_src racket :exports code
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
#+end_src
** Solution
#+caption: List implementation selectors
#+name: list-frame
#+begin_src racket :exports both
#lang sicp
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (caddr f))
;; This is really bad testing since we should be testing with vectors
(define test-frame (make-frame 1 2 3 ))
(origin-frame test-frame)
(edge1-frame test-frame)
(edge2-frame test-frame)
#+end_src

#+RESULTS: list-frame
: 1
: 2
: 3

#+caption: Pair of pair implementation selectors
#+begin_src racket :exports both
#lang sicp
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))

(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (cddr f))
;; This is really bad testing since we should be testing with vectors
(define test-frame (make-frame 1 2 3))
(origin-frame test-frame)
(edge1-frame test-frame)
(edge2-frame test-frame)
#+end_src

#+RESULTS:
: 1
: 2
: 3

We can see that the selectors can obtain the values that corresponds to each of the argument used to build the frame.
* Exercise 2.48
** Prompt
A direct line segment on a plane could be represented as a vector from origin to the start point and a vector from origin from the origin to the end point. Using the vector representation from 2.46, define the representation for the segment with ~make-segment~ as the constructor and ~start-segment~ and ~end-segment~ as the selectors
** Solution
Will need to import the definition for vectors.

#+name: segment-representation
#+begin_src racket :exports both
(define (make-vect x y)
  (cons x y))
(define (xcor-vect v)
  (car v))
(define (ycor-vect v)
  (cdr v))

(define (add-vect a b)
  (make-vect (+ (xcor-vect a) (xcor-vect b)) (+ (ycor-vect a) (ycor-vect b))))
(define (sub-vect a b)
  (make-vect (- (xcor-vect a) (xcor-vect b)) (- (ycor-vect a) (ycor-vect b))))
(define (scale-vect s v)
  (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))

(define (make-segment start end)
  (cons start end))
(define (start-segment s) (car s))
(define (end-segment s) (cdr s))
#+end_src
* Exercise 2.49
** Prompt
Use ~segment->painter~ to define the following primitive painters
a. The painter that draws the outline of the designated frame
b. The painter that draws an "X" by connecting opposite corners of the frame
c. The painter that draws a diamond shape by connecting the midpoints of the sides
** Solution
Great thing about the sicp language in Racket is that it comes with a picture language implementation that already implements ~segment~ and ~vect~.
#+name: vect-consts
#+begin_src racket :exports code
(define bottom-left (make-vect 0 0))
(define bottom-right (make-vect 1 0))
(define top-left (make-vect 0 1))
(define top-right (make-vect 1 1))
#+end_src

#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
;; Setting up tangle file
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

*** Part a
#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports code :noweb yes
; we just need to make a list that makes square
(define outline-painter (segments->painter (list
                                            (make-segment bottom-left bottom-right)
                                            (make-segment bottom-right top-right)
                                            (make-segment top-right top-left)
                                            (make-segment top-left bottom-left))))

(display "Part a. The outline")
(newline)
(paint outline-painter)
#+end_src

#+RESULTS:
: #(struct:object:image-snip% ... ...)
*** Part b
You only need two segments to draw an x in the frame
#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports code :noweb yes
(define cross-painter (segments->painter (list
                                            (make-segment top-left bottom-right)
                                            (make-segment top-right bottom-left))))

(display "Part b. The cross")
(newline)
(paint cross-painter)
#+end_src
*** Part c
Build the diamond painter. In this solution, we over engineer and add a vector average procedure.
#+name: vector-average
#+begin_src racket :exports code
(define (vector-average . v)
  (define (count-aux x acc)
    (if (null? x)
        acc
        (count-aux (cdr x) (+ acc 1))))
  (define (count x)
    (count-aux x 0))
  (define (vector-sum-aux vecs acc)
    (if (null? vecs)
        acc
        (vector-sum-aux (cdr vecs) (vector-add acc (car vecs)))))
  (define (vector-sum vecs)
    (vector-sum-aux vecs zero-vector))
  (vector-scale (/ 1 (count v)) (vector-sum v)))
#+end_src

#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports code :noweb yes
<<vector-average>>

(define diamond-painter
  (segments->painter
   (list
    (make-segment (vector-average bottom-left top-left) (vector-average top-left top-right))
    (make-segment (vector-average top-left top-right) (vector-average top-right bottom-right))
    (make-segment (vector-average top-right bottom-right) (vector-average bottom-right bottom-left))
    (make-segment (vector-average bottom-right bottom-left) (vector-average bottom-left top-left)))))

(display "Part c. The diamond")
(newline)
(paint diamond-painter)
#+end_src
*** Part d
Build the wave painter.

- Actually, I won't be doing this. I don't think that it is adding that value that I want from this book. We'll see each other in the next exercise.
* Exercise 2.50
** Prompt
Define a ~flip-horiz~ that will flip a painter horizontally (left-right flip).
** Solution
#+caption: setup
#+header: :tangle ./src/exercise-2.50.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

#+caption: flip-horiz implementation
#+header: :tangle ./src/exercise-2.50.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (flip-horiz painter)
  (transform-painter painter
                     bottom-right
                     bottom-left
                     top-right))
#+end_src

#+caption: flip-horiz test
#+header: :tangle ./src/exercise-2.50.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(display "einstein")
(newline)
(paint einstein)

(display "flipped einstein")
(newline)
(paint (flip-horiz einstein))
#+end_src

* Exercise 2.51
** Prompt
Define the ~below~ procedure that takes in two painters and put the first painter below the second painter. Make this procedure twice, once the same way as the provided ~beside~ procedure, and the second time using the ~beside~ procedure.
** Solution

*** Part a
Implement ~below~ analogous to ~beside~.

#+caption: setup
#+header: :tangle ./src/exercise-2.51-a.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

#+caption: below implementation
#+header: :tangle ./src/exercise-2.51-a.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (below painter-1 painter-2)
  (let ([split-point (make-vect 0 0.5)])
    (let ([paint-below (transform-painter painter-1 (make-vect 0 0) (make-vect 1 0) split-point)]
          [paint-above (transform-painter painter-2 split-point (make-vect 1 0.5) (make-vect 0 1))])
      (lambda (frame)
        (paint-below frame)
        (paint-above frame)))))
#+end_src

#+caption: below test a
#+header: :tangle ./src/exercise-2.51-a.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(display "einstein")
(newline)
(paint einstein)

(display "below einstein")
(newline)
(paint (below einstein einstein))
#+end_src

*** Part b
Implementing ~below~ using beside and some transformations. We will pretend that a rotate procedure has already been implemented. We will rotate both input values clockwise, and then rotate the entire full image counter clockwise.

#+caption: setup
#+header: :tangle ./src/exercise-2.51-b.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

#+caption: below implementation
#+header: :tangle ./src/exercise-2.51-b.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (below painter-1 painter-2)
  (let ([paint-below (rotate90 painter-1)]
        [paint-above (rotate90 painter-2)])
    (lambda (frame) ((rotate270 (beside paint-below paint-above)) frame))))
#+end_src

#+caption: below test a
#+header: :tangle ./src/exercise-2.51-b.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(display "einstein")
(newline)
(paint einstein)

(display "below einstein")
(newline)
(paint (below einstein einstein))
#+end_src

* Exercise 2.52
** Prompt
Leverage the concept of stratification by changing different levels of the system. Here are what needs to be done.
1. Add more segment to a painter
2. Change ~corner-split~ pattern
3. Modify ~square-limit~ so that the corners are in different patterns
** Solution
We're going to implement the three features at the same time. For the first requirement, we will swap from using wave painter to using the diamond painter, and this time, we will make sure that this new version of painter is asymmetrical.

#+caption: setup
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<higher-order-painters>>
<<vect-consts>>
<<vector-average>>
#+end_src

#+caption: adding segment to a painter (not wave, since I did not make that)
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
;; Adding new segments to make the painter assymmetrical
(define diamond-painter
  (let ([mid-left (vector-average bottom-left top-left)]
        [top-central (vector-average top-left top-right)]
        [mid-right (vector-average top-right bottom-right)]
        [bottom-central (vector-average bottom-right bottom-left)]
        [middle (make-vect 0.5 0.5)])
    (segments->painter (list (make-segment mid-left top-central)
                             (make-segment top-central mid-right)
                             (make-segment mid-right bottom-central)
                             (make-segment bottom-central mid-left)
                             (make-segment middle (vector-average middle top-central))
                             (make-segment middle (vector-average middle mid-right))
                             (make-segment (vector-average middle mid-right)
                                           (vector-average middle top-central))))))
#+end_src

We're going to make the corner more asymmetrical as well.

#+caption: change the corner split pattern
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
;; Adding new segments to make the painter assymmetrical
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ([top (up-split painter (- n 1))])
        (let ([top-right (beside top top)]
              [corner (corner-split painter (- n 1))])
          (beside (below white corner)
                  (below painter top-right))))))

#+end_src

Instead of flipping the top-left and bottom-right corner, we're going to move to rotating them.

#+caption: change the square limit procedure so that the corners are more interesting
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
;; Adding new segments to make the painter assymmetrical
(define (square-limit painter n)
  (let ([cornered-painter (corner-split painter n)])
    (beside (below (rotate180 cornered-painter) (rotate90 cornered-painter))
            (below (rotate270 cornered-painter) cornered-painter))))
#+end_src


#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(paint (square-limit diamond-painter 5))
#+end_src

Now we're done.
* Exercise 2.53
** Prompt
Describe what the interpreter would output with the following expressions
** Solution
We will write the expected output as the comment. We can easily verify that this is correct by running the code.

#+begin_src racket :exports code
#lang sicp

(list 'a 'b 'c)
;; (a b c)
(list (list 'george))
;; ((george))
(cdr '((x1 x2) (y1 y2)))
;; ((y1 y2))
(cadr '((x1 x2) (y1 y2)))
;; (y1 y2)
(pair? (car '(a short list)))
;; false
(memq 'red '((red shoes) (blue socks)))
;; false
(memq 'red '(red shoes blue socks))
;; (red shoes blue socks)
#+end_src

#+RESULTS:
: (a b c)
: ((george))
: ((y1 y2))
: (y1 y2)
: #f
: #f
: (red shoes blue socks)

* Exercise 2.54
** Prompt
Define a procedure called ~equal?~ that will compare two lists using ~eq?~ and if the element is a list, navigate that one and do the same as well.
** Solution
We could implement this recursively. Our strategy is to move through both lists at the same time.

#+begin_src racket :exports both
#lang sicp
(define (equal? a b)
  (cond
    [(and (null? a) (null? b)) true]
    [(and (pair? (car a)) (pair? (car b)))
     (if (equal? (car a) (car b))
         (equal? (cdr a) (cdr b))
         false)]
    [(not (eq? (car a) (car b))) false]
    [else (equal? (cdr a) (cdr b))]))

(equal? '(this is a list) '(this is a list))
(equal? '(this is a list) '(this (is a) list))
#+end_src

#+RESULTS:
: #t
: #f

Raw testing result showed that we successfully implemented the procedure.
* Exercise 2.55
** Prompt
Eva Lu Ator types to the interpreter the following expression.

#+begin_src racket :exports both
#lang sicp
(car ''abracadabra)
#+end_src

#+RESULTS:
: quote

Why the heck did we get ~quote~. Explain.
** Solution
The ~'~ operator in Scheme will treat the values following it as the symbol, and not the value. We should wonder, how does Scheme actually interpret this? Well since we are getting the ~quote~ from a ~car~ it is safe to assume that ~''abracadabra~ will return either a pair or a list. I will not pretend I know the answer right now, so I will do a little experiment.

#+begin_src racket :exports both
#lang sicp
(car ''abracadabra)
''abracadabra
'abracadabra
(car ''(a b c d))
''(a b c d)
'''(a b c d)
(quote (a b c d))
#+end_src

#+RESULTS:
: quote
: (quote abracadabra)
: abracadabra
: quote
: (quote (a b c d))
: (quote (quote (a b c d)))
: (a b c d)

Interesting, it looks like by accessing ~'abracadabra~ with another ~'~ we are able to see the representation for the symbol access. It is a compound object with the first element being the ~quote~ symbol, and the second element being the symbol being shown. This must be used to tell the Scheme interpreter how to access and how the value that is prepended with a quote. More accurately, prepending with a ~'~ will tell the interpreter to return the symbol, and not the value. In our experiment, we did ~'''(a b c d)~ which returned ~(quote (quote (a b c d)))~ and we see that ~(quote (a b c d))~ returns ~(a b c d)~. I think with these tests, we can see that ~quote~ is a procedure that returns its parameter as a symbol. We can also see that ~'~ is actually syntactic sugar for the ~quote~ procedure, meaning that ~(car ''abradacadabra)~ is actually just ~(car (quote (quote abradacadabra)))~ where ~quote~ will evaluate first due to applicative ordered evaluation, resulting in ~(car (quote abradacadabra))~ which will finally evaluate to ~quote~.
* Exercise 2.56
** Prompt
We're working with a system for symbolic differentiation. Implementation for differentiating sums, products, variables, and constant has been given to us. We have to reduce the expression if it is simple to do so. In this exercise, extend the system to handle variables with exponents.
** Solution
Below is the implementation that is provided to us. We will proceed to extend the implementation to add exponents of variables. We'll import this around as a base to other exercises that work with symbolic differentiation.

#+name: deriv-base
#+begin_src racket :exports code
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [else (error "unknown expression type: DERIV" exp)]))
#+end_src

#+name: deriv-base-dependencies
#+begin_src racket :exports code
(define (variable? x)
  (symbol? x))
(define (same-variable? x y)
  (and (variable? x) (variable? y) (eq? x y)))
(define (=number? exp val)
  (and (number? exp) (= exp val)))
#+end_src

#+name: deriv-base-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y) (+ x y))]
    [else (list '+ x y)]))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s)
  (cadr s))
(define (augend s)
  (caddr s))
#+end_src

#+name: deriv-base-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    [else (list '* x y)]))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p)
  (cadr p))
(define (multiplicand p)
  (caddr p))
#+end_src

#+RESULTS: deriv-base-dependencies

#+name: deriv-base-test
#+begin_src racket :exports code
(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

We'll use the strategy that often used in sicp, which is to actually use the abstraction in the algorithm before building the representation. We will write this out.

#+name: deriv-exponentiation
#+begin_src racket :exports code
;; deriv with exponentiation
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [(exponentiation? exp)
     (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1)))]
    [else (error "unknown expression type: DERIV" exp)]))
#+end_src

#+name: deriv-base-exponentiation
#+begin_src racket :exports code
;; Need to now make the representation of the exponentiation expression
(define (make-exponentiation base exponent)
  (cond [(=number? exponent 0) 1]
        [(=number? exponent 1) base]
        [else (list '** base exponent)]))

(define (exponentiation? exp) (and (pair? exp) (eq? (car exp) '**)))
(define (base exp) (cadr exp))
(define (exponent exp) (caddr exp))
#+end_src

Now we will test our implementation.

#+begin_src racket :exports both :noweb yes
#lang sicp
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<deriv-exponentiation>>
<<deriv-base-exponentiation>>
<<deriv-base-test>>
(deriv '(+ (* x y) (** x 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))

The test is not exhaustive, but this does look right.

* Exercise 2.57: Multiple arguments to product and sum
** Prompt
The goal here is to extend the representation of both product and sum to handle arbitrary amount of parameters.
** Solution
We have to make sure that we don't actually need to change the implementation of the ~deriv~ procedure to make this work. Here is the current strategy that we will attempt. We don't really need dynamic parameter unpacking, we just need to make the selector be able to retrieve representation of the sum expression that have more than two elements properly. We should be surgical with where we make the changes.

In our implementation, we made the constructor merge two instances of sums, and made the augend selector handle the case where there are more than two operands. We then do the analogous implementation on the product version.

#+name: deriv-multiple-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y)) (+ x y)]
    [(sum? y) (make-sum (make-sum x (addend y) ) (augend y))]
    [else (list '+ x y)]))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s)
  (cadr s))
(define (augend s)
  (let ([ag (cddr s)])
      (cond [(null? (cdr ag)) (car ag)]
            [(null? (cddr ag)) (make-sum (car ag) (cadr ag))]
            [else (make-sum (car ag) (cons '+ (cdr ag)))])))
#+end_src


#+name: deriv-multiple-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    [(product? y) (make-product (make-product x (multiplier y)) (multiplicand y))]
    [else (list '* x y)]))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p)
  (cadr p))
(define (multiplicand p)
  (let ([mp (cddr p)])
    (cond
      [(null? (cdr mp)) (car mp)]
      [(null? (cddr mp)) (make-product (car mp) (cadr mp))]
      [else (make-product (car mp) (cons '* (cdr mp)))])))
#+end_src


#+begin_src racket :exports both :noweb yes
#lang sicp
<<deriv-base-dependencies>>
<<deriv-multiple-sum>>
<<deriv-multiple-product>>
<<deriv-exponentiation>>
<<deriv-base-exponentiation>>
<<deriv-base-test>>
(deriv '(+ (* x y) (** x 8)) 'x)
(deriv '(* x y (+ x 3)) 'x)
(deriv '(* x y (+ x 3) 0) 'x)
(deriv '(* x y (+ x 3) 1 y) 'x)
(deriv '(+ x y (* x 3) (** x 7)) 'x)
(deriv '(+ x y (* x 3) 0 (** x 7)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))
: (+ (* x y) (* y (+ x 3)))
: 0
: (+ (* (* x y) y) (* (* y (+ x 3)) y))
: (+ 4 (* 7 (** x 6)))
: (+ 4 (* 7 (** x 6)))
* Exercise 2.58: Infix operators
** Prompt
Now modify the program to work on a representation that is infix. Make two versions, first version being that all group of expression is binary, and the second using actual normal algebraic syntax, with PEDMAS order of operations.
** Solution
*** Part A
We'll implement the system to the state where it will correctly evaluate binary infix operations. The chained implementation will be done in part B.
#+name: deriv-infix-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y)) (+ x y)]
    [else (list x '+ y)]))
(define (sum? x)
  (and (pair? x) (eq? (cadr x) '+)))
(define (addend s)
  (car s))
(define (augend s)
  (caddr s))
#+end_src


#+name: deriv-infix-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    [else (list x '* y)]))
(define (product? x)
  (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p)
  (car p))
(define (multiplicand p)
  (caddr p))
#+end_src

#+name: deriv-infix-exponentiation
#+begin_src racket :exports code
;; Need to now make the representation of the exponentiation expression
(define (make-exponentiation base exponent)
  (cond [(=number? exponent 0) 1]
        [(=number? exponent 1) base]
        [else (list base '** exponent)]))

(define (exponentiation? exp) (and (pair? exp) (eq? (cadr exp) '**)))
(define (base exp) (car exp))
(define (exponent exp) (caddr exp))
#+end_src


#+begin_src racket :exports both :noweb yes
#lang sicp
<<deriv-base-dependencies>>
<<deriv-infix-sum>>
<<deriv-infix-product>>
<<deriv-infix-exponentiation>>
<<deriv-exponentiation>>
(deriv '(x + 3) 'x)
(deriv '(x * y) 'x)
(deriv '(x * y) 'y)
(deriv '((x * y) * (x + 3)) 'x)
(deriv '((x * y) * (x + 3)) 'y)
(deriv '((x * y) + (x ** 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: ((x * y) + (y * (x + 3)))
: (y + (8 * (x ** 7)))

*** Part B
In this part, we are trying to parse normal algebraic expressions, like those that people would use. This is the type of parsing that calculators do, and to do this cleanly, we'll make an abstract syntax tree. Another goal is that we should not need to change how the ~deriv~ method works.

We'll treat the representation as a list, but we'll still recursively split it into a sequence of binary operations. The way that it has to work, since we are using recursion is that the lowest priority operation will actually just take the highest precedence, in that an expression that contains the lowest level operator will be treated as a statement of that operator. What this does is that the higher level operators will have to check for the previous level, as to allow them to take precedence in the recursion. (Taking precedence actually makes it evaluate last in our recursive architecture).

#+name: deriv-normal-common
#+begin_src racket :exports code
;; Returns true if the provided symbol, v, is in the list, l
(define (contain? l v)
  (define (iter li)
    (cond
      [(null? li) false]
      [(eq? (car li) v) true]
      [else (iter (cdr li))]))
  (iter l))

;; Returns list of all elements before the value, v
(define (before-first l v)
  (cond
    [(null? l) l]
    [(eq? (car l) v) nil]
    [else (cons (car l) (before-first (cdr l) v))]))

;; Returns list of all elements after the value, v
(define (after-first l v)
  (let ([ret (memq v l)])
    (if (pair? ret) (cdr ret) nil)))
#+end_src

#+name: deriv-normal-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y)) (+ x y)]
    ;; [(sum? y) (make-sum (make-sum x (addend y) ) (augend y))]
    [else (list x '+ y)]))
(define (sum? x)
  (and (pair? x) (contain? x '+)))
;; Assumption is that the sum check has already completed before this procedure
;; is called.
;; addend will be the elements before the first '+ symbol
(define (addend s)
  (let ([v (before-first s '+)])
    (if (null? (cdr v))
        (car v)
        v)))
(define (augend s)
  (let ([v (after-first s '+)])
    (if (null? (cdr v))
        (car v)
        v)))
#+end_src


#+name: deriv-normal-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    ;; [(product? y) (make-product (make-product x (multiplier y)) (multiplicand y))]
    [else (list x '* y)]))
;; This is more tricky. It is product if there is a * in the least nested
;; layer of the expression
(define (product? x)
  (and (pair? x) (not (contain? x '+)) (contain? x '*)))
;; Assuming that product check has always happened before this line
(define (multiplier p)
  (let ([val (before-first p '*)])
    (if (null? (cdr val)) (car val) val)))
(define (multiplicand p)
  (let ([val (after-first p '*)])
    (if (null? (cdr val)) (car val) val)))
#+end_src

#+name: deriv-normal-exponentiation
#+begin_src racket :exports code
;; Need to now make the representation of the exponentiation expression
(define (make-exponentiation base exponent)
  (cond [(=number? exponent 0) 1]
        [(=number? exponent 1) base]
        [else (list base '** exponent)]))

(define (exponentiation? exp) (and (pair? exp) (not (or (contain? exp '+) (contain? exp '*))) (contain? exp '**)))
(define (base exp)
  (car exp))
(define (exponent exp) (caddr exp))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<deriv-base-dependencies>>
<<deriv-normal-common>>
<<deriv-normal-sum>>
<<deriv-normal-product>>
<<deriv-normal-exponentiation>>
<<deriv-exponentiation>>
(assert-eq "sum predicate check" (sum? '(x + 3)) #t)
(assert-eq "sum predicate check" (sum? '(x * 3)) #f)
(assert-eq "multiple sum predicate check" (sum? '(x + 3 + 4 + y)) #t)
(assert-eq "normal expression, with one product predicate check" (sum? '(x + 3 * 4 + y)) #t)
(assert-eq "normal expression, one product predicate check" (sum? '(x * 3 + 4 + y)) #t)
(assert-eq "sum predicate on variable (should fail)" (sum? '(x)) #f)
(assert-eq "sum predicate on variable (should fail)" (sum? 'x) #f)
(assert-eq "sum predicate on number (should fail)" (sum? '(3)) #f)
(assert-eq "getting the adden" (addend '(3 + 4)) 3)
(assert-eq "getting the augend" (augend '(3 + 4)) 4)
(assert-eq "getting the augend" (augend '(3 + x + y)) '(x + y))
(assert-eq "getting the augend" (augend '(3 + x + y + z)) '(x + y + z))
(assert-eq "getting the addend" (addend '(x + 3 * 4 + y)) 'x)
(assert-eq "getting the augend" (augend '(x + 3 * 4 + y)) '(3 * 4 + y))
(assert-eq "getting the addend" (addend '(x * 3 + 4 + y)) '(x * 3))
(assert-eq "getting the addend" (augend '(x * 3 + 4 + y)) '(4 + y))
(assert-eq "product predicate check" (product? '(x * 3)) #t)
(assert-eq "product predicate check" (product? '(x + 3)) #f)
(assert-eq "multiple product predicate check" (product? '(x * 3 * y)) #t)
(assert-eq "multiple product predicate check" (product? '(x + 3 + y)) #f)
(assert-eq "multiple product predicate check" (product? '(x + 3 * y)) #f)
(assert-eq "multiple product predicate check" (product? '(x * 3 + y)) #f)
(assert-eq "product predicate on variable (should fail)" (product? '(x)) #f)
(assert-eq "product predicate on variable (should fail)" (product? 'x) #f)
(assert-eq "product predicate on number (should fail)" (product? '(3)) #f)
(assert-eq "multiple exponent predicate check" (exponentiation? '(x * 3 * y)) #f)
(assert-eq "multiple exponent predicate check" (exponentiation? '(x * 3 * y ** 2)) #f)
(assert-eq "multiple exponent predicate check" (exponentiation? '(x ** 3)) #t)
(deriv '(x + 3) 'x)
(deriv '(x + 3 + y) 'x)
(deriv '(x * y) 'x)
(deriv '((x * y) * (x + 3)) 'x)
(deriv '(x + 3 * (x + y + 2)) 'x)
(deriv '((x * y) + (x ** 8)) 'x)
#+end_src

#+RESULTS:
#+begin_example
pass: sum predicate check value: #t expected: #t
pass: sum predicate check value: #f expected: #f
pass: multiple sum predicate check value: #t expected: #t
pass: normal expression, with one product predicate check value: #t expected: #t
pass: normal expression, one product predicate check value: #t expected: #t
pass: sum predicate on variable (should fail) value: #f expected: #f
pass: sum predicate on variable (should fail) value: #f expected: #f
pass: sum predicate on number (should fail) value: #f expected: #f
pass: getting the adden value: 3 expected: 3
pass: getting the augend value: 4 expected: 4
pass: getting the augend value: (x + y) expected: (x + y)
pass: getting the augend value: (x + y + z) expected: (x + y + z)
pass: getting the addend value: x expected: x
pass: getting the augend value: (3 * 4 + y) expected: (3 * 4 + y)
pass: getting the addend value: (x * 3) expected: (x * 3)
pass: getting the addend value: (4 + y) expected: (4 + y)
pass: product predicate check value: #t expected: #t
pass: product predicate check value: #f expected: #f
pass: multiple product predicate check value: #t expected: #t
pass: multiple product predicate check value: #f expected: #f
pass: multiple product predicate check value: #f expected: #f
pass: multiple product predicate check value: #f expected: #f
pass: product predicate on variable (should fail) value: #f expected: #f
pass: product predicate on variable (should fail) value: #f expected: #f
pass: product predicate on number (should fail) value: #f expected: #f
pass: multiple exponent predicate check value: #f expected: #f
pass: multiple exponent predicate check value: #f expected: #f
pass: multiple exponent predicate check value: #t expected: #t
1
1
y
((x * y) + (y * (x + 3)))
4
(y + (8 * (x ** 7)))
#+end_example

And voila! We are now able to symbolically differentiate a smaller subset of normal algebraic expressions.
* Exercise 2.59
** Prompt
Implement ~union-set~ for the unordered-list representation of a set
** Solution
The following is the provided code from sicp.

#+name: set-unordered-list
#+begin_src racket :exports code
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(equal? x (car set)) true]
    [else (element-of-set? x (cdr set))]))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond
    [(or (null? set1) (null? set2)) '()]
    [(element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))]
    [else (intersection-set (cdr set1) set2)]))
#+end_src

Set unions are the combination of two sets, all we would have to do is to make sure that we don't include an element that already exists.

#+name: set-unordered-list-union
#+begin_src racket :exports code
(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [(element-of-set? (car set1) set2) (union-set (cdr set1) set2)]
    [else (cons (car set1) (union-set (cdr set1) set2))]))
#+end_src

The following is just some checks to make sure that union is unioning.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<set-unordered-list>>
<<set-unordered-list-union>>
<<assertion-suite>>
(define seta '(a b c d e))
(define setb '(d e f g h i j))
(intersection-set seta setb)
(union-set seta setb)
#+end_src

#+RESULTS:
: (d e)
: (a b c d e f g h i j)

Judging by the result of evaluating the code block, the union is unioning.
* Exercise 2.60
** Prompt
Now let the representation allow for duplicates. Re-implement the selectors and constructors, then compare the efficiency of this representation with the noon-duplicate version.
** Solution

#+name: set-unordered-list-duplicate
#+begin_src racket :exports code
;; Does not need to change
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(equal? x (car set)) true]
    [else (element-of-set? x (cdr set))]))

;; Always add without checking. This is how we get duplicates
(define (adjoin-set x set)
  (cons x set))

(define (intersection-set set1 set2)
  (cond
    [(or (null? set1) (null? set2)) '()]
    [(element-of-set? (car set1) set2) (adjoin-set (car set1) (intersection-set (cdr set1) set2))]
    [else (intersection-set (cdr set1) set2)]))

(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [else (cons (car set1) (union-set (cdr set1) set2))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<set-unordered-list-duplicate>>
<<assertion-suite>>
(define seta '(a b c d e))
(define setb '(d e f g h i j))
(define int-set (intersection-set seta setb) )
(define uni-set (union-set seta setb) )
(element-of-set? 'a int-set)
(element-of-set? 'a uni-set)
int-set
uni-set
#+end_src

#+RESULTS:
: #f
: #t
: (d e)
: (a b c d e d e f g h i j)

Let's talk about the efficiency of this implementation. Adjoining the set, unioning a set is faster, however, after enough duplicates have been inserted into the set, lookup will become slower. This means in general, both the containment predicate and set intersection will perform worse than the non-duplicate version. The specifics of when each implementation is better than the other is very dependent on the usecase. The generalization here is that many insertion with few containment checks make duplicate good, few insertions with many containment checks make non-duplicate good.
* Exercise 2.61
** Prompt
We have now looked at the ordered list representation of the set, and how it could make intersection operations linear due to the invariant of the representation being sorted, as we no longer have to search the entire list again everytime. This is very akin to merge sort. In fact, merge sort might be easier to implement on lisp than other sorting algorithms.

Now the goal of this exercise is to implement ~adjoin-set~ and show how using ordering can, on average, make the implementation take half the steps of the unordered representation.
** Solution

#+name: ordered-list-set-base
#+begin_src racket :exports code
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(= x (car set)) true]
    [(< x (car set)) false]
    [else (element-of-set? x (cdr set))]))

(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ([x1 (car set1)]
            [x2 (car set2)])
        (cond
          [(= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2)))]
          [(< x1 x2) (intersection-set (cdr set1) set2)]
          [else (intersection-set set1 (cdr set2))]))))
#+end_src

#+name: ordered-list-set-adjoin
#+begin_src racket :exports code
;; let's make an iterative closure to check if we have gotten to the thing.
;; This procedure can either return the original set or a newly sorted
;; set.
(define (adjoin-set x set)
  (cond [(null? set) (list x)]
        [(= x (car set)) set]
        [(< x (car set)) (cons x set)]
        [else (cons (car set) (adjoin-set x (cdr set)))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<ordered-list-set-base>>
<<ordered-list-set-adjoin>>
(define test-set (list 1 2 3 6 7 10))
test-set
(adjoin-set 5 test-set)
(adjoin-set 3 test-set)
(adjoin-set 100 test-set)
#+end_src

#+RESULTS:
: (1 2 3 6 7 10)
: (1 2 3 5 6 7 10)
: (1 2 3 6 7 10)
: (1 2 3 6 7 10 100)

I'll just describe how we took advantage of ordering to half the steps on average vs the unordered method. Because ordered, we can find out when the element does not exist in the set as we traverse from the first element to the last element by seeing when the value we are trying to add is lower than the element we are looking at, as all elements after that will be even larger. If we managed to get to the end of the list, we know that the element does not exist in the set, and that it is larger than all the other element, so we could place it there.
* Exercise 2.62
** Prompt
Make ~union-set~ for ordered list set.
** Solution

#+name: ordered-list-set-union
#+begin_src racket :exports code
(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [else
     (let ([x1 (car set1)]
           [x2 (car set2)])
       (cond
         [(= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2)))]
         [(< x1 x2) (cons x1 (union-set (cdr set1) set2))]
         [(< x2 x1) (cons x2 (union-set set1 (cdr set2)))]))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<ordered-list-set-base>>
<<ordered-list-set-adjoin>>
<<ordered-list-set-union>>
(define test-set (list 1 2 3 6 7 10))
(define test-set2 (list 5 6 7 8 9 10))
test-set
test-set2
(union-set test-set test-set2)
#+end_src

#+RESULTS:
: (1 2 3 6 7 10)
: (5 6 7 8 9 10)
: (1 2 3 5 6 7 8 9 10)
* Exercise 2.63
** Prompt
We are provided two procedures that transforms a tree into a list. Answer the following two questions:
a. Do the two procedures generate the same output for every tree? If not, how do they differ? We are provided three input trees, what list do they make?
b. Do the two procedures have the same order of growth (balanced tree only)? If not, which one grows more slowly?
** Solution
#+name: base-tree-representation
#+begin_src racket :exports code
(define (entry tree)
  (car tree))
(define (left-branch tree)
  (cadr tree))
(define (right-branch tree)
  (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
#+end_src

#+name: flat-tree-1
#+begin_src racket :exports code
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree) (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree) (copy-to-list (right-branch tree) result-list)))))
  (copy-to-list tree '()))
#+end_src

#+name: trees-2.16
#+begin_src racket :exports code
(define tree-1
  (make-tree 7
             (make-tree 3 (make-tree 1 '() '()) (make-tree 5 '() '()))
             (make-tree 9 '() (make-tree 11 '() '()))))
(define tree-2
  (make-tree 3
             (make-tree 1 '() '())
             (make-tree 7 (make-tree 5 '() '()) (make-tree 9 '() (make-tree 11 '() '())))))
(define tree-3
  (make-tree 5
             (make-tree 3  (make-tree 1 '() '()) '())
             (make-tree 9 (make-tree 7 '() '()) (make-tree 11 '() '()))))
#+end_src
*** Part a
They make the same output. They are both built with recursive breakdown of the tree where each unit of the procedure is combining the flatten list of the left subtree is combined with the right flattened list of the right subtree with the entry as the value in between these new flattened list. This means that the output of both the procedures will generate the same value. Actually, because of the invariant of the binary tree, the output list will just be a sorted list.

Running the procedure on all three trees in [[trees-2.16]] will result in the following lists.

#+beg
(1 3 5 7 9 11)
(1 3 5 7 9 11)
(1 3 5 7 9 11)
#+end_example

The above solution was done before evaluating the procedure on the sample trees. As a good engineer, we should double check the work.

#+begin_src racket :exports both :noweb yes
#lang sicp
<<base-tree-representation>>
<<flat-tree-1>>
<<trees-2.16>>
(tree->list-1 tree-1)
(tree->list-1 tree-2)
(tree->list-1 tree-3)
(tree->list-2 tree-1)
(tree->list-2 tree-2)
(tree->list-2 tree-3)
#+end_src

#+RESULTS:
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)

Wow, that's crazy.
*** Part b
Do they have the same order of growth? If not, which one grows more slowly.

Well this question is implementation specific. If we're using the Scheme in the SICP lectures, it's important to analyze ~append~. ~append~ is a procedure that combines two LISP lists together, and since the Scheme list is a singly linked list, ~append~ must generate a new list by iterating over all element of one of them, and using ~cons~ to make the combined one. Although we are under the illusion that we arrive at each nodes once, ~tree->list-1~ is actually \(\Theta \left( n^{2} \right)\), while ~tree->list-2~ grows at \(\Theta \left( n \right)\), which is really a lession on how data structures could subtly affect the best algorithm implementation.
* Exercise 2.64
** Prompt
We are given a procedure that converts a list to a tree. It uses a helper procedure called ~partial-tree~ that takes an argument ~n~ for the number of elements of the list to be transformed into a tree, and the list of elements to be transformed. Answer the following two questions:
a. Write a short paragraph explaining, as clearly as possible, how ~partial-tree~ works. Then draw the tree ~(1 3 5 7 9 11)~ produced from ~list->tree~
b. What is the order of growth for the ~list->tree~ for a list of ~n~ elements?
** Solution
#+name: list->tree
#+begin_src racket :exports code
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ([left-size (quotient (- n 1) 2)])
        (let ([left-result (partial-tree elts left-size)])
          (let ([left-tree (car left-result)]
                [non-left-elts (cdr left-result)]
                [right-size (- n (+ left-size 1))])
            (let ([this-entry (car non-left-elts)]
                  [right-result (partial-tree (cdr non-left-elts) right-size)])
              (let ([right-tree (car right-result)]
                    [remaining-elts (cdr right-result)])
                (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))
#+end_src
*** Part a
Let's explain what the ~partial-tree~ procedure is doing. This helper procedure lets build arbitrary balanced trees in a recursive manner. The input parameter ~n~ and the ~remaining-elts~ return value allow flexible use of the procedure. Let's get into what it is doing. At a high level, the procedure is splitting the input list into left side, and right side, where it will build the left side first. Because of the ~(quotient (- n 1) 2)~ as the ~n~ for the left side, it means that the left branch of the tree will be filled last. It will do recursive calls on the tree until it cannot get a left branch anymore, which occurs at ~n~ equals or less than 2. Once this happens, it will use the first element of the list as the current sub-tree entry, and the remaining ~n~ values that do not count the left tree entries and the current entry as the right subtree. The algorithm of the right subtree is the same. Once both the left and right subtrees are built (although the left subtree would be empty), the left and right trees are combined with the current entry as the top-level node. After this, we return both the newly constructed tree and the rest of the elements that are not used in constructing the tree. And then the same process is done. Procedure can operate without knowing if it is building the left or the right tree.

#+caption: Diagram of the tree that is built from list->tree
#+begin_example
   5
 /   \
1     9
 \   / \
  3 7   11
#+end_example
*** Part b
What is the order of growth for the steps for a list of ~n~ elements?

This is a linear algorithm, the elements becomes a node exactly once. \(\Theta \left( n \right)\).
* Exercise 2.65
** Prompt
Create a \Theta(n) implementation of ~union-set~ and ~intersection-set~ for the set implementation of the balanced binary tree

** Solution
#+name: tree-set-unit
#+begin_src racket :exports code
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(= x (entry set) true)]
    [(< x (entry set)) (element-of-set? x (left-branch set))]
    [else (element-of-set? x (right-branch set))]))

(define (adjoin-set x set)
  (cond
    [(null? set) (make-tree x '() '())]
    [(= x (entry set)) set]
    [(< x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))]
    [else (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))]))
#+end_src

So if we want to intersection or union, at best it will be a linear algorithm (we'll have to iterate through at least one, at most both of the elements of the sets). We've solved this problem pretty well using ordered list representation of set, and we happen to have the ability to make an ordered list from the tree representation. Obviously, we will just do that again.

#+name: tree-set-union
#+begin_src racket :exports code
(define (union-ordered-list list1 list2)
  (cond
    [(null? list1) list2]
    [(null? list2) list1]
    [else
     (let ([x1 (car list1)]
           [x2 (car list2)])
       (cond
         [(= x1 x2) (cons x1 (union-ordered-list (cdr list1) (cdr list2)))]
         [(< x1 x2) (cons x1 (union-ordered-list (cdr list1) list2))]
         [(< x2 x1) (cons x2 (union-ordered-list list1 (cdr list2)))]))]))
(define (union-set set1 set2)
  (let ([list1 (tree->list-2 set1)]
        [list2 (tree->list-2 set2)])
    (list->tree (union-ordered-list list1 list2))))

#+end_src

#+name: tree-set-intersection
#+begin_src racket :exports code
(define (intersection-ordered-list list1 list2)
  (if (or (null? list1) (null? list2))
      '()
      (let ([x1 (car list1)]
            [x2 (car list2)])
        (cond
          [(= x1 x2) (cons x1 (intersection-ordered-list (cdr list1) (cdr list2)))]
          [(< x1 x2) (intersection-ordered-list (cdr list1) list2)]
          [else (intersection-ordered-list list1 (cdr list2))]))))

(define (intersection-set set1 set2)
  (let ([list1 (tree->list-2 set1)]
        [list2 (tree->list-2 set2)])
    (list->tree (intersection-ordered-list list1 list2))))
#+end_src


#+name: tree-set-intersect
#+begin_src racket :exports code
#+end_src

#+RESULTS: tree-set-intersect

#+begin_src racket :exports both :noweb yes
#lang sicp
<<base-tree-representation>>
<<flat-tree-1>>
<<list->tree>>
<<tree-set-unit>>
<<tree-set-union>>
<<tree-set-intersection>>
(define test-set (list->tree (list 1 2 3 6 7 10)))
(define test-set2 (list->tree (list 5 6 7 8 9 10)))
test-set
test-set2
(union-set test-set test-set2)
(intersection-set test-set test-set2)
(tree->list-2 test-set)
(tree->list-2 test-set2)
(tree->list-2 (union-set test-set test-set2))
(tree->list-2 (intersection-set test-set test-set2))
#+end_src

#+RESULTS:
: (3 (1 () (2 () ())) (7 (6 () ()) (10 () ())))
: (7 (5 () (6 () ())) (9 (8 () ()) (10 () ())))
: (6 (2 (1 () ()) (3 () (5 () ()))) (8 (7 () ()) (9 () (10 () ()))))
: (7 (6 () ()) (10 () ()))
: (1 2 3 6 7 10)
: (5 6 7 8 9 10)
: (1 2 3 5 6 7 8 9 10)
: (6 7 10)

Yep, here is your \Theta(n) implementation of the union and intersection operators.
* Exercise 2.66
** Prompt
Implement the ~lookup~ procedure for the case where the set of records is structured as binary tree ordered by the numerical values of the keys
** Solution
#+name: binary-tree-lookup
#+begin_src racket :exports code
(define (lookup given-key bin-tree)
  (if (null? bin-tree) false
      (let ([curr-val (entry bin-tree)])
        (cond [(= given-key curr-val) bin-tree]
              [(< given-key curr-val) (lookup given-key (left-branch bin-tree))]
              [else (lookup given-key (right-branch bin-tree))]))))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<base-tree-representation>>
<<flat-tree-1>>
<<list->tree>>
<<tree-set-unit>>
<<tree-set-union>>
<<tree-set-intersection>>
<<binary-tree-lookup>>
(define test-set (list->tree (list 1 2 3 6 7 10)))
(define test-set2 (list->tree (list 5 6 7 8 9 10)))
test-set
test-set2
(lookup 1000 test-set)
(lookup 1 test-set)
(lookup 8 test-set2)
#+end_src

#+RESULTS:
: (3 (1 () (2 () ())) (7 (6 () ()) (10 () ())))
: (7 (5 () (6 () ())) (9 (8 () ()) (10 () ())))
: #f
: (1 () (2 () ()))
: (8 () ())

Yes, it works, and it is not so bad to implement.
* Exercise 2.67
** Prompt
This is a non-problem. We are given a Huffman tree and a code. Evaluate.
** Solution
Only thing we really need to do here is port over the procedure from the chapter, and then run the procedure on the exercise data. Technically, I could just hand evaluate the code, but that would come back and waste my time in the next exercises.

#+name: huffman-leaf
#+begin_src racket :exports code
;; This is just the representation that we chose for the leaf
(define (make-leaf symbol weight) (list 'leaf symbol weight))
(define (leaf? object) (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
#+end_src

#+name: huffman-tree
#+begin_src racket :exports code
;; Constructors and selectors for the component in the huffman tree
;; for navigation
(define (make-code-tree left right)
  (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right))))
(define (left-branch tree)
  (car tree))
(define (right-branch tree)
  (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
#+end_src

#+name: huffman-tree-decode
#+begin_src racket :exports code
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond [(= bit 0) (left-branch branch)]
        [(= bit 1) (right-branch branch)]
        [else (error "bad bit: CHOOSE-BRANCH" bit)]))
#+end_src

#+name: weighted-set
#+begin_src racket :exports code
(define (adjoin-set x set)
  (cond
    [(null? set) (list x)]
    [(< (weight x) (weight (car set))) (cons x set)]
    [else (cons (car set) (adjoin-set x (cdr set)))]))

;; Pairs is a list of list that looks like this (symbol weight), but we should have appropriate selectors.
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ([pair (car pairs)])
        (adjoin-set (make-leaf (car pair) (cadr pair)) (make-leaf-set (cdr pairs))))))
#+end_src

#+name: sample-huffman
#+begin_src racket :exports code
(define sample-tree
         (make-code-tree (make-leaf 'A 4)
                         (make-code-tree (make-leaf 'B 2)
                                         (make-code-tree
                                          (make-leaf 'D 1)
                                          (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
(decode sample-message sample-tree)
#+end_src

#+RESULTS:
: (A D A B B C A)

Yep, this looks correct.
* Exercise 2.68
** Prompt
We are now given an ~encode~ procedure, and we must implement the ~encode-symbol~ procedure. After this, test the procedure on the sample messages from the previous exercise.
** Solution
Looking at how we implemented the datastructure for the huffman tree, we need to leverage the following attributes. Are we at a leaf node? If not, we should look at the children, and check if the target is in those sets. If not a leaf and not in the children, then raise error. If in, then traverse there.
#+name: huffman-encode
#+begin_src racket :exports code
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree) (encode (cdr message) tree))))

;; This means that encode-symbol only have to make one symbol turn into a
;; collection of bits by navigating the huffman tree.
;; We need to be able to check if the symbol is in a set, therefore, we need to
;; implement a new set lookup procedure as well
(define (encode-symbol char tree)
  (define (local-lookup val subtree)
    (pair? (list-lookup val (symbols subtree) (lambda (x) x))))
  (define (encode-symbol-aux subtree)
    (let ([left (left-branch subtree)]
          [right (right-branch subtree)])
     (cond
       [(null? subtree) (error "empty subtree")]
       [(and (leaf? subtree) (eq? (symbol-leaf subtree) char)) '()]
       [(local-lookup char left)
        (cons 0 (encode-symbol-aux left))]
       [(local-lookup char right)
        (cons 1 (encode-symbol-aux right))]
       [else (error "symbol not found in tree, Symbol, Tree: " char tree)])))
  (encode-symbol-aux tree))

;; Iterative procedure that will lookup our representation of the set
;; I will say that this procedure is written in an overkill way
(define (list-lookup target-key set key-getter)
  (if (null? set)
      false
      (let ([head-val (key-getter (car set))])
        (if (equal? head-val target-key)
            set
            (list-lookup target-key (cdr set) key-getter)))))
#+end_src

#+RESULTS: huffman-encode


#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
<<huffman-encode>>
sample-message
(decode sample-message sample-tree)
(encode (decode sample-message sample-tree) sample-tree)
;; The following line fails in a failure like we expect it to.
;; (encode '(A B D B A X) sample-tree)
#+end_src

#+RESULTS:
: (0 1 1 0 0 1 0 1 0 1 1 1 0)
: (A D A B B C A)
: (0 1 1 0 0 1 0 1 0 1 1 1 0)
* Exercise 2.69
** Prompt
We are to make the infrastructure required to make a huffman tree from just the frequency list. We are given ~generate-huffman-tree~, and we have to make ~successive-merge~ that will keep merging the smallest elements of the set until there is only one element left. Most of the required procedures have been built, so this should be a relatively simple procedure.
** Solution
#+name: generate-huffman-tree
#+begin_src racket :exports code
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
#+end_src

Let's just get into the meat of building successive merge.

#+name: huffman-successive-merge
#+begin_src racket :exports code
;; Working with a set of leaves, but actually, the elements are not just leaves.
;; Here is the invariant we are working with. The set is ordered by weight, and
;; we are trying to combine the smallest weighted values together recursively
(define (successive-merge leaf-set)
  (cond
    [(null? leaf-set) (error "reached empty set")]
    [(null? (cdr leaf-set)) (car leaf-set)]
    [else
     (successive-merge (adjoin-set (make-code-tree (car leaf-set) (cadr leaf-set))
                                   (cddr leaf-set)))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
<<huffman-encode>>
<<generate-huffman-tree>>
<<huffman-successive-merge>>
(generate-huffman-tree '((A 4) (B 2) (C 1) (D 1)))
sample-tree
#+end_src

#+RESULTS:
: ((leaf A 4) ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4) (A B D C) 8)
: ((leaf A 4) ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4) (A B D C) 8)

Yep, and now we are done.
* Exercise 2.70
** Prompt
Run the huffman encoding on song lyric. Also describe the number of bits required to encode the song, and what the required number of bits to encode the song if we are using fixed width encoding.
** Solution
Okay.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
<<huffman-encode>>
<<generate-huffman-tree>>
<<huffman-successive-merge>>
(define song-tree (generate-huffman-tree '((A 2) (GET 2) (SHA 3) (WAH 1) (BOOM 1) (JOB 2) (NA 16) (YIP 9))))
song-tree
(define song '(GET A JOB SHA NA NA NA NA NA NA NA NA GET A JOB SHA NA NA NA NA NA NA NA NA WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP YIP SHA BOOM))
(define encoded-song (encode song song-tree) )
(display "number of symbols in the song: " ) (display (length song)) (newline)
encoded-song
(length encoded-song)
#+end_src

#+RESULTS:
: ((leaf NA 16) ((leaf YIP 9) (((leaf A 2) ((leaf BOOM 1) (leaf WAH 1) (BOOM WAH) 2) (A BOOM WAH) 4) ((leaf SHA 3) ((leaf JOB 2) (leaf GET 2) (JOB GET) 4) (SHA JOB GET) 7) (A BOOM WAH SHA JOB GET) 11) (YIP A BOOM WAH SHA JOB GET) 20) (NA YIP A BOOM WAH SHA JOB GET) 36)
: number of symbols in the song: 37
: (1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 0 1 0)
: 86

We needed 86 bits to encode the song. If we were to use fixed width encoding, for a song with 8 symbols, we would use 3 bits to encode each symbols. Knowing that there are 37 symbols in the song, we would use src_elisp{(* 3 37)} {{{results(=111=)}}} bits. So yes, huffman encoding is more efficient than fixed width encoding.
* Exercise 2.71
** Prompt
Suppose we are trying to huffman encode data with the following incrementing pattern, for n symbols, each value is 2^{n-1}. Draw out the Huffman tree for n=5 and n=10. Generalize and tell us how many bits are required to represent the most frequent and least frequent symbols.
** Solution
#+begin_src plantuml :exports results :results file :file ./images/exercise-2.71-a.svg
@startuml
circle 32
circle 15
circle 7
circle 3

rectangle A
rectangle B
rectangle C
rectangle D
rectangle E

32 --  E: 1
32 --  15: 0

15 -- 7: 0
15 -- D: 1

7 -- 3: 0
7 -- C: 1

3 -- A: 0
3 -- B: 1
@enduml
#+end_src

#+RESULTS:
[[file:./images/exercise-2.71-a.svg]]

This combination of values generates a very unbalanced tree, where other than the two least frequent elements, there will be a symbol for every number of bits. Actually, there might be more to it than that. We can discuss this after drawing the Huffman tree for n=10.

#+begin_src plantuml :exports results :results file :file ./images/exercise-2.71.svg
@startuml
circle 1023
circle 511
circle 255
circle 127
circle 63
circle 31
circle 15
circle 7
circle 3

rectangle A
rectangle B
rectangle C
rectangle D
rectangle E
rectangle F
rectangle G
rectangle H
rectangle I
rectangle J

1023 --  511: 0
1023 --  J: 1

511 -- 255: 0
511 -- I: 1

255 -- 127: 0
255 -- H: 1

127 -- 63: 0
127 -- G: 1

63 -- 31: 0
63 -- F: 1

31 -- 15: 0
31 -- E: 1

15 -- 7: 0
15 -- D: 1
7 -- 3: 0
7 -- C: 1
3 -- A: 0
3 -- B: 1
@enduml
#+end_src

#+RESULTS:
[[file:./images/exercise-2.71.svg]]

Well, we see that there is just a really long branch, and actually, the minimum number of bits is always going to be 1, and the largest number of bits will be n - 1, coming from the structure of the tree, where we see that there is a symbol that will be matched with every bit length except for the two least frequent symbols, which share the same tree nodes.

Let's check our work by using our program.

#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
<<huffman-encode>>
<<generate-huffman-tree>>
<<huffman-successive-merge>>
(define incrementing-symbols '(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z))

(define (make-incrementing-sequence n)
  (define (iter m acc symbol-list) (if (>= m n)
                                       acc
                                       (iter (+ m 1) (cons (list (car symbol-list) (expt 2 m)) acc) (cdr symbol-list))))
  (iter 0 '() incrementing-symbols))
(make-incrementing-sequence 5)
(generate-huffman-tree (make-incrementing-sequence 5))
(make-incrementing-sequence 10)
(generate-huffman-tree (make-incrementing-sequence 10))
#+end_src

#+RESULTS:
: ((E 16) (D 8) (C 4) (B 2) (A 1))
: (((((leaf A 1) (leaf B 2) (A B) 3) (leaf C 4) (A B C) 7) (leaf D 8) (A B C D) 15) (leaf E 16) (A B C D E) 31)
: ((J 512) (I 256) (H 128) (G 64) (F 32) (E 16) (D 8) (C 4) (B 2) (A 1))
: ((((((((((leaf A 1) (leaf B 2) (A B) 3) (leaf C 4) (A B C) 7) (leaf D 8) (A B C D) 15) (leaf E 16) (A B C D E) 31) (leaf F 32) (A B C D E F) 63) (leaf G 64) (A B C D E F G) 127) (leaf H 128) (A B C D E F G H) 255) (leaf I 256) (A B C D E F G H I) 511) (leaf J 512) (A B C D E F G H I J) 1023)

Yep, this looks right.
* Exercise 2.72
** Prompt
What is the order of growth for encoding a single symbol, using the implementation from [[*Exercise 2.68][Exercise 2.68]]? Include the search step as well. Consider the special case where the relative frequency of the signal is as described in [[*Exercise 2.71][Exercise 2.71]]. Specifically, the number of steps required to encode the most and least frequent symbol. (The book does not believe that I could define this for the general case).
** Solution
Here is the implementation as a reminder.
#+begin_src racket :exports code
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree) (encode (cdr message) tree))))

;; This means that encode-symbol only have to make one symbol turn into a
;; collection of bits by navigating the huffman tree.
;; We need to be able to check if the symbol is in a set, therefore, we need to
;; implement a new set lookup procedure as well
(define (encode-symbol char tree)
  (define (local-lookup val subtree)
    (pair? (list-lookup val (symbols subtree) (lambda (x) x))))
  (define (encode-symbol-aux subtree)
    (let ([left (left-branch subtree)]
          [right (right-branch subtree)])
     (cond
       [(null? subtree) (error "empty subtree")]
       [(and (leaf? subtree) (eq? (symbol-leaf subtree) char)) '()]
       [(local-lookup char left)
        (cons 0 (encode-symbol-aux left))]
       [(local-lookup char right)
        (cons 1 (encode-symbol-aux right))]
       [else (error "symbol not found in tree, Symbol, Tree: " char tree)])))
  (encode-symbol-aux tree))

;; Iterative procedure that will lookup our representation of the set
;; I will say that this procedure is written in an overkill way
(define (list-lookup target-key set key-getter)
  (if (null? set)
      false
      (let ([head-val (key-getter (car set))])
        (if (equal? head-val target-key)
            set
            (list-lookup target-key (cdr set) key-getter)))))
#+end_src
~encode-symbol~ takes two parameters, the symbol being encoded, and the Huffman tree used to represent ~m~ symbols. We also have a few structure invariant, such as how each of the nodes will return a set for both the weight and the symbols that is under that node. The two notable things here is that the sets are represented as lists, and that they are sorted by weight (lowest to highest).

We assume that list manipulation primitives are constant time: \Theta(1). Type checking, such as ~null?~ and ~pair?~ are also constant time: \Theta(1), and also that ~define~ is a \Theta(1) operation.

To choose which branch to navigate to using the symbol in the tree, we do a set containment check, which is done on a list that is sorted by weight. This is a linear search, with the size of the search being the elements of the tree that is under it, therefore, the steps of growth for this stage of the algorithm is linear, and it scales with ~m~. Best case is that the search target is in the front of the list, which would be \Theta(1), worst case is that the symbol is either at the back of the list, or it is not present, which would cost however many symbols are under that node.

We'll continue our analysis for a symbol that will map to a sequence of ~b~ bits. If the symbol maps to ~b~ bits, then the main logic of ~encode-symbol~ would happen ~b~ times, with each layer having its own linear time set search to determine which branch to navigate to next. Another thing to note is that as the iteration continues, the size of the set being searched decreases. What we find here is that the growth of the steps for searching the tree is compounded on the set search.

What is difficult here is that the efficiency of the set search and the tree navigation is dependent on the shape of the tree. Knowing this, we will just analyze the two special case from [[*Exercise 2.71][Exercise 2.71]].

First is the most frequent case. Here, ~b~ is 1, but the most frequent symbol will appear more than the combination of the rest of the symbols. In our implementation, we do the containment check on the left branch before the right branch, and since the target symbol is not present there, we will always check all the m - 1 elements in that set, and therefore, ~m~ elements will be searched before finding the most frequent symbol (just because of the list representation of the set). This leaves us at \Theta(m) steps of growth for the most frequent symbol.

For the least frequent symbol, the searching would have to traverse the entire bit tree, but due to the set being sorted by weight, the target symbol will always show up at the front of the search, making the set lookup for the least frequent symbol a constant operation for this tree shape. Instead, the growth comes from traversing down to the lowest layer of the tree, building ~b~ bits. The value of ~b~ was solved in the previous exercise, giving us m - 1 steps. This also leaves us at \Theta(m) steps of growth for encoding the least frequent symbol in the Huffman tree of the shape defined in the previous exercise. Yes, if the set of symbol was not sorted by weight, then the searching component of the process would have been linear time, pushing this case to $\Theta(m^2)$, but we should consider the implementation details.

Here is an explanation of how we could have gotten $\Theta(m^2)$ if the symbols were not sorted by weight. Searching is most intensive at the top of the tree, but every layer down the tree, the number of elements decrease by 1. Say in the worse case scenario, we always search the entire set, by the time we get to the bottom of the tree, we'd have to do the following set search sizes to the tree.

$$\left( m - 1 \right) + \left( m - 2 \right) + \cdots + 2 + 1$$

Using the young Gauss strategy of finding recurring patterns, we see that the pattern that we just showed allows us to form pairs of $\left( m - n \right)$ and $n$, which would cancel out to $m$. When $m$ is an odd value, the upper half and lower half of the sum will cancel out perfectly, leaving the result of the sum as $\left( m^2\div 2 \right)$. If $m$ is an even value, there will be a leftover in the middle of the sum, resulting in $\left( m^2 \div 2 \right) + \left( m \div 2 \right)$. \Theta notation only cares about the value that will contribute the most, and removes the coefficient, therefore, we get $\Theta(m^2)$.

As a reminder, the Huffman tree for this special case looks like the following:

[[file:./images/exercise-2.71.svg]]

I suppose that in conclusion, encoding a symbol with a tree of this shape takes linear time: \Theta(m).
* Exercise 2.73
** Prompt
We have just covered dispatches, and now we are working on data-directed style of generic procedures. For this exercise, we will review the symbolic differentiation procedure that was designed in sicp section 2.3.2.

#+caption: Previous version of the symbolic differentiation procedure
#+name: 2.73-old-dispatch
#+begin_src racket :exports code
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [else (error "Unknown expression type: DERIV" exp)]))
#+end_src

We can convert the old version of the symbolic differentiation to the data-directed procedure by doing the following to it.

#+caption: Data-driven implementation of deriv
#+name: 2.73-data-driven
#+begin_src racket :exports code
(define (deriv exp var)
 (cond [(number? exp) 0]
       [(variable? exp) (if (same-variable? exp var) 1 0)]
       [else ((get 'deriv (operator exp)) (operand exp) var)]))

(define (operator exp) (car exp))
(define (operand exp) (cdr exp))
#+end_src

There are now a few questions that must be answered.

a. Explain what was done above, and explain why ~number?~ and ~variable?~ cannot be moved into data-driven dispatch.
b. Write the procedure for derivatives of sums and products, and the auxiliary code required to install them in the table used by the program above.
c. Choose any additional differentiation rule that you like, such as exponents, and install it into this data-directed system.
d. Right now, the type of the expression is the algebraic operator that binds the expression together. What if we index the procedure in the opposite way, such that the dispatch line in the ~deriv~ procedure look like the following. ~((get (operator exp) 'deriv') (operands exp) var)~.
** Solution
*** Part a
The data driven solution is to check for the primitives, which are numbers and variables, and if the it was found that the exp is an actual registered expression, then use the data-driven table to lookup the corresponding procedure, and then dispatch it. Lookup process is done with ~deriv~ as the operation, and the expression operator as the type being used in the lookup. Following this, selectors for the data and the operation were defined. ~number?~ and ~variable?~ cannot be moved to the data-driven dispatch because we are dispatching with algebraic expressions as the type. ~variable~ and ~nubmer~ in this representation do not have operators, therefore, lookup cannot occur.
*** Part b
Writing an implementation for the sum and product implementation of ~deriv~, we must first setup our test script. We could just reuse a testing script from the ~deriv~ exercises.


#+caption: Test for old version of the ~deriv~ procedure for regression testing.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-old-dispatch>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))

With this value here, we could get to implementing the data-driven dispatch version of the ~deriv~ procedure.

#+name: 2.73-data-driven-sum
#+begin_src racket :exports code
(define (install-data-driven-sum)
  (define (deriv-sum operand var)
    (make-sum (deriv (car operand) var)
              (deriv (cadr operand) var)))
  (put 'deriv '+ deriv-sum))
#+end_src

#+name: 2.73-data-driven-product
#+begin_src racket :exports code
(define (install-data-driven-product)
  (define (deriv-product operand var)
    (make-sum (make-product (car operand) (deriv (cadr operand) var))
              (make-product (deriv (car operand) var) (cadr operand))))
  (put 'deriv '* deriv-product))
#+end_src

Awkward thing we found here is that the racket implementation of ~sicp~ is missing the ~put~ and ~get~ procedure, therefore, we must implement this ourselves.
#+caption: With help from the stack overflow answer provided here: https://stackoverflow.com/questions/5499005/how-do-i-get-the-functions-put-and-get-in-sicp-scheme-exercise-2-78-and-on.
#+name: put-get-implementation
#+begin_src racket :exports code
(define *op-table* '())

(define (make-entry k v) (list k v))
(define (key entry) (car entry))
(define (value entry) (cadr entry))
;; Checks if the entry of the table has a matching parameter key
(define (key? k entry)
  (equal? (key entry) k))

(define (put op type item)
  (define (putter k array)
    (cond [(null? array) (list (make-entry k item))]
          [(key? k (car array)) array]
          [else (cons (car array) (putter k (cdr array)))]))
  (set! *op-table* (putter (list op type) *op-table*)))

(define (get op type)
  (define (getter k array)
    (cond [(null? array) #f]
          [(key? k (car array)) (value (car array))]
          [else (getter k (cdr array))]))
  (getter (list op type) *op-table*))

#+end_src

#+RESULTS: put-get-implementation

#+caption: Test for data-driven version of the ~deriv~ procedure
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-data-driven>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<put-get-implementation>>
<<2.73-data-driven-sum>>
<<2.73-data-driven-product>>

(install-data-driven-sum)
(install-data-driven-product)

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))

This is the expected result, but with one caveat. We had to stop using the selectors for the operands in the old implementation, as those selectors are working with the assumption that there is an operator at the front of the expression. The new interface does not have that.
*** Part c
Add the rule back in.

Using data-driven dispatch, this should be easy to do.

#+name: 2.73-data-driven-exponentiation
#+begin_src racket :exports code
(define (install-data-driven-exponentiation)
  (define (deriv-exponentiation operand var)
    (make-product (cadr operand) (make-exponentiation (car operand) (- (cadr operand) 1))))
  (put 'deriv '** deriv-exponentiation))
#+end_src

#+caption: Test for data-driven version of the ~deriv~ procedure with exponentiation.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-data-driven>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<deriv-base-exponentiation>>
<<put-get-implementation>>
<<2.73-data-driven-sum>>
<<2.73-data-driven-product>>
<<2.73-data-driven-exponentiation>>

(install-data-driven-sum)
(install-data-driven-product)
(install-data-driven-exponentiation)

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
(deriv '(+ (* x y) (** x 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))

Result came out as expected.
*** Part d
Suppose that we swapped the op and the type, so that the operation is now the operator in the expression and the type is ~'deriv~. What are the changes that are required?

Well, we are now trying to implement ~'deriv~ for the different operations that could be described in an expression. The schema of the table will change, and both the installation and the retrieval of the procedure would change, but otherwise, ~deriv~ itself stays relatively the same. What we could do here is just implement this, and test it.

#+caption: swapped data-driven implementation of deriv
#+name: 2.73-data-driven-swapped
#+begin_src racket :exports code
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [else ((get (operator exp) 'deriv) (operand exp) var)]))

(define (operator exp)
  (car exp))
(define (operand exp)
  (cdr exp))
#+end_src

#+name: 2.73-data-driven-sum-swapped
#+begin_src racket :exports code
(define (install-data-driven-sum)
  (define (deriv-sum operand var)
    (make-sum (deriv (car operand) var)
              (deriv (cadr operand) var)))
  (put '+ 'deriv deriv-sum))
#+end_src

#+name: 2.73-data-driven-product-swapped
#+begin_src racket :exports code
(define (install-data-driven-product)
  (define (deriv-product operand var)
    (make-sum (make-product (car operand) (deriv (cadr operand) var))
              (make-product (deriv (car operand) var) (cadr operand))))
  (put '* 'deriv deriv-product))
#+end_src

#+name: 2.73-data-driven-exponentiation-swapped
#+begin_src racket :exports code
(define (install-data-driven-exponentiation)
  (define (deriv-exponentiation operand var)
    (make-product (cadr operand) (make-exponentiation (car operand) (- (cadr operand) 1))))
  (put '** 'deriv deriv-exponentiation))
#+end_src

#+caption: Test for swapped operator and type for data-driven version of the ~deriv~ procedure.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-data-driven-swapped>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<deriv-base-exponentiation>>
<<put-get-implementation>>
<<2.73-data-driven-sum-swapped>>
<<2.73-data-driven-product-swapped>>
<<2.73-data-driven-exponentiation-swapped>>

(install-data-driven-sum)
(install-data-driven-product)
(install-data-driven-exponentiation)

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
(deriv '(+ (* x y) (** x 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))

And just like that, we are done the exercise.
* Exercise 2.74
** Prompt
We are larping as a software engineer for a company that used to have multiple distributed independent divisions, all having software infrastructure that was not standardized. We are responsible for making an interface that would allow a access to those different systems without changing those systems.
a. Implement for headquarters a ~get-record~ procedure that retrieves a specified employee's record from a specified personnel file. The procedure should be applicable to any division's file. Explain how the individual divisions' file should be structured. In particular, what type information must be supplied?
b. Implement for headquarters a ~get-salary~ procedure that returns the salary information from a given employee's record from any division's personnel file. How should the record be structured in order to make this operation work?
c. Implement for HQ a ~find-employee-record~ procedure. This should search all division files for the record of a given employee and return the record. Assume that this procedure takes as arguments an employee's name and a list of all the divisions' file.
d. When Insatiable takes over a new company, what changes must be made in order to incorporate the new personnel information into the central system?
** Solution
Let's talk a little about our requirements. Firstly, we are trying to integrate multiple systems that tries to do the same thing. Firstly, each of these systems should have selectors and constructors. Reading the requirements, the central system is mostly trying to read the content of each of the systems. There are also some similarities in how the data is stored. We know that the entries are stored as a record of records, meaning that for most of the exercise, we are trying to select and check for containment generically.
*** Part a
Parameters for this procedure are the name of the employee, and a record file. Here is what we will do to make this work.
1. We are injecting the datastructure, and this is the thing that is different between the teams
2. We assume that each of the teams have built their own querying system

We could use data-driven dispatch to be able to generically operate on the different record types that are used by the different teams.

Since we don't really have data to test with, nor do I really want to put the time to do that, we'll just pretend that the code I am writing has some underlying representation written up by someone else. The generic procedure is provided below.

#+begin_src racket :exports code
(define (attach-type type value)
  (cons type value))
(define (type-tag item)
  (car item))
(define (contents item)
  (cdr item))
#+end_src

#+name: generic-apply
#+begin_src racket :exports code
(define (generic-apply op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (error "could not find the item for the following op and type" (list op type-tag))))))
#+end_src

#+begin_src racket :exports code
(define (get-record record-store name)
  (generic-apply 'get-record record-store name))
#+end_src

Each of the team just has to make an install procedure that contains the implementation of retrieving the record with the parameterized name. For the sake of correctness, this procedure should also return ~#f~ as the option value for when the search failed. If the search does not fail, then the returned record should be tagged by the implementer of the type.

Finally, the record file should specify what team format it uses, so that we could use data-driven dispatch to find the correct procedure.
*** Part b
Implementing the ~get-salary~ procedure that takes the employee record as parameter.

#+begin_src racket :exports code
;; This procedure is using data-driven dispatch to find the correct selector
;; procedure
(define (get-salary emp-record)
  (generic-apply 'get-salary emp-record))
#+end_src

So basically, we have written another generic procedure. What really matters here is that the employee record being passed into the procedure is tagged with a type, (the team that the record format belongs to). Finally, the selector procedure that is installed should tag the return salary information.
*** Part c
Making a list of record looking actually does not involve making the teams implement a new selector. Instead, we could leverage the procedure that was designed in part a.

Luckily for us, we made the interface for the ~get-record~ method return ~#f~ if the name could not be found in the record, so now, we just make the procedure traverse all the records, and do a data-driven dispatch for the ~get-record~ operation. If the record returns a negative, we continue looking. If there are no more records, we return ~#f~ as the sentinel value, and if we find the record, we return the record.

#+begin_src racket :exports code
(define (find-employee-record name . records)
  (if (null? records)
      #f
      (let ([curr-record (car records)])
        (let ([res (get-record curr-record name)])
          (if (not res)
              (apply find-employee-record (cons name (cdr records)))
              res)))))
#+end_src
*** Part d
Once a new company is being purchased, and we must integrate their system into the central system, we have to do the following changes on their side.

The new company must implement the ~get-record~ procedure, and the ~get-salary~ procedure, following the interface that we have defined, which includes the ~#f~ return and tagging the record value that was returned from ~get-record~. They must pick a unique type name for their team, and then tag their record data with this name. Then, they must make an install script that will register their version of ~get-record~ and ~get-salary~ into the data-driven table.

This should be enough to integrate a new team into the central system.
