#+title: Chapter 2
#+author: Bach
* Snippets
#+name: assertion-suite
#+begin_src racket :exports code
(define (assert-predicate pred-fn test-name value expected)
  (display (if (pred-fn value expected) "pass: " "fail: "))
  (display test-name)
  (display " value: ")
  (display value)
  (display " expected: ")
  (display expected)
  (newline))

(define (assert-eq test-name value expected)
  (assert-predicate equal? test-name value expected))
(define (assert-almost-eq test-name value expected)
  (define dx 0.0001)
  (define (almost-eq? left right)
    (< (abs (- left right)) dx))
  (assert-predicate almost-eq? test-name value expected))
#+end_src
* Exercise 2.1
Make an improved ~make-rat~ that will normalize the signage of the rational number.
#+begin_src racket :exports code
#lang sicp
(define (make-rat n d)
  (define (neg? nu de)
    (or (and (> nu 0) (< de 0)) (and (< nu 0) (> de 0))))
  (define (make-rat-aux nu de)
    (let ([g (gcd nu de)]) (cons (/ nu g) (/ de g))))
  (if (neg? n d)
      (make-rat-aux (- 0 (abs n)) (abs d))
      (make-rat-aux (abs n) (abs d))))

(make-rat -4 -12)
(make-rat 4 -12)
(make-rat -4 12)
(make-rat 4 12)
#+end_src

#+RESULTS:
: (1 . 3)
: (-1 . 3)
: (-1 . 3)
: (1 . 3)

* Exercise 2.2
Design a segment, a concept where two points make up a segment. While at it, also design points, a pair of numbers. Here are the required interface:

For segment:
- Constructor
  - ~make-segment~
- Selector
  - ~start-segment~
  - ~end-segment~

For points:
- Constructor
  - ~make-point~
- Selector
  - ~x-point~
  - ~y-point~

Domain procedure:
- ~midpoint-segment~

We're provided with a print function

#+name: exercise-2.2
#+begin_src racket :exports code
;; Point printing
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
;; Point interface
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))

;; Segment interface
;; make-segment is the segment constructor that takes in a start point and an
;; end point as parameters
(define (make-segment start end)
  (cons start end))
;; start-segment takes a segment as a parameter and returns the start of the
;; segment
(define (start-segment s)
  (car s))
;; end-segment takes in a segment as parameter and returns the end point of the
;; segment
(define (end-segment s)
  (cdr s))

;; midpoint-segment takes in a segment and returns the point that represents the
;; midpoint of that segment
(define (midpoint-segment s)
  (define (average a b)
    (/ (+ a b) 2))
  (let ([start (start-segment s)]
        [end (end-segment s)])
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))
#+end_src

Testing the written values now

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<exercise-2.2>>

;; Integration test
(define test-segment-1 (make-segment (make-point -1 -2) (make-point 3 4)))
(define test-mp-1 (midpoint-segment test-segment-1))
(print-point test-mp-1)
(assert-eq "test-mp-1-x=1" (x-point test-mp-1) 1)
(assert-eq "test-mp-1-y=1" (y-point test-mp-1) 1)
#+end_src

#+RESULTS:
:
: (1,1)
: pass: test-mp-1-x=1 value: 1 expected: 1
: pass: test-mp-1-y=1 value: 1 expected: 1
* Exercise 2.3
Implement a rectangle in a plane. Write a procedure that calculates the perimeter and area of the rectangle. Then implement a different representation for a rectangle. The goal of the exercise is to abstract properly such that the perimeter and area method does not need to change.

Assuming that we are designing this datastructure to follow the rules of a two dimensional rectangle, and that we really only care about the perimeter and the area of the rectange, we really just need to be able to retrieve the height and width of the rectangle. This will be our selectors. As for conforming to the rule of the rectangle, we could make the constructor always take in less parameters, and generate the other values to follow the rules of the rectangle.

#+name: rectangle-functions
#+begin_src racket :exports code
;; We are building the rectangle for this exercise such that the interface is
;; height and width
(define (area rectangle)
  (* (width rectangle) (height rectangle)))
(define (perimeter rectangle)
  (+ (* 2 (height rectangle)) (* 2 (width rectangle))))
#+end_src

#+RESULTS: rectangle-functions

** Implementation 1
We're not doing anything fancy in this first version. Constructor will take in bottom left corner and top right corner of the rectangle, and we will use that to represent a retangular object that has it's sides parallel to the two axis of the plane. Our selectors will just be for height and length.


#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
;; Takes two points as arguments. bottom-left is the bottom left point of a
;; rectange that is parallel to the plane axis. top-right is the top right
;; point of the same rectangle
(define (make-rectangle bottom-left top-right)
  (cons bottom-left top-right))
(define (width rectangle)
  (let ([left (x-point (car rectangle))]
        [right (x-point (cdr rectangle))])
    (abs (- left right))))
(define (height rectangle)
  (let ([top (y-point (cdr rectangle))]
        [bottom (y-point (car rectangle))])
    (abs (- top bottom))))

(assert-eq "area of (0,0) (2,2) is 4" (area (make-rectangle (make-point 0 0) (make-point 2 2))) 4)
(assert-eq "perimiter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-point -1 -1) (make-point 1 1)))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimiter of (-1, -1) (1, 1) is 8 value: 8 expected: 8
** Implementation 2
Let's allow orientation. This second version takes a segment representing the base of the rectangle and an integer representing the height of the rectangle

#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
;; Takes a segment representing the base and the height as arguments
(define (make-rectangle base height)
  (cons base height))
(define (width rectangle)
  (define (position-vector segment)
    (make-segment (make-point 0 0)
                  (make-point (- (x-point (end-segment segment)) (x-point (start-segment segment)))
                              (- (y-point (end-segment segment)) (y-point (start-segment segment))))))
  (define (square x)
    (* x x))
  (define (mag x y)
    (sqrt (+ (square x) (square y))))
  (let ([pos-tip (end-segment (position-vector (car rectangle)))])
    (mag (x-point pos-tip) (y-point pos-tip))))
(define (height rectangle)
  (cdr rectangle))

(assert-eq "area of (0,0) (2,2) is 4"
           (area (make-rectangle (make-segment (make-point 0 0) (make-point 0 2)) 2))
           4)
(assert-eq "perimeter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-segment (make-point -1 -1) (make-point 1 -1)) 2))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimeter of (-1, -1) (1, 1) is 8 value: 8 expected: 8


We can see that this second implementation is importing the same rectangle functions ~area~ and ~perimeter~, and we were able to achieve the same result.
* Exercise 2.4

With the new implementation of ~cons~ and ~car~ below, implement ~cdr~.

#+name: cons-override-1
#+begin_src racket :exports code
;; Makes a lambda that accepts a procedure and applies it on both members of
;; the pairs
(define (cons x y)
  (lambda (m) (m x y)))

;; Feeds a procedure that returns the first parameter
(define (car z)
  (z (lambda (p q) p)))

;; Our implementation just needs to return the second parameter
(define (cdr z)
  (z (lambda (p q) q)))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
<<cons-override-1>>
;; Takes two points as arguments. bottom-left is the bottom left point of a
;; rectange that is parallel to the plane axis. top-right is the top right
;; point of the same rectangle
(define (make-rectangle bottom-left top-right)
  (cons bottom-left top-right))
(define (width rectangle)
  (let ([left (x-point (car rectangle))]
        [right (x-point (cdr rectangle))])
    (abs (- left right))))
(define (height rectangle)
  (let ([top (y-point (cdr rectangle))]
        [bottom (y-point (car rectangle))])
    (abs (- top bottom))))

(assert-eq "area of (0,0) (2,2) is 4" (area (make-rectangle (make-point 0 0) (make-point 2 2))) 4)
(assert-eq "perimiter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-point -1 -1) (make-point 1 1)))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimiter of (-1, -1) (1, 1) is 8 value: 8 expected: 8

* Exercise 2.5
** Prompt
Show how we can hold a pair of non-negative integers using just numbers and arithmetic operations if we represent the pair ~a~ and ~b~ as \(2^{a}3^{b}\). Make the constructor and two selectors.
** Solution
2 and 3 have non-colliding powers. We could get ~a~ just by diving the representation by 2 until the remainder is no longer 0 and count the number of applications required to get there. As for the second element, we could do the same thing as the first element, but using 3 is the target value. This just means that we need to allow the accumulation procedure to take a mod parameter.

#+name: power-integer-pairs
#+begin_src racket :exports code
(define (pcons a b)
  (* (expt 2 a) (expt 3 b)))

;; We should move to using an iterative process instead of a recursive process
;; We should do the optimization using the sqaure property.
(define (count-div base val)
  (define (iter v acc)
    (if (= (remainder v base) 0)
        (iter (/ v base) (+ acc 1))
        acc))
  (iter val 0))

(define (pcar x)
  (count-div 2 x))
(define (pcdr x)
  (count-div 3 x))
#+end_src



#+begin_src racket :exports both :noweb yes
#lang sicp
<<power-integer-pairs>>
<<assertion-suite>>

(assert-eq "pcar (2, 4) = 2" (pcar (pcons 2 4)) 2)
(assert-eq "pcdr (2, 4) = 4" (pcdr (pcons 2 4)) 4)
#+end_src

#+RESULTS:
:
: pass: pcar (2, 4) = 2 value: 2 expected: 2
: pass: pcdr (2, 4) = 4 value: 4 expected: 4
* Exercise 2.6
We're doing Church encoding, but instead of the lamda calculus representation, it is scheme. I think this is one of the few cases where scheme is less readable. Luckily, this question only ask that we show the representation of one, two, and the actual definition of the addition procedure.

#+begin_src racket :exports code
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

Let's find one using ~add-1~ on ~zero~.

#+begin_src racket :exports code
(add-1 zero)
(add-1 (lambda (f) (lambda (x) x)))
(lambda (f) (lambda (x) (f ((lambda (f) (lambda (x) x))) f) x))
(lambda (f) (lambda (x) (f ((lambda (x) x) x) )))
(lambda (f) (lambda (x) (f x)))

(define one (lambda (f) (lambda (x) (f x))))
#+end_src

From doing this, we see that ~one~ is represented as a function that takes in a function ~f~ and create a new function that applies ~f~ once on the parameter.

#+begin_src racket :exports code
(add-1 one)
(add-1 (lambda (f) (lambda (x) (f x))))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (f (f x))))

(define two (lambda (f) (lambda (x) (f (f x)))))
#+end_src

Encoding for two is a higher order procedure that takes in a procedure ~f~ and produces a procedure that applies ~f~ twice on a parameter.

We can continue this line of reasoning to say that Church encoding of a non-negative integer ~n~ is a higher order procedure that takes in a procedure ~f~ and produces a procedure that applies ~f~ ~n~ times. Now to define addition in Scheme.

#+begin_src racket :exports code
(define (add a b)
  (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+end_src

To prove that this addition procedure works, we'll evaluate this with ~a~ as ~one~ and ~b~ as ~two~, and we should see that it evaluates to ~(lambda (f) (lambda (x) (f (f (f x)))))~.

#+begin_src racket :exports code
(add one two)
(add (lambda (f) (lambda (x) (f x))) (lambda (f) (lambda (x) (f (f x)))))
(lambda (f)
  (lambda (x) (((lambda (f) (lambda (x) (f x))) f) (((lambda (f) (lambda (x) (f (f x)))) f) x))))
(lambda (f) (lambda (x) ((lambda (x) (f x)) ((lambda (x) (f (f x))) x))))
(lambda (f) (lambda (x) ((lambda (x) (f x)) (f (f x)))))
(lambda (f) (lambda (x) (f (f (f x)))))
#+end_src

And as we expected, adding one and two gets us three.
* Exercise 2.7
Implement Alyssa P. Hacker's datastructure for interval operations.

#+name: interval-data-struct
#+begin_src racket :exports code
(define (make-interval a b) (cons a b))
(define (upper-bound z)
  (max (car z) (cdr z)))
(define (lower-bound z)
  (min (car z) (cdr z)))
#+end_src
* Exercise 2.8
** Prompt
Make a subtraction analogous for the interval datastructure.
** Solution
#+name: exercise-2.8
#+begin_src racket :exports code
(define (sub-interval a b)
  (make-interval (- (upper-bound a) (lower-bound b))
                 (- (lower-bound a) (upper-bound b))))
(define (add-interval a b)
  (make-interval (+ (upper-bound a) (upper-bound b))
                 (+ (lower-bound a) (lower-bound b))))

#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<interval-data-struct>>
<<exercise-2.8>>

(assert-eq "upper bound of [-2, 2] - [-8, 4] is 10"
           (upper-bound (sub-interval (make-interval 2 -2) (make-interval 4 -8)))
           10)
(assert-eq "upper bound of [-8, 4] - [-2, 2] is 6"
           (upper-bound (sub-interval (make-interval 4 -8) (make-interval 2 -2)))
           6)
#+end_src

#+RESULTS:
:
: pass: upper bound of [-2, 2] - [-8, 4] is 10 value: 10 expected: 10
: pass: upper bound of [-8, 4] - [-2, 2] is 6 value: 6 expected: 6
* Exercise 2.9
** Prompt
The width of an interval is half the difference of the upper and lower bound. For some arithmetic functions, the width of combining two variables is a function of only the width of the argument intervals while for some other arithmetic operations, this is not the case.

Show that for addition, the sum's interval is a function of only the widths of the argument intervals. After showing this, show that this is not the case for multiplication or division.
** Solution
Let's have a look at an example problem using addition.

\[\begin{aligned}
\text{let}~w = f_{w}(i) = \frac{u - l}{2},~ \text{where}~[l, u] = i \\
i_{3} = i_{1} + i_{2} = [l_{1} + l_{2}, u_{1} + u_{2} ] = [l_{3}, u_{3}] ~ \text{where}~ l_{3} = l_{1} + l_{2}, u_{3} = u_{1} + u_{2} \\
  \text{We will show that } w_{3} = w_{1} + w_{2} = f_{w}(i_{3}) \\
  f_{w}(i_{3}) = \frac{l_{3} + u_{3}}{2} = \frac{(l_{1} + u_{1}) + (l_{2} + u_{2}) }{2} \\
  \text{Knowing that}~ w_{1} = \frac{l_{1} + u_{1}}{2}, w_{2} = \frac{l_{2} + u_{2}}{2} \\
  f_{w}(i_{3}) = w_{1} + w_{2}
\end{aligned}\]

Now we will show that this is not the case for multiplication.

\[\begin{aligned}
		\text{We just need to show one case where the result width is not a function of the input width} \\
		i_{1} = \left[ 8, 10 \right], i_{2} = \left[ 2, 5 \right]                                        \\
		w_{1} = 1, w_{2} = 1.5; w_{1} \times w_{2} = 1.5                                                 \\
		i_{3} = i_{1} * i_{2} = \left[ 16, 50 \right]                                                    \\
		w_{3} = 17 != w_{1} \times w_{2}
	\end{aligned}\]

Did not think that it was necessary to show the same property for division since division is just a multiplication against a reciprocal.
* Exercise 2.10
** Prompt
Thanks to Ben Bitdiddle, we realize that we should be treating a division against an interval that spans zero as an error. Modify the procedure the Alyssa P. Hacker wrote to do this error handling.
** Solution
#+name: alyssa-multiplication
#+begin_src racket :exports code
(define (mul-interval x y)
  (let ([p1 (* (lower-bound x) (lower-bound y))]
        [p2 (* (lower-bound x) (upper-bound y))]
        [p3 (* (upper-bound x) (lower-bound y))]
        [p4 (* (upper-bound x) (upper-bound y))])
    (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4))))
#+end_src

#+name: exercise-2.10
#+begin_src racket :exports code
(define (div-interval x y)
  (define (zero-interval? a)
    (and (< (lower-bound a) 0) (> (upper-bound a) 0)))
  (let ([reciprocal-y (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))])
    (if (zero-interval? reciprocal-y)
        (error "cannot divide by zero")
        (mul-interval x reciprocal-y))))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<interval-data-struct>>
<<alyssa-multiplication>>
<<exercise-2.10>>

(assert-almost-eq "lower [8, 10] / [2, 4] is 2" (lower-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 2.0)
(assert-almost-eq "upper [8, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 5.0)

;; The following line should throw an error
(div-interval (make-interval 8 9) (make-interval -1 0.1))
#+end_src

#+RESULTS:
:
: pass: lower [8, 10] / [2, 4] is 2 value: 2.0 expected: 2.0
: pass: upper [8, 10] / [2, 4] is 5 value: 5.0 expected: 5.0

We see that the procedure will operate normally when not dividing by zero, and thrown an error if it does divide by an interval that covers zero.
* Exercise 2.11
** Prompt
We can make the ~mul-interval~ procedure use less multiplication operations by breaking it down into 9 cases. Only one of these cases will require more than two multiplication. Implementate this improved version of ~mul-interval~.

** Solution
#+name: exercise-2.11
#+begin_src racket :exports code
(define (mul-interval x y)
  (let ([a (lower-bound x)]
        [b (upper-bound x)]
        [c (lower-bound y)]
        [d (upper-bound y)])
    (cond
      [(and (>= a 0) (>= b 0) (>= c 0) (>= d 0)) (make-interval (* a c) (* b d))]
      [(and (< a 0) (>= b 0) (>= c 0) (>= d 0)) (make-interval (* a d) (* b d))]
      [(and (>= a 0) (>= b 0) (< c 0) (>= d 0)) (make-interval (* c b) (* b d))]
      [(and (< a 0) (< b 0) (>= c 0) (>= d 0)) (make-interval (* a d) (* b c))]
      [(and (>= a 0) (>= b 0) (< c 0) (< d 0)) (make-interval (* b c) (* a d))]
      [(and (< a 0) (>= b 0) (< c 0) (>= d 0))
       (make-interval (min (* a d) (* c b)) (max (* a c) (* b d)))]
      [(and (< a 0) (>= b 0) (< c 0) (< d 0)) (make-interval (* b c) (* a c))]
      [(and (< a 0) (< b 0) (< c 0) (>= d 0)) (make-interval (* a d) (* a c))]
      [(and (< a 0) (< b 0) (< c 0) (< d 0)) (make-interval (* b d) (* a c))])))
#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<exercise-2.11>>
<<assertion-suite>>
<<interval-data-struct>>
<<exercise-2.10>>

(assert-almost-eq "lower [8, 10] / [2, 4] is 2" (lower-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 2.0)
(assert-almost-eq "upper [8, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 5.0)
(assert-almost-eq "lower [-10, 10] / [2, 4] is -5" (lower-bound (div-interval (make-interval -10 10) (make-interval 2 4))) -5)
(assert-almost-eq "upper [-10, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval -10 10) (make-interval 2 4))) 5)
(assert-almost-eq "lower [-10, 10] * [-20, 14] is -200" (lower-bound (mul-interval (make-interval -10 10) (make-interval -20 14))) -200)
(assert-almost-eq "upper [-10, 10] * [-20, 14] is 200" (upper-bound (mul-interval (make-interval -10 10) (make-interval -20 14))) 200)

;; The following line should throw an error
(div-interval (make-interval 8 9) (make-interval -1 0.1))
#+end_src

#+RESULTS:
:
: pass: lower [8, 10] / [2, 4] is 2 value: 2.0 expected: 2.0
: pass: upper [8, 10] / [2, 4] is 5 value: 5.0 expected: 5.0
: pass: lower [-10, 10] / [2, 4] is -5 value: -5.0 expected: -5
: pass: upper [-10, 10] / [2, 4] is 5 value: 5.0 expected: 5
: pass: lower [-10, 10] * [-20, 14] is -200 value: -200 expected: -200
: pass: upper [-10, 10] * [-20, 14] is 200 value: 200 expected: 200
* Exercise 2.12
** Prompt
Alyssa made an alternate constructor and selectors that represents the following \(c \pm w\). Now make a version that does percentage tolerance in the following form. \(c \pm p \%\). Also provide the percent selector.
** Solution
#+name: center-width-rep
#+begin_src racket :exports code
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (center x)
  (/ (+ (upper-bound x) (lower-bound x)) 2))
(define (width x)
  (/ (- (upper-bound x) (lower-bound x)) 2))
#+end_src

#+name: exercise-2.12
#+begin_src racket :exports code
(define (percent i)
  (* 100 (/ (width i) (abs (center i)))))

(define (make-center-percent c p)
  (let ([width (* (abs c) (/ p 100))]) (make-center-width c width)))
#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<interval-data-struct>>
<<center-width-rep>>
<<exercise-2.12>>
<<assertion-suite>>

(assert-eq "construct and then assert" (percent (make-center-percent 10 10)) 10)
#+end_src

#+RESULTS:
:
: pass: construct and then assert value: 10 expected: 10
* Exercise 2.13
** Prompt
Show that under small percentage tolerance, there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors.
** Solution
By working on exercise 2.14, we know exactly what this approximation is. At small percentage, the percentage tolerance of the product is equal to the sum of the percentage tolerance of the operands. At larger values, this breaks down.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<interval-data-struct>>
<<center-width-rep>>
<<exercise-2.12>>
<<exercise-2.11>>
<<exercise-2.10>>
<<exercise-2.8>>
<<assertion-suite>>
(define a (make-center-percent 80 0.5))
(define b (make-center-percent 210 0.8))

(assert-almost-eq "the percentage tolerance of a * b should be very close to percent tolerance a + percent tolerance b" (percent (mul-interval a b)) (+ (percent a) (percent b)))
#+end_src

#+RESULTS:
:
: pass: the percentage tolerance of a * b should be very close to percent tolerance a + percent tolerance b value: 1.2999480020799254 expected: 1.3000000000000105

* Exercise 2.14
** Prompt
The previous implementation of interval was flawed in that it was unable to give the same answer in two equivalent but different equation for the parallel resistor. Run some experiment and investigate why this issue is occurring.
** Investigation
#+begin_src racket :exports code
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2) (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ([one (make-interval 1 1)])
    (div-interva
#+end_src
*** Experiments
#+begin_src racket :exports both :noweb yes
#lang sicp
<<interval-data-struct>>
<<center-width-rep>>
<<exercise-2.12>>
<<exercise-2.11>>
<<exercise-2.10>>
<<exercise-2.8>>
(define a (make-center-percent 80 0.5))
(define b (make-center-percent 210 0.8))
(define a-prime (make-center-percent 80 40))
(define b-prime (make-center-percent 210 60))
(define c (make-center-percent 80 0.7))

(center (div-interval a a))
(percent (div-interval a a))
(center (div-interval a b))
(percent (div-interval a b))
(newline)
(display "210 +- 8% / 80 +- 5%")
(newline)
(center (div-interval a-prime b-prime))
(percent (div-interval a-prime b-prime))

(center (div-interval b a))
(percent (div-interval b a))
(center (div-interval c c))
(percent (div-interval c c))
(center (add-interval c c))
(percent (add-interval c c))
(center (add-interval c a))
(percent (add-interval c a))
(center (add-interval b a))
(percent (add-interval b a))
(center (sub-interval b a))
(percent (sub-interval b a))
(newline)
(display "210 +- 0.8% - 80 +- 0.7%")
(newline)
(center (sub-interval b c))
(percent (sub-interval b c))
(center (mul-interval c c))
(percent (mul-interval c c))
#+end_src

#+RESULTS:
#+begin_example
1.000050001250031
0.9999750006249956
0.38099200253578136
1.2999480020799312

210 +- 8% / 80 +- 5%
0.738095238095238
80.64516129032259
2.6251706292657317
1.299948002079925
1.0000980048022352
1.3999314033612358
160.0
0.7000000000000028
160.0
0.600000000000005
290.0
0.7172413793103589
130.0
1.6000000000000099

210 +- 0.8% - 80 +- 0.7%
130.0
1.7230769230769298
6400.3136
1.399931403361241
#+end_example

Interesting. In the previous implementation of the interval class, addition will cause the sum's percent to be the weighted average of the two operands. Multiplication and division will cause the product and quotient to have a percent tolerance that is the sum of the operands. Subtraction will see the tolerance increase due to multiple factors.
* Exercise 2.15
** Prompt
Eva Lu Ator says that since different intervals are calculated when using different but algebraically equivalent expressions. Eva then claims that using forms that do not repeat the same uncertain variable would produce a tighter output uncertainty, and that therefore, this is the better method. Is she correct? Why?
** Solution
Problem was that the implementation is not consistent between different equivalent algebraic problems. There should not be a better method, but Eva is correct, using this implementation, we should operate on the unique variables with uncertainty once. Specifically, what seems to be happening is that repeated operations seem to assume that there are more than one uncertain variables.
* Exercise 2.16
** Prompt
Explain why different equivalent algebraic expressions will result in different result interval. Can we devise a package that can solve this problem? Given with warning that this is a difficult task.
** Solution
I will not be attempting to build my own library for intervals, as I have things to be and placed to do. As stated in the 2.15 solution, if the same interval object is used in multiple placed, it eventually propagates its uncertainty back on itself as if they are not the same value. I am choosing to not continue to dwell on this topic, as I have places to do, and things to be.
* Exercise 2.17
** Prompt
Implement a procedure called ~last-pair~ that will return the last element of a list.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (last-pair items)
  (cond ((null? items) items)
        ((null? (cdr items)) (car items))
        (else (last-pair (cdr items)))))
(last-pair (list 1 2 43 5 12 90 58))
#+end_src

#+RESULTS:
: 58
* Exercise 2.18
** Prompt
Define reverse that will reverse a list
** Solution
Will be solving this problem using an iterative process
#+begin_src racket :exports both
#lang sicp
(define (reverse items)
  (define (iter acc nav)
    (if (null? nav)
        acc
        (iter (cons (car nav) acc) (cdr nav))))
  (iter nil items)
  )

(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)
* Exercise 2.19
** Prompt
Upgrade change counting algorithm to take the coin value as parameter as well.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (cc amount coin-values)
  (define (except-first-denomination items)
    (cdr items))
  (define (first-denomination items)
    (car items))
  (define (no-more? items)
    (null? items))
  (cond
    [(= amount 0) 1]
    [(or (< amount 0) (no-more? coin-values)) 0]
    [else
     (+ (cc amount (except-first-denomination coin-values))
        (cc (- amount (first-denomination coin-values)) coin-values))]))

(define us-coin (list 25 10 50 5 1))
(define uk-coin (list 100 50 20 10 5 2 1 0.5))

(cc 100 us-coin)
#+end_src

#+RESULTS:
: 292

Here is the learning from doing this exercise. Yes we could have just done the low level list access procedures in the cc procedure, but by defining these external access methods, we are abstracting out the lower level implementation. It is up to us to think about whether our data structure would need an abstraction layer or not.

This is a combination problem, the order of the elements in the list do not matter. If this is incorrect, and you are looking at my github, please create an issue to address this.
* Exercise 2.20
** Prompt
We can see that there are procedures in scheme that can take in a dynamic number of arguments. Well, we're going to learn how to do that here.

We can achieve this by using ~define~ with a /dotted-tail/ notation.

#+begin_src racket :exports code
(define (f a b c . z) (<body>))
(define (g . x) (<body>))
#+end_src

Semantically, this is the same as doing the following in Python. Excuse me for not just explaining it in plain English.

#+begin_src python :exports code
def f(a, b, c, *z):
    ...

def g(*x):
    ...
#+end_src

Now build a procedure called same parity that takes in a dynamic number of input and then only return the content of the input that matches the parity of the input.

** Solution
#+begin_src racket :exports both
#lang sicp
(define (same-parity x . y)
  (define (choose-predicate a)
    (if (even? a) even? odd?))
  ;; I suppose that I really just made filter. Whoops.
  (define (choose predicate items)
    (cond ((null? items) nil)
          ((predicate (car items))
           (cons (car items) (choose predicate (cdr items))))
          (else (choose predicate (cdr items)))))
  (choose (choose-predicate x) (cons x y)))

(same-parity 1 2 3 4 5 6 7)
(same-parity 2 3 4 5 6 7)
#+end_src

#+RESULTS:
: (1 3 5 7)
: (2 4 6)
* Exercise 2.21
** Prompt
Make the two implementation of ~square-list~ that will take a list of numbers and return a list of the square of those numbers.
** Solution
*** First solution
First implementation without using ~map~.
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
(define (square-list items)
  (if (null? items)
      nil
      (cons (square (car items)) (square-list (cdr items)))))
(square-list (list 1 2 3 4))
#+end_src

#+RESULTS:
: (1 4 9 16)
*** Map solution
Yes, the map solution is cleaner, why wouldn't it be?
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
(define (square-list items)
  (map square items))
(square-list (list 1 2 3 4))
#+end_src

#+RESULTS:
: (1 4 9 16)
* Exercise 2.22
** Prompt
Louis Reasoner tried to make the ~square-list~ function and his implementation produces a list in reverse order. Why is this the case? Then he made a second version of the code that does not work. Listings available below.
#+caption: Reversed list output
#+begin_src racket :exports code
#lang sicp
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
#+end_src

#+caption: Just does not work
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things) (cons answer (square (car things))))))
  (iter items nil))

(square-list (list 1 2 3 4))
#+end_src

#+RESULTS:
: ((((() . 1) . 4) . 9) . 16)

** Solution
The first listing is reversed because our Scheme list implementation only allows for appending from one direction. This means the iterative algorithms that builds a list as it is traversing another one will build a reversed list.

The second listing does not work because we are no longer following the semantics of a Scheme list. The list is being built in reverse order.
* Exercise 2.23
** Prompt
We learn what a ~for-each~ is, which is just ~map~ but no return. Good for just doing side effects. Make an implementation of ~for-each~
** Solution
We have an implementation of ~for-each~ using the ~let~ procedure.
#+begin_src racket :exports both
#lang sicp
(define (for-each f items)
  (if (not (null? items))
      (let ([app (f (car items))]) (for-each f (cdr items)))))

(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
#+end_src

#+RESULTS:
:
: 57
: 321
: 88
* Exercise 2.24
** Prompt
Show the result of ~(list 1 (list 2 (list 3 4)))~ from the interpreter, followed by the box and pointer diagram and the tree diagram of the structure.
** Solution
For the first part, I will just let the interpreter do the printing for me.

#+begin_src racket :exports both
#lang sicp
(list 1 (list 2 (list 3 4)))
#+end_src

#+RESULTS:
: (1 (2 (3 4)))

Second and third part will be done using uml.

#+caption: Box and pointer diagram of the given structure.
#+begin_src plantuml :exports results :file ./images/exercise-2.24-1.png
@startuml
rectangle p00
rectangle p01
rectangle p10
rectangle p11
rectangle p20
rectangle p21

p00 --> 1
p00 -> p01
p01 --> p10

p10 --> 2
p10 -> p11
p11 --> p20

p20 --> 3
p20 -> p21
p21 --> 4

@enduml
#+end_src

#+caption: Box and pointer diagram of the given structure.
#+RESULTS:
[[file:./images/exercise-2.24-1.png]]

Box and pointer representation does hide the fact that the hierarchical structure is built on top of the Scheme pairs.

#+caption: Tree representation of the given structure.
#+begin_src plantuml :exports results :file ./images/exercise-2.24-2.png
@startuml
rectangle "(list 1 (list 2 (list 3 4)))" as p0
rectangle "(list 2 (list 3 4))" as p1
rectangle "(list 3 4)" as p2

p0 --> 1
p0 --> p1

p1 --> 2
p1 --> p2

p2 --> 3
p2 --> 4

@enduml
#+end_src

#+caption: Tree representation of the given structure.
#+RESULTS:
[[file:./images/exercise-2.24-2.png]]

Tree representation abstracts away the implementation detail of using pairs.
* Exercise 2.25
** Prompt
Pick 7 from the following list using ~car~ and ~cdr~.
#+begin_src racket :exports code
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
#+end_src
** Solution
Here are the calls using just ~car~ and ~cdr~ to get the 7 in each of the lists.
#+begin_src racket :exports both
#lang sicp
(define first (list 1 3 (list 5 7) 9))
(define second (list (list 7)))
(define third (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))

(car (cdr (car (cdr (cdr first)))))
(car (car second))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr third))))))))))))
#+end_src

#+RESULTS:
: 7
: 7
: 7
* Exercise 2.26
** Prompt
Say what the output of the following list manipulation procedures.

#+begin_src racket :exports code
(define x (list 1 2 3))
(define y (list 4 5 6))
#+end_src

#+begin_src racket :exports code
(append x y)
(cons x y)
(list x y)
#+end_src
** Solution
I am writing what I see as the solution before evaluating these procedures using the interpreter.

#+begin_src racket :exports code
(1 2 3 4 5 6)
;; This is a pair, and I know that this is how racket displays this
((1 2 3) . (4 5 6))
((1 2 3) (4 5 6))
#+end_src

Now we can evaluate for proof.

#+begin_src racket :exports both
#lang sicp
(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y)
(cons x y)
(list x y)
#+end_src

#+RESULTS:
: (1 2 3 4 5 6)
: ((1 2 3) 4 5 6)
: ((1 2 3) (4 5 6))

Alright, I must admit that I was wrong. Here is what we can see. The second line is using ~cons~ on two list. Remembering what ~cons~ does, with respect to the abstraction of list, we know that ~cons~ actually appends to the front of the list. This is why we see ~x~ as the new first element of list ~y~.
* Exercise 2.27
** Prompt
Modify the solution to [[*Exercise 2.18][Exercise 2.18]] to make a procedure called ~deep-reverse~ that will reverse the main list, as well as the sub-lists.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (deep-reverse items)
  (define (iter acc nav)
    (cond ((null? nav) acc)
          ((pair? (car nav)) (iter (cons (deep-reverse (car nav)) acc) (cdr nav)))
          (else (iter (cons (car nav) acc) (cdr nav)))))
  (iter nil items)
  )

(deep-reverse (list 1 2 3 4))
(deep-reverse (list (list 1 2) (list 3 4)))
#+end_src

#+RESULTS:
: (4 3 2 1)
: ((4 3) (2 1))

This is working as expected.
* Exercise 2.28
** Prompt
Make a procedure called ~fringe~ that takes a tree make of list as input, and then outputs a list with all the leaves arranged from left to right order.
** Solution
We could re-frame the problem into flattening a list. Since I have done some of Cornell's cs3110, I know the spoiler of having to reverse the list if it is generated recursively.

#+begin_src racket :exports both
#lang sicp

(define (reverse items)
  (define (iter acc nav)
    (if (null? nav)
        acc
        (iter (cons (car nav) acc) (cdr nav))))
  (iter nil items))

(define (fringe tree)
  (define (iter acc sub-tree)
    (cond
      [(null? sub-tree) acc]
      [(pair? (car sub-tree)) (iter (iter acc (car sub-tree)) (cdr sub-tree))]
      [else (iter (cons (car sub-tree) acc) (cdr sub-tree))]))
  (reverse (iter nil tree)))

(define x (list (list 1 2) (list 3 4)))
(fringe x)
(fringe (list x x))
(let ([y (list x x)]) (fringe (list y y)))
#+end_src

#+RESULTS:
: (1 2 3 4)
: (1 2 3 4 1 2 3 4)
: (1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4)

This is lovely, but the downside is that it is not truly an iterative process, since there are branches that would cause the previous scope to wait for a new iterative process to finish evaluation. Still, this lowers the growth of memory when there are long lists in the tree.
* Exercise 2.29
** Prompt
Working with the concept of a binary mobile, which has the following constructors.
#+begin_src racket :exports code
;; make-mobile makes a binary mobile. left and right are branches.
(define (make-mobile left right) (list left right))
;; make-branch is the constructor for a branch. length must be an integer, and
;; structure could either be a number or another mobile
(define (make-branch length structure) (list length structure))
#+end_src
*** Local Analysis
This problem is introducing the concept of indirect recursive data structure.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (make-mobile left right)
  (list left right))
(define (make-branch length structure)
  (list length structure))

;; Part a. make a selector for mobile called left-branch and right-branch.
;; Make a selector for branches called branch-length and branch-structure
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile)))

(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (car (cdr branch)))

(left-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))
(right-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))

(branch-length (make-branch 2 4))
(branch-structure (make-branch 2 4))

;; Part b. define a procedure called total weight that will return the total
;; weight of the mobile.
;; We're really looking to accumulate the sum of the weights, with the
;; assumption that the mobile type does not have a weight associated with it.
;; Branches are actually tagged unions, so we should have a predicate that
;; determines the type. Base case is that we have reached a branch that is a
;; weight, then we could return the value.

(define (mobile? x)
  (pair? x))

(define (total-weight mobile)
  (define (total-weight-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (total-weight local-structure)
          local-structure)))
  (+ (total-weight-branch (left-branch mobile)) (total-weight-branch (right-branch mobile))))

(define test-mobile-1
  (make-mobile
   (make-branch 4 (make-mobile (make-branch 2 2) (make-branch 4 2)))
   (make-branch 7
                (make-mobile (make-branch 3 (make-mobile (make-branch 3 3) (make-branch 3 12)))
                             (make-branch 2 2)))))

;; expect the total-weight to be 21 for test-mobile-1
(total-weight test-mobile-1)

;; Part c. Make a predicate that will determine if the mobile is balanced,
;; where balanced means that the torque of the left and right branch is
;; equal, and all the mobiles underneath are balanced as well. As a reminder,
;; torque is the product of the length of the rod and the weight it is
;; carrying.
;; For the sake of computational efficiency, we're going to calculate this
;; predicate as we traverse the tree
(define (balanced? mobile)
  (define (get-torque x)
    (car x))
  (define (get-branch-weight x)
    (cdr x))
  ;; handle-branch should return a pair of the torque and weight or propagate a
  ;; nil
  (define (handle-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (let ([mobile-return (handle-mobile local-structure)])
            (if (null? mobile-return)
                mobile-return
                (cons (* (branch-length branch) mobile-return) mobile-return)))
          (cons (* (branch-length branch) local-structure) local-structure))))
  ;; handle-mobile should either return a nil if it does not find the mobile
  ;; parameter to be balanced, else return the sum of the weight of the
  ;; two branches.
  (define (handle-mobile mobile)
    (let ([left (handle-branch (left-branch mobile))]
          [right (handle-branch (right-branch mobile))])
      (cond
        [(or (null? left) (null? right)) nil]
        [(= (get-torque left) (get-torque right))
         (+ (get-branch-weight left) (get-branch-weight right))]
        [else nil])))
  (not (null? (handle-mobile mobile))))

(balanced? test-mobile-1)
(balanced? (make-mobile (make-branch 1 1)
                        (make-branch 1 1)))
(balanced? (make-mobile (make-branch 1 8)
                        (make-branch 2 4)))
(balanced? (make-mobile (make-branch 1 (make-mobile (make-branch 1 4)
                                                    (make-branch 1 4)))
                        (make-branch 2 4)))


#+end_src

#+RESULTS:
: (2 2)
: (3 3)
: 2
: 4
: 21
: #f
: #t
: #t
: #t

In part d of the exercise, we are changing the implementation of the constructor. How many procedures must change to keep the functionality the same?

#+caption: Constructor and data structure representation changes.
#+begin_src racket :exports code
(define (make-mobile left right) (cons left right))
(define (make-branch length structure) (cons length structure))
#+end_src

The answer is just the ~cdr~ selectors, since we are using the abstraction for data structure access in all higher level procedures that work with this system. Swapping from list to pair means that you no longer need the ~car~ to access the second element, since the pair here does not need the facility to allow for dynamic extension.

#+begin_src racket :exports both
#lang sicp
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))

;; Part a. make a selector for mobile called left-branch and right-branch.
;; Make a selector for branches called branch-length and branch-structure
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))

(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))

(left-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))
(right-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))

(branch-length (make-branch 2 4))
(branch-structure (make-branch 2 4))

;; Part b. define a procedure called total weight that will return the total
;; weight of the mobile.
;; We're really looking to accumulate the sum of the weights, with the
;; assumption that the mobile type does not have a weight associated with it.
;; Branches are actually tagged unions, so we should have a predicate that
;; determines the type. Base case is that we have reached a branch that is a
;; weight, then we could return the value.

(define (mobile? x)
  (pair? x))

(define (total-weight mobile)
  (define (total-weight-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (total-weight local-structure)
          local-structure)))
  (+ (total-weight-branch (left-branch mobile)) (total-weight-branch (right-branch mobile))))

(define test-mobile-1
  (make-mobile
   (make-branch 4 (make-mobile (make-branch 2 2) (make-branch 4 2)))
   (make-branch 7
                (make-mobile (make-branch 3 (make-mobile (make-branch 3 3) (make-branch 3 12)))
                             (make-branch 2 2)))))

;; expect the total-weight to be 21 for test-mobile-1
(total-weight test-mobile-1)

;; Part c. Make a predicate that will determine if the mobile is balanced,
;; where balanced means that the torque of the left and right branch is
;; equal, and all the mobiles underneath are balanced as well. As a reminder,
;; torque is the product of the length of the rod and the weight it is
;; carrying.
;; For the sake of computational efficiency, we're going to calculate this
;; predicate as we traverse the tree
(define (balanced? mobile)
  (define (get-torque x)
    (car x))
  (define (get-branch-weight x)
    (cdr x))
  ;; handle-branch should return a pair of the torque and weight or propagate a
  ;; nil
  (define (handle-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (let ([mobile-return (handle-mobile local-structure)])
            (if (null? mobile-return)
                mobile-return
                (cons (* (branch-length branch) mobile-return) mobile-return)))
          (cons (* (branch-length branch) local-structure) local-structure))))
  ;; handle-mobile should either return a nil if it does not find the mobile
  ;; parameter to be balanced, else return the sum of the weight of the
  ;; two branches.
  (define (handle-mobile mobile)
    (let ([left (handle-branch (left-branch mobile))]
          [right (handle-branch (right-branch mobile))])
      (cond
        [(or (null? left) (null? right)) nil]
        [(= (get-torque left) (get-torque right))
         (+ (get-branch-weight left) (get-branch-weight right))]
        [else nil])))
  (not (null? (handle-mobile mobile))))

(balanced? test-mobile-1)
(balanced? (make-mobile (make-branch 1 1) (make-branch 1 1)))
(balanced? (make-mobile (make-branch 1 8) (make-branch 2 4)))
(balanced? (make-mobile (make-branch 1 (make-mobile (make-branch 1 4) (make-branch 1 4)))
                        (make-branch 2 4)))
#+end_src

#+RESULTS:
: (2 . 2)
: (3 . 3)
: 2
: 4
: 21
: #f
: #t
: #t
: #t

And we can see that this was an acceptable refactor. We changed 2 procedures to accommodate for the change in the data structure representation.
* Exercise 2.30
** Prompt
Make a procedure ~square-tree~ that is analogous to the ~square-list~ procedure in exercise [[*Exercise 2.21][Exercise 2.21]]. Do this exercise with and without the ~map~ procedure.
** Solution
#+caption: Square tree without using map
#+begin_src racket :exports both
#lang sicp

(define (square x)
  (* x x))
(define (square-tree tree)
  (cond
    [(null? tree) nil]
    [(pair? tree) (cons (square-tree (car tree)) (square-tree (cdr tree)))]
    [else (square tree)]))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

#+caption: Square tree using map
#+begin_src racket :exports both
#lang sicp

(define (square x)
  (* x x))
(define (square-tree tree)
  (map (lambda (x)
         (if (pair? x)
             (square-tree x)
             (square x)))
       tree))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

I'll say, the ~map~ version of the implementation was actually easier to reason about.
* Exercise 2.31
** Prompt
Abstract tree map out of the previous implementation. Design such that the definition of ~square-tree~ from [[*Exercise 2.30][Exercise 2.30]] looks like the following code block.
#+begin_src racket :exports code
(define (square-tree tree) (tree-map square tree))
#+end_src
** Solution
For the sake of reuse, I'll implement this using the pre-existing ~map~ procedure.

#+begin_src racket :exports both
#lang sicp

(define (tree-map f items)
  (map (lambda (x)
         (if (pair? x)
             (tree-map f x)
             (f x)))
       items))

(define (square x)
  (* x x))
(define (square-tree tree)
  (tree-map square tree))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

Just like that, we have a clean and efficient implementation of tree map.
* Exercise 2.32
** Prompt
Knowing the definition of a set, make a procedure that generates a set of subsets using the given code.
** Solution
#+begin_src racket :exports both
#lang sicp

;; Invariant, s is a set that is represented as a list. This means that this
;; list should have no duplicate elements.
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ([rest (subsets (cdr s))]) (append rest (map (lambda (x) (cons (car s) x)) rest)))))

;; this should return (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
(subsets (list 3))
(subsets (list 2 3))
(subsets (list 1 2 3))
#+end_src

#+RESULTS:
: (() (3))
: (() (3) (2) (2 3))
: (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))

In this problem, we are working with a power set. The pattern is that we want the combination of all the elements of the input set. Recursive approach is the following. Since we are returning a set of set, the base case is the very last element of the input set, which is nil. Then the recursion case goes back one layer, where we are working with an input set of 3 and nil. This layer has two elements in the input set, and we have the power-set of the tail of the input set. Now we generate the next layer output by appending the power-set of the tail with a set of the head of the set with the power-set of the tail. The set of the head appended to the power-set of the tail will create the rest of the elements that would appear upon adding the head element to the input set. Excuse the less than clear explanation, the writer of this file did not have a very formal mathematical background.
* Exercise 2.33
** Prompt
This is the first element after learning about sequence operations and how it contributes to modular design. Task for this exercise is to define ~map~, ~append~, and ~length~ in terms of accumulate.
** Solution
This exercise makes us use right fold to achieve different solutions.
#+begin_src racket :exports both
#lang sicp
;; Accumulate designed as right fold
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))

(accumulate (lambda (x y) (+ x y)) 0 (list 1 2 3 4))

;; This implementation requires that the accumulate function be a right fold,
;; else we would not be able to build like this.
(define (map p sequence)
  (accumulate (lambda (x y)
                (cons (p x) y))
              nil
              sequence))

(map (lambda (x) (* x x)) (list 1 2 3 4))

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(append (list 1 2) (list 3 4))

(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))

(length nil)
(length (list 1 2 2 2 2))
#+end_src

#+RESULTS:
: 10
: (1 4 9 16)
: (1 2 3 4)
: 0
: 5
* Exercise 2.34
** Prompt
Using Horner's rule, evaluate the polynomial as an accumulation.

\[a_{n} x^{n} + a_{n-1}x^{n -1} + \cdots + a_{1} x + a_{0} \rightarrow \left( \cdots \left( a_{n} x + a_{n-1} \right) x + \cdots + a_{1} \right) x + a_{0}\]
** Solution
Horner's rule brings the evaluation of the \(x\) term into a recursive case, which also reduces the number of multiplication that is happening. This can be done in a single accumulation sequence operation.

#+begin_src racket :exports both
#lang sicp
;; Accumulate designed as right fold
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))

;; coefficient-sequence is given in order or a_0 to a_n
(define (horner-eval x coefficient-sequence)
  ;; accumulate must be a right fold for this implementation
  (accumulate (lambda (curr-coefficient accumulation) (+ curr-coefficient (* x accumulation)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 1 1))
(horner-eval 2 (list 1 3 0 5 0 1))
#+end_src

#+RESULTS:
: 7
: 79

Cool note. Horner's rule is the most optimal algorithm for polynomial evaluation.
* Exercise 2.35
** Prompt
Redefine ~count-leaves~ from section 2.2.2 as an accumulation.
** Solution
#+begin_src racket :exports both
#lang sicp

;; still using right fold for accumulation
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))
;; Procedure under test
(define (count-leaves t)
  (accumulate +
              0
              (map (lambda (x)
                     (if (pair? x)
                         (count-leaves x)
                         1))
                   t)))

(count-leaves (list 1 (list 3 4) 5))
#+end_src

#+RESULTS:
: 4

Modularity is a powerful tool for designing software.
* Exercise 2.36
** prompt
Make a procedure called ~accumulate-n~ where the third parameter is a sequence of equal length sequences. The accumulation will now happen on the different sequences at the same index.

#+caption: Example output
#+begin_src racket :exports code
(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
(22 26 30)
#+end_src

A template for the solution was provided. Work within the constraint.
** Solution

#+begin_src racket :exports both
#lang sicp

;; still using right fold for accumulation
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))
(define (accumulate-n op initial seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op initial (map car seqs))
            (accumulate-n op initial (map cdr seqs)))))

(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
#+end_src

#+RESULTS:
: (22 26 30)

Our solution uses sequence operators to quickly build this system. Hoping that this is sufficiently modular.
* Exercise 2.37
** Prompt
Matrix operation. Vectors \(v\) are sequences of numbers and matrices are sequence of equal length vectors. Implement ~dot-product~, ~matrix-*-vector~, ~matrix-*-matrix~, and ~transpose~. Note that the implementation of the matrix is a list of list by rows.
** Solution
#+begin_src racket :exports both
#lang sicp
;; still using right fold for accumulation
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))
;; Need to use this for transpose
(define (accumulate-n op initial seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op initial (map car seqs)) (accumulate-n op initial (map cdr seqs)))))

(define (dot-product v w)
  (accumulate + 0 (map * v w))) ;; This is using expanded map

(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))
;; This implementation is reliant on accumulate-n being a right fold.
(define (transpose mat)
  (accumulate-n cons nil mat))

(define (matrix-*-matrix m n)
  (let ([cols (transpose n)])
    (map (lambda (x) (matrix-*-vector cols x)) m)))

(dot-product (list 1 2 3) (list 4 5 6))
(matrix-*-vector (list (list 1 2) (list 3 4)) (list 5 6))
(transpose (list (list 1 2) (list 3 4)))
(matrix-*-matrix (list (list 1 2) (list 3 4)) (list (list 5 6) (list 7 8)))
#+end_src

#+RESULTS:
: 32
: (17 39)
: ((1 3) (2 4))
: ((19 22) (43 50))

We got the expected values out of this implementation. This implementation does not focus on getting the best cache hits, but instead it was all about modularity and reusing abstractions created as we implement each of the matrix operations.
* Exercise 2.38
** Prompt
We realize that we were using a right fold for accumulate previously. Now we introduce a fold left procedure that operates from left to right. This implementation is an iterative process.
#+caption: Implementation of fold left and fold right
#+begin_src racket :exports code
(define (fold-right p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (fold-right p initial (cdr sequence)))))

(define (fold-left op initial seq)
  (define (iter acc s)
    (if (null? s)
        acc
        (iter (op acc (car s))
              (cdr s))))
  (iter initial seq))
#+end_src

Find the value of the following operations.
#+begin_src racket :exports code
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#+end_src
** Solution
#+caption: Solution (before verifying)
#+begin_src racket :exports code
;; (fold-right / 1 (list 1 2 3))
(/ 1 (/ 2 (/ 3 1)))
(3/2)
;; (fold-left / 1 (list 1 2 3))
(/ (/ (/ 1 1) 2) 3)
(1/6)
;; (fold-right list nil (list 1 2 3))
(list 1 (list 2 (list 3 nil)))
(1 (2 (3 ())))
;; (fold-left list nil (list 1 2 3))
(list (list (list nil 1) 2) 3)
(((() 1) 2) 3)
#+end_src

With that solution done, we should verify the result.

#+begin_src racket :exports both
#lang sicp
(define (fold-right p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (fold-right p initial (cdr sequence)))))

(define (fold-left op initial seq)
  (define (iter acc s)
    (if (null? s)
        acc
        (iter (op acc (car s))
              (cdr s))))
  (iter initial seq))
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#+end_src

#+RESULTS:
: 3/2
: 1/6
: (1 (2 (3 ())))
: (((() 1) 2) 3)

Nice, we were correct about the semantics of the problem. Now to talk about the property of the operator that would make ~fold-left~ and ~fold-right~ return the same value. That operator property is the commutative property. Commutative property is a property that means that the operator will produce the same output if you swap the position of the operands.
* Exercise 2.39
** Prompt
Define ~reverse~ using both ~fold-left~ and ~fold-right~.
** Solution
#+caption: Fold right implementation of reverse.
#+begin_src racket :exports both
#lang sicp
(define (fold-right p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (fold-right p initial (cdr sequence)))))

(define (reverse seq)
  (fold-right (lambda (x y) (if (null? y)
                                (cons x nil)
                                (append y (cons x nil)))) nil seq))

(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)

The fold right implementation requires the use of the append procedure, which is inefficient.

#+caption: Fold left implementation of reverse.
#+begin_src racket :exports both
#lang sicp
(define (fold-left op initial seq)
  (define (iter acc s)
    (if (null? s)
        acc
        (iter (op acc (car s))
              (cdr s))))
  (iter initial seq))

(define (reverse seq)
  (fold-left (lambda (x y) (cons y x)) nil seq))
(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)

Fold left is much more efficient for reversing a list, as it is an iterative process, and it avoids append.
* Exercise 2.40
** Prompt
This problem goes into the application of the ~flatmap~. Define a procedure called ~unique-map~ that when given an integer ~n~, generate the sequence of pairs (i, j) with 1 <= j < i <= n. Use this to simplify the definition of ~prime-sum-pairs~.
** Solution
#+begin_src racket :exports both
#lang sicp
;; Importing prime?
(define (square x) (* x x))
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? x y) (= (remainder y x) 0))
(define (prime? n)
  (= n (smallest-divisor n)))

(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))

(define (filter predicate seq)
  (fold-right (lambda (x y) (if (predicate x) (cons x y) y)) nil seq))


(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))

(define (unique-pairs n)
  (flatmap (lambda (x) (map (lambda (y) (list x y)) (enumerate-range 1 (- x 1))))
           (enumerate-range 2 n)))

(define (make-pair-sum pair)
  (let ((left (car pair)) (right (car (cdr pair))))
    (list left right (+ left right))))
(define (prime-sum-pairs n)
  (define (prime-sum? x) (prime? (+ (car x) (car (cdr x) ))))
  (map make-pair-sum (filter prime-sum? (unique-pairs n))))

(unique-pairs 8)
(prime-sum-pairs 8)
#+end_src

#+RESULTS:
: ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3) (5 1) (5 2) (5 3) (5 4) (6 1) (6 2) (6 3) (6 4) (6 5) (7 1) (7 2) (7 3) (7 4) (7 5) (7 6) (8 1) (8 2) (8 3) (8 4) (8 5) (8 6) (8 7))
: ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11) (7 4 11) (7 6 13) (8 3 11) (8 5 13))
* Exercise 2.41
** Prompt
Write a procedure to find all ordered triples of distinct positive integers i, j, and k less than or equal to a given integer n that sum to a given integer s
** Solution
We are looking for all ordered integers of distinct positive integers. Distinct means that we will not accept cases where i, j, or k are equal. Furthermore, the values no longer has to be less than each other, they just need to be distinct. We'd usually generate this with three for loops. Next, we will filter by summing.

#+begin_src racket :exports both
#lang sicp
(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))

(define (filter predicate seq)
  (fold-right (lambda (x y)
                (if (predicate x)
                    (cons x y)
                    y))
              nil
              seq))

(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))

;; This procedure checks if the target value is contained inside the sequence
;; Currently only comparing numerical contents
(define (contains? target seq)
  (fold-right (lambda (left right)
                (cond
                  [(= left target) #t]
                  [else right]))
              #f
              seq))

;; Enumerates from 1 to n, inclusive, but do not include the values in the
;; excl dynamic parameter.
(define (enumerate-exclusion n . excl)
  (define (enumerate-exclusion-aux lower)
    (cond
      [(> lower n) nil]
      [(contains? lower excl) (enumerate-exclusion-aux (+ lower 1))]
      [else (cons lower (enumerate-exclusion-aux (+ lower 1)))]))
  (enumerate-exclusion-aux 1))

;; constructor and selector for the triple
(define (make-triple a b c)
  (list a b c))
(define (first x)
  (car x))
(define (second x)
  (car (cdr x)))
(define (third x)
  (car (cdr (cdr x))))

;; Main function should do the following to reduce work. Only enumerate through
;; what is possible to get to the target sum. If we cannot get to the target
;; sum, then move on to the next iteration.
(define (ordered-triple-sum n s)
  (flatmap (lambda (x)
             (flatmap (lambda (y)
                        (map (lambda (z) (make-triple x y z))
                             (filter (lambda (c) (= (+ x y c) s)) (enumerate-exclusion n x y))))
                      (filter (lambda (b) (< (+ x b) s)) (enumerate-exclusion n x))))
           ;; We could subtract two from the first case because the smallest
           ;; increase with two more value is 1 + 2
           (filter (lambda (a) (< a (- s 2))) (enumerate-range 1 n))))

(ordered-triple-sum 8 11)
#+end_src

#+RESULTS:
: ((1 2 8) (1 3 7) (1 4 6) (1 6 4) (1 7 3) (1 8 2) (2 1 8) (2 3 6) (2 4 5) (2 5 4) (2 6 3) (2 8 1) (3 1 7) (3 2 6) (3 6 2) (3 7 1) (4 1 6) (4 2 5) (4 5 2) (4 6 1) (5 2 4) (5 4 2) (6 1 4) (6 2 3) (6 3 2) (6 4 1) (7 1 3) (7 3 1) (8 1 2) (8 2 1))

For the sake of performance, instead of building all the permuatations first, and then filtering them out, we could reduce the permutation problem size by filtering the enumeration out as we go.
* Exercise 2.42
** Prompt
This is the eight queens problem, which asks how to place 8 queens on a chessboard. Strategy being asked of us is to place a queen in each column. For the k-th queen, check we can place a queen in a row that will not conflict with the previously placed queens. To do this, we are asked to keep track of all the previous legal moves, and as we move forward, filter out the ones that are not legal. On the k-th queen, don't just produce one legal position, but all of them. Actually, the generalization will be done for a square chessboard of equal size. The following is the provided code, implement the rest.

#+begin_src racket :exports code
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter (lambda (positions) (safe? k positions))
                (flatmap
                 (lambda (rest-of-queens)
                   (map (lambda (new-row)
                          (adjoin-position
                           new-row k rest-of-queens))
                        (enumerate-interval 1 board-size)))
                 (queen-cols (- k 1))))))
  (queen-cols board-size))
#+end_src
** Solution
We can make our solution more flexible by making the underlying representation a pair, and forgo the index. This way, the previous queens do not have to be ordered. Our recusions could be much more efficient with this strategy of implementing this.
#+begin_src racket :exports both
#lang sicp
;; unit testing
(define (assert-predicate pred-fn test-name value expected)
  (display (if (pred-fn value expected) "pass: " "fail: "))
  (display test-name)
  (display " value: ")
  (display value)
  (display " expected: ")
  (display expected)
  (newline))
(define (assert-eq test-name value expected)
  (assert-predicate eq? test-name value expected))
(define (assert-almost-eq test-name value expected)
  (define dx 0.0001)
  (define (almost-eq? left right)
    (< (abs (- left right)) dx))
  (assert-predicate almost-eq? test-name value expected))

;; Common sequence operators
(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))
(define (fold-left op initial seq)
  (define (iter acc remaining)
    (if (null? remaining)
        acc
        (iter (op (car remaining) acc) (cdr remaining))))
  (iter initial seq))
(define (filter predicate seq)
  (fold-right (lambda (x y)
                (if (predicate x)
                    (cons x y)
                    y))
              nil
              seq))

(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))
(define (enumerate-interval lower upper)
  (enumerate-range lower upper))

;; Need to implement the representation of the queens on the board. We can
;; make this representation unordered if we store the col and row information
;; with the queen
(define empty-board nil)
(define (make-queen row col)
  (cons row col))
(define (get-row queen)
  (car queen))
(define (get-col queen)
  (cdr queen))
;; Looks like k actually does nothing for us yet
(define (adjoin-position nr k roq)
  (cons (make-queen nr k) roq))

(define (safe? k positions)
  (define (get-queen)
    (fold-left (lambda (x acc)
                 (if (null? acc)
                     (if (= (get-col x) k) x acc)
                     acc))
               nil
               positions))
  ;; check if the two queens are diag from each other
  (define (diag? a b)
    (= (abs (- (get-col a)
               (get-col b)))
     (abs (- (get-row a)
             (get-row b)))))
  ;; where target is the queen that is being tested against
  (define (safe?-aux target roq)
    (define (iter rest-of-queens)
      (cond
        [(null? rest-of-queens) #t]
        [(= (get-row target) (get-row (car rest-of-queens))) #f]
        [(= (get-col target) (get-col (car rest-of-queens))) #f]
        [(diag? target (car rest-of-queens)) #f]
        [else (iter (cdr rest-of-queens))]))
    (iter roq))
  (let ((k-queen (get-queen))) (safe?-aux k-queen
                                          (filter (lambda (x) (not (and (= (get-col x)
                                                                           (get-col k-queen))
                                                                        (= (get-row x)
                                                                           (get-row k-queen)))))
                                                  positions))))

(display "testing safe?")
(newline)
(define base-1 (adjoin-position 7 3 (adjoin-position 5 2 (adjoin-position 1 1 empty-board))))
(define base-2 (adjoin-position 1 1 empty-board))
(assert-eq "horizontal collision" (safe? 4 (adjoin-position 1 4 base-1)) #f)
(assert-eq "no collision" (safe? 4 (adjoin-position 2 4 base-1)) #t)
(assert-eq "diagonal collision 1" (safe? 4 (adjoin-position 3 4 base-1)) #f)
(assert-eq "diagonal collision 2" (safe? 4 (adjoin-position 6 4 base-1)) #f)
(assert-eq "diagonal collision 3" (safe? 4 (adjoin-position 4 4 base-1)) #f)
(assert-eq "fail by horizontal collision" (safe? 2 (adjoin-position 1 2 base-2)) #f)
(assert-eq "fail by diagonal collision" (safe? 2 (adjoin-position 2 2 base-2)) #f)
(assert-eq "safe 1" (safe? 2 (adjoin-position 3 2 base-2)) #t)
(assert-eq "safe 2" (safe? 2 (adjoin-position 4 2 base-2)) #t)
(assert-eq "safe 3" (safe? 2 (adjoin-position 5 2 base-2)) #t)
(assert-eq "safe 4" (safe? 2 (adjoin-position 6 2 base-2)) #t)
(assert-eq "safe 5" (safe? 2 (adjoin-position 7 2 base-2)) #t)
(assert-eq "safe 6" (safe? 2 (adjoin-position 8 2 base-2)) #t)
(newline)

;; We are using board-size as a local global (all the other recursion will use
;; this value to test if the system is working as intended)
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        ;; Making the base board
        (list empty-board)
        ;; filter, safe? is given the current col being tested, and positions
        ;; actually already includes the parameter
        (filter (lambda (positions) (safe? k positions))
                (flatmap (lambda (rest-of-queens)
                           (map (lambda (new-row) (adjoin-position new-row k rest-of-queens))
                                (enumerate-interval 1 board-size)))
                         (queen-cols (- k 1))))))
  (queen-cols board-size))

(display "one queens")
(newline)
(queens 1)
(display "four queens")
(newline)
(queens 4)
(display "five queens")
(newline)
(queens 5)
(display "eight queens")
(newline)
(queens 8)
#+end_src

#+RESULTS:
#+begin_example
testing safe?
pass: horizontal collision value: #f expected: #f
pass: no collision value: #t expected: #t
pass: diagonal collision 1 value: #f expected: #f
pass: diagonal collision 2 value: #f expected: #f
pass: diagonal collision 3 value: #f expected: #f
pass: fail by horizontal collision value: #f expected: #f
pass: fail by diagonal collision value: #f expected: #f
pass: safe 1 value: #t expected: #t
pass: safe 2 value: #t expected: #t
pass: safe 3 value: #t expected: #t
pass: safe 4 value: #t expected: #t
pass: safe 5 value: #t expected: #t
pass: safe 6 value: #t expected: #t

one queens
(((1 . 1)))
four queens
(((3 . 4) (1 . 3) (4 . 2) (2 . 1)) ((2 . 4) (4 . 3) (1 . 2) (3 . 1)))
five queens
(((4 . 5) (2 . 4) (5 . 3) (3 . 2) (1 . 1)) ((3 . 5) (5 . 4) (2 . 3) (4 . 2) (1 . 1)) ((5 . 5) (3 . 4) (1 . 3) (4 . 2) (2 . 1)) ((4 . 5) (1 . 4) (3 . 3) (5 . 2) (2 . 1)) ((5 . 5) (2 . 4) (4 . 3) (1 . 2) (3 . 1)) ((1 . 5) (4 . 4) (2 . 3) (5 . 2) (3 . 1)) ((2 . 5) (5 . 4) (3 . 3) (1 . 2) (4 . 1)) ((1 . 5) (3 . 4) (5 . 3) (2 . 2) (4 . 1)) ((3 . 5) (1 . 4) (4 . 3) (2 . 2) (5 . 1)) ((2 . 5) (4 . 4) (1 . 3) (3 . 2) (5 . 1)))
eight queens
(((4 . 8) (2 . 7) (7 . 6) (3 . 5) (6 . 4) (8 . 3) (5 . 2) (1 . 1)) ((5 . 8) (2 . 7) (4 . 6) (7 . 5) (3 . 4) (8 . 3) (6 . 2) (1 . 1)) ((3 . 8) (5 . 7) (2 . 6) (8 . 5) (6 . 4) (4 . 3) (7 . 2) (1 . 1)) ((3 . 8) (6 . 7) (4 . 6) (2 . 5) (8 . 4) (5 . 3) (7 . 2) (1 . 1)) ((5 . 8) (7 . 7) (1 . 6) (3 . 5) (8 . 4) (6 . 3) (4 . 2) (2 . 1)) ((4 . 8) (6 . 7) (8 . 6) (3 . 5) (1 . 4) (7 . 3) (5 . 2) (2 . 1)) ((3 . 8) (6 . 7) (8 . 6) (1 . 5) (4 . 4) (7 . 3) (5 . 2) (2 . 1)) ((5 . 8) (3 . 7) (8 . 6) (4 . 5) (7 . 4) (1 . 3) (6 . 2) (2 . 1)) ((5 . 8) (7 . 7) (4 . 6) (1 . 5) (3 . 4) (8 . 3) (6 . 2) (2 . 1)) ((4 . 8) (1 . 7) (5 . 6) (8 . 5) (6 . 4) (3 . 3) (7 . 2) (2 . 1)) ((3 . 8) (6 . 7) (4 . 6) (1 . 5) (8 . 4) (5 . 3) (7 . 2) (2 . 1)) ((4 . 8) (7 . 7) (5 . 6) (3 . 5) (1 . 4) (6 . 3) (8 . 2) (2 . 1)) ((6 . 8) (4 . 7) (2 . 6) (8 . 5) (5 . 4) (7 . 3) (1 . 2) (3 . 1)) ((6 . 8) (4 . 7) (7 . 6) (1 . 5) (8 . 4) (2 . 3) (5 . 2) (3 . 1)) ((1 . 8) (7 . 7) (4 . 6) (6 . 5) (8 . 4) (2 . 3) (5 . 2) (3 . 1)) ((6 . 8) (8 . 7) (2 . 6) (4 . 5) (1 . 4) (7 . 3) (5 . 2) (3 . 1)) ((6 . 8) (2 . 7) (7 . 6) (1 . 5) (4 . 4) (8 . 3) (5 . 2) (3 . 1)) ((4 . 8) (7 . 7) (1 . 6) (8 . 5) (5 . 4) (2 . 3) (6 . 2) (3 . 1)) ((5 . 8) (8 . 7) (4 . 6) (1 . 5) (7 . 4) (2 . 3) (6 . 2) (3 . 1)) ((4 . 8) (8 . 7) (1 . 6) (5 . 5) (7 . 4) (2 . 3) (6 . 2) (3 . 1)) ((2 . 8) (7 . 7) (5 . 6) (8 . 5) (1 . 4) (4 . 3) (6 . 2) (3 . 1)) ((1 . 8) (7 . 7) (5 . 6) (8 . 5) (2 . 4) (4 . 3) (6 . 2) (3 . 1)) ((2 . 8) (5 . 7) (7 . 6) (4 . 5) (1 . 4) (8 . 3) (6 . 2) (3 . 1)) ((4 . 8) (2 . 7) (7 . 6) (5 . 5) (1 . 4) (8 . 3) (6 . 2) (3 . 1)) ((5 . 8) (7 . 7) (1 . 6) (4 . 5) (2 . 4) (8 . 3) (6 . 2) (3 . 1)) ((6 . 8) (4 . 7) (1 . 6) (5 . 5) (8 . 4) (2 . 3) (7 . 2) (3 . 1)) ((5 . 8) (1 . 7) (4 . 6) (6 . 5) (8 . 4) (2 . 3) (7 . 2) (3 . 1)) ((5 . 8) (2 . 7) (6 . 6) (1 . 5) (7 . 4) (4 . 3) (8 . 2) (3 . 1)) ((6 . 8) (3 . 7) (7 . 6) (2 . 5) (8 . 4) (5 . 3) (1 . 2) (4 . 1)) ((2 . 8) (7 . 7) (3 . 6) (6 . 5) (8 . 4) (5 . 3) (1 . 2) (4 . 1)) ((7 . 8) (3 . 7) (1 . 6) (6 . 5) (8 . 4) (5 . 3) (2 . 2) (4 . 1)) ((5 . 8) (1 . 7) (8 . 6) (6 . 5) (3 . 4) (7 . 3) (2 . 2) (4 . 1)) ((1 . 8) (5 . 7) (8 . 6) (6 . 5) (3 . 4) (7 . 3) (2 . 2) (4 . 1)) ((3 . 8) (6 . 7) (8 . 6) (1 . 5) (5 . 4) (7 . 3) (2 . 2) (4 . 1)) ((6 . 8) (3 . 7) (1 . 6) (7 . 5) (5 . 4) (8 . 3) (2 . 2) (4 . 1)) ((7 . 8) (5 . 7) (3 . 6) (1 . 5) (6 . 4) (8 . 3) (2 . 2) (4 . 1)) ((7 . 8) (3 . 7) (8 . 6) (2 . 5) (5 . 4) (1 . 3) (6 . 2) (4 . 1)) ((5 . 8) (3 . 7) (1 . 6) (7 . 5) (2 . 4) (8 . 3) (6 . 2) (4 . 1)) ((2 . 8) (5 . 7) (7 . 6) (1 . 5) (3 . 4) (8 . 3) (6 . 2) (4 . 1)) ((3 . 8) (6 . 7) (2 . 6) (5 . 5) (8 . 4) (1 . 3) (7 . 2) (4 . 1)) ((6 . 8) (1 . 7) (5 . 6) (2 . 5) (8 . 4) (3 . 3) (7 . 2) (4 . 1)) ((8 . 8) (3 . 7) (1 . 6) (6 . 5) (2 . 4) (5 . 3) (7 . 2) (4 . 1)) ((2 . 8) (8 . 7) (6 . 6) (1 . 5) (3 . 4) (5 . 3) (7 . 2) (4 . 1)) ((5 . 8) (7 . 7) (2 . 6) (6 . 5) (3 . 4) (1 . 3) (8 . 2) (4 . 1)) ((3 . 8) (6 . 7) (2 . 6) (7 . 5) (5 . 4) (1 . 3) (8 . 2) (4 . 1)) ((6 . 8) (2 . 7) (7 . 6) (1 . 5) (3 . 4) (5 . 3) (8 . 2) (4 . 1)) ((3 . 8) (7 . 7) (2 . 6) (8 . 5) (6 . 4) (4 . 3) (1 . 2) (5 . 1)) ((6 . 8) (3 . 7) (7 . 6) (2 . 5) (4 . 4) (8 . 3) (1 . 2) (5 . 1)) ((4 . 8) (2 . 7) (7 . 6) (3 . 5) (6 . 4) (8 . 3) (1 . 2) (5 . 1)) ((7 . 8) (1 . 7) (3 . 6) (8 . 5) (6 . 4) (4 . 3) (2 . 2) (5 . 1)) ((1 . 8) (6 . 7) (8 . 6) (3 . 5) (7 . 4) (4 . 3) (2 . 2) (5 . 1)) ((3 . 8) (8 . 7) (4 . 6) (7 . 5) (1 . 4) (6 . 3) (2 . 2) (5 . 1)) ((6 . 8) (3 . 7) (7 . 6) (4 . 5) (1 . 4) (8 . 3) (2 . 2) (5 . 1)) ((7 . 8) (4 . 7) (2 . 6) (8 . 5) (6 . 4) (1 . 3) (3 . 2) (5 . 1)) ((4 . 8) (6 . 7) (8 . 6) (2 . 5) (7 . 4) (1 . 3) (3 . 2) (5 . 1)) ((2 . 8) (6 . 7) (1 . 6) (7 . 5) (4 . 4) (8 . 3) (3 . 2) (5 . 1)) ((2 . 8) (4 . 7) (6 . 6) (8 . 5) (3 . 4) (1 . 3) (7 . 2) (5 . 1)) ((3 . 8) (6 . 7) (8 . 6) (2 . 5) (4 . 4) (1 . 3) (7 . 2) (5 . 1)) ((6 . 8) (3 . 7) (1 . 6) (8 . 5) (4 . 4) (2 . 3) (7 . 2) (5 . 1)) ((8 . 8) (4 . 7) (1 . 6) (3 . 5) (6 . 4) (2 . 3) (7 . 2) (5 . 1)) ((4 . 8) (8 . 7) (1 . 6) (3 . 5) (6 . 4) (2 . 3) (7 . 2) (5 . 1)) ((2 . 8) (6 . 7) (8 . 6) (3 . 5) (1 . 4) (4 . 3) (7 . 2) (5 . 1)) ((7 . 8) (2 . 7) (6 . 6) (3 . 5) (1 . 4) (4 . 3) (8 . 2) (5 . 1)) ((3 . 8) (6 . 7) (2 . 6) (7 . 5) (1 . 4) (4 . 3) (8 . 2) (5 . 1)) ((4 . 8) (7 . 7) (3 . 6) (8 . 5) (2 . 4) (5 . 3) (1 . 2) (6 . 1)) ((4 . 8) (8 . 7) (5 . 6) (3 . 5) (1 . 4) (7 . 3) (2 . 2) (6 . 1)) ((3 . 8) (5 . 7) (8 . 6) (4 . 5) (1 . 4) (7 . 3) (2 . 2) (6 . 1)) ((4 . 8) (2 . 7) (8 . 6) (5 . 5) (7 . 4) (1 . 3) (3 . 2) (6 . 1)) ((5 . 8) (7 . 7) (2 . 6) (4 . 5) (8 . 4) (1 . 3) (3 . 2) (6 . 1)) ((7 . 8) (4 . 7) (2 . 6) (5 . 5) (8 . 4) (1 . 3) (3 . 2) (6 . 1)) ((8 . 8) (2 . 7) (4 . 6) (1 . 5) (7 . 4) (5 . 3) (3 . 2) (6 . 1)) ((7 . 8) (2 . 7) (4 . 6) (1 . 5) (8 . 4) (5 . 3) (3 . 2) (6 . 1)) ((5 . 8) (1 . 7) (8 . 6) (4 . 5) (2 . 4) (7 . 3) (3 . 2) (6 . 1)) ((4 . 8) (1 . 7) (5 . 6) (8 . 5) (2 . 4) (7 . 3) (3 . 2) (6 . 1)) ((5 . 8) (2 . 7) (8 . 6) (1 . 5) (4 . 4) (7 . 3) (3 . 2) (6 . 1)) ((3 . 8) (7 . 7) (2 . 6) (8 . 5) (5 . 4) (1 . 3) (4 . 2) (6 . 1)) ((3 . 8) (1 . 7) (7 . 6) (5 . 5) (8 . 4) (2 . 3) (4 . 2) (6 . 1)) ((8 . 8) (2 . 7) (5 . 6) (3 . 5) (1 . 4) (7 . 3) (4 . 2) (6 . 1)) ((3 . 8) (5 . 7) (2 . 6) (8 . 5) (1 . 4) (7 . 3) (4 . 2) (6 . 1)) ((3 . 8) (5 . 7) (7 . 6) (1 . 5) (4 . 4) (2 . 3) (8 . 2) (6 . 1)) ((5 . 8) (2 . 7) (4 . 6) (6 . 5) (8 . 4) (3 . 3) (1 . 2) (7 . 1)) ((6 . 8) (3 . 7) (5 . 6) (8 . 5) (1 . 4) (4 . 3) (2 . 2) (7 . 1)) ((5 . 8) (8 . 7) (4 . 6) (1 . 5) (3 . 4) (6 . 3) (2 . 2) (7 . 1)) ((4 . 8) (2 . 7) (5 . 6) (8 . 5) (6 . 4) (1 . 3) (3 . 2) (7 . 1)) ((4 . 8) (6 . 7) (1 . 6) (5 . 5) (2 . 4) (8 . 3) (3 . 2) (7 . 1)) ((6 . 8) (3 . 7) (1 . 6) (8 . 5) (5 . 4) (2 . 3) (4 . 2) (7 . 1)) ((5 . 8) (3 . 7) (1 . 6) (6 . 5) (8 . 4) (2 . 3) (4 . 2) (7 . 1)) ((4 . 8) (2 . 7) (8 . 6) (6 . 5) (1 . 4) (3 . 3) (5 . 2) (7 . 1)) ((6 . 8) (3 . 7) (5 . 6) (7 . 5) (1 . 4) (4 . 3) (2 . 2) (8 . 1)) ((6 . 8) (4 . 7) (7 . 6) (1 . 5) (3 . 4) (5 . 3) (2 . 2) (8 . 1)) ((4 . 8) (7 . 7) (5 . 6) (2 . 5) (6 . 4) (1 . 3) (3 . 2) (8 . 1)) ((5 . 8) (7 . 7) (2 . 6) (6 . 5) (3 . 4) (1 . 3) (4 . 2) (8 . 1)))
#+end_example
* Exercise 2.43
** Prompt
Louis Reasoner has a slower implementation of queens than we do. His code difference is provided. Please explain why it is running slower, and if our program queens runs in T, how long would Louis's implementation take to run?
#+begin_src racket :exports code
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
#+end_src
** Solution
Louis's queen's implementation is slow because each iteration in the recursion is calling the next recursion step multiple times, causing repeated work. This problem compounds heavily fast.

To estimate runtime differences, we should look at the different components of the program that are executed at each of the recursive stage. Let's start with our version of the program. First, at the base case of k = 0, we immediately return, preventing work from occurring. Let's call this constant cost C_{0}. In the other case, we get the result from the k - 1 recursive case of the process. Here are just some quantitative estimation of the runtime of the process. First, we can observe that the base case of ~queen-cols~ has nearly no work being done, just a single conditional, followed by the construction of an empty board. In the recursive case of the program that we implement, we see that the size of the board we are working with multiplies by the width of the board. Finally, the ~safe?~ procedure is ran on the expanding result size. This problem could be tricky to model, since the runtime of ~safe?~ will grow linearly with the size of the board that has already been built, and the number of times that ~safe?~ is called also increases as we find more permutations. Luckily, our implementation of adjoin position is a constant time operation because we have decided to keep track of both the row and column for each of the queen, opening us up to future unordered implementations, while sacrificing twice the amount of memory as other solutions. Let's write the equation for the growth of our process now.

T_{k} = T_{k - 1} + ((b * C_{1} + k * C_{2}) * N_{k})

Where N_{k} is the number of returns from ~queens~ at the problem size, b is the board size, C_{1} is the time it takes to append a new queen on to the board and C_{2} is the time it takes to check if the queen is in a valid position one a board on size one. Now we should consider the base case, T_{0} and T_{0}' for the Louis implementation. We could say that it takes constant time C_{0}, and that it is nearly 0 due to the fact that it is one conditional. As a good engineer, I will just take that as fact, and make T_{0} disappear when faced with it.

Now we'll define the expression for the Louis case, which really just multiplies the recursive case by the width of the board, along with a few difference in the nesting.

T_{k}' = b * (T_{k - 1}' + C_{1} * N_{k} ) + (k * C_{2} * N_{k})

Now we should calculate how long it takes to run the two cases for b = 8.

#+begin_src racket :exports both
#lang sicp

(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))
(define (fold-left op initial seq)
  (define (iter acc remaining)
    (if (null? remaining)
        acc
        (iter (op (car remaining) acc) (cdr remaining))))
  (iter initial seq))
(define (filter predicate seq)
  (fold-right (lambda (x y)
                (if (predicate x)
                    (cons x y)
                    y))
              nil
              seq))

(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))
(define (enumerate-interval lower upper)
  (enumerate-range lower upper))

;; Need to implement the representation of the queens on the board. We can
;; make this representation unordered if we store the col and row information
;; with the queen
(define empty-board nil)
(define (make-queen row col)
  (cons row col))
(define (get-row queen)
  (car queen))
(define (get-col queen)
  (cdr queen))
;; Looks like k actually does nothing for us yet
(define (adjoin-position nr k roq)
  (cons (make-queen nr k) roq))

(define (safe? k positions)
  (define (get-queen)
    (fold-left (lambda (x acc)
                 (if (null? acc)
                     (if (= (get-col x) k) x acc)
                     acc))
               nil
               positions))
  ;; check if the two queens are diag from each other
  (define (diag? a b)
    (= (abs (- (get-col a) (get-col b))) (abs (- (get-row a) (get-row b)))))
  ;; where target is the queen that is being tested against
  (define (safe?-aux target roq)
    (define (iter rest-of-queens)
      (cond
        [(null? rest-of-queens) #t]
        [(= (get-row target) (get-row (car rest-of-queens))) #f]
        [(= (get-col target) (get-col (car rest-of-queens))) #f]
        [(diag? target (car rest-of-queens)) #f]
        [else (iter (cdr rest-of-queens))]))
    (iter roq))
  (let ([k-queen (get-queen)])
    (safe?-aux k-queen
               (filter (lambda (x)
                         (not (and (= (get-col x) (get-col k-queen))
                                   (= (get-row x) (get-row k-queen)))))
                       positions))))

;; We are using board-size as a local global (all the other recursion will use
;; this value to test if the system is working as intended)
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        ;; Making the base board
        (list empty-board)
        ;; filter, safe? is given the current col being tested, and positions
        ;; actually already includes the parameter
        (filter (lambda (positions) (safe? k positions))
                (flatmap (lambda (rest-of-queens)
                           (map (lambda (new-row) (adjoin-position new-row k rest-of-queens))
                                (enumerate-interval 1 board-size)))
                         (queen-cols (- k 1))))))
  (queen-cols board-size))
(define (tk-prime b c1 c2)
  (define (iter k)
    (let ([nk (length (queens k))])
      (if (= k 0)
          0
          (+ (* b (+ (iter (- k 1)) (* c1 nk))) (* k c2 nk)))))
  (iter b))
(define (tk b c1 c2)
  (define (iter acc k)
    (if (> k b)
        acc
        (iter (+ acc (* (length (queens k)) (+ (* b c1) (* k c2)))) (+ k 1))))
  (iter 0 0))

(/ (tk-prime 8 0.1 0.5) (tk 8 0.1 0.5))
#+end_src

#+RESULTS
: 4135.805227781927

So we can see that the Louis implementation is approximately 3 order of magnitudes more expensive to run than our implementation.
* Exercise 2.44
** Prompt
Define ~up-split~ which is similar to ~right-split~, but upwards.
** Solution
Luckily for us, Racket's ~sicp~ package comes with the picture language, so we could just printout the solution to a file and render it on Org. In this solution, we will start to use ~org-tangle~, since it is helpful in literate programming.
#+header: :tangle ./src/exercise-2.44.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
#lang sicp
(#%require sicp-pict)
(define (up-split p n)
  (if (= n 0)
      p
      (let ((up (up-split p (- n 1))))
        (below p (beside up up)))))
(paint (up-split einstein 10))
#+end_src

#+RESULTS:
: #(struct:object:image-snip% ... ...)

#+name: higher-order-painters
#+begin_src racket :exports none
(define (up-split p n)
  (if (= n 0)
      p
      (let ((up (up-split p (- n 1))))
        (below p (beside up up)))))
(define (right-split p n)
  (if (= n 0)
      p
      (let ((right (right-split p (- n 1))))
        (beside p (below right right)))))
#+end_src


Result can be obtained through DrRacket with the ~sicp~ package.
* Exercise 2.45
** Prompt
Make ~right-split~ and ~up-split~ use a higher order procedure in it's implementation. Allow it to be built like the following.

#+begin_src racket :exports code
(define right-split (split beside below))
(define up-split (split below beside))
#+end_src
** Solution
Tangling again.

#+header: :tangle ./src/exercise-2.45.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
#lang sicp
(#%require sicp-pict)
(define (split first-proc second-proc)
  (define (proc p n)
    (if (= n 0)
        p
        (let ([rec (proc p (- n 1))]) (first-proc p (second-proc rec rec)))))
  proc)
(define right-split (split beside below))
(define up-split (split below beside))

(paint (right-split mark-of-zorro 10))
(paint (up-split einstein 10))
#+end_src

#+RESULTS:
: #(struct:object:image-snip% ... ...)
: #(struct:object:image-snip% ... ...)

Running this on DrRacket produced the expected result.
* Exercise 2.46
** Prompt
Make the constructor and selector for the vector we are working with. Following this, implement ~add-vect~, ~sub-vect~, and ~scale-vect~ that does the corresponding vector operations.
** Solution
#+name: vect-def
#+header: :tangle ./src/exercise-2.46.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (make-vect x y)
  (cons x y))
(define (xcor-vect v)
  (car v))
(define (ycor-vect v)
  (cdr v))

(define (add-vect a b)
  (make-vect (+ (xcor-vect a) (xcor-vect b)) (+ (ycor-vect a) (ycor-vect b))))
(define (sub-vect a b)
  (make-vect (- (xcor-vect a) (xcor-vect b)) (- (ycor-vect a) (ycor-vect b))))
(define (scale-vect s v)
  (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))
#+end_src
* Exercise 2.47
** Prompt
There are two possible constructors for the frames, make selectors for them.
#+caption: The two possible constructors for frames.
#+begin_src racket :exports code
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
#+end_src
** Solution
#+caption: List implementation selectors
#+name: list-frame
#+begin_src racket :exports both
#lang sicp
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (caddr f))
;; This is really bad testing since we should be testing with vectors
(define test-frame (make-frame 1 2 3 ))
(origin-frame test-frame)
(edge1-frame test-frame)
(edge2-frame test-frame)
#+end_src

#+RESULTS: list-frame
: 1
: 2
: 3

#+caption: Pair of pair implementation selectors
#+begin_src racket :exports both
#lang sicp
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))

(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (cddr f))
;; This is really bad testing since we should be testing with vectors
(define test-frame (make-frame 1 2 3))
(origin-frame test-frame)
(edge1-frame test-frame)
(edge2-frame test-frame)
#+end_src

#+RESULTS:
: 1
: 2
: 3

We can see that the selectors can obtain the values that corresponds to each of the argument used to build the frame.
* Exercise 2.48
** Prompt
A direct line segment on a plane could be represented as a vector from origin to the start point and a vector from origin from the origin to the end point. Using the vector representation from 2.46, define the representation for the segment with ~make-segment~ as the constructor and ~start-segment~ and ~end-segment~ as the selectors
** Solution
Will need to import the definition for vectors.

#+name: segment-representation
#+begin_src racket :exports both
(define (make-vect x y)
  (cons x y))
(define (xcor-vect v)
  (car v))
(define (ycor-vect v)
  (cdr v))

(define (add-vect a b)
  (make-vect (+ (xcor-vect a) (xcor-vect b)) (+ (ycor-vect a) (ycor-vect b))))
(define (sub-vect a b)
  (make-vect (- (xcor-vect a) (xcor-vect b)) (- (ycor-vect a) (ycor-vect b))))
(define (scale-vect s v)
  (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))

(define (make-segment start end)
  (cons start end))
(define (start-segment s) (car s))
(define (end-segment s) (cdr s))
#+end_src
* Exercise 2.49
** Prompt
Use ~segment->painter~ to define the following primitive painters
a. The painter that draws the outline of the designated frame
b. The painter that draws an "X" by connecting opposite corners of the frame
c. The painter that draws a diamond shape by connecting the midpoints of the sides
** Solution
Great thing about the sicp language in Racket is that it comes with a picture language implementation that already implements ~segment~ and ~vect~.
#+name: vect-consts
#+begin_src racket :exports code
(define bottom-left (make-vect 0 0))
(define bottom-right (make-vect 1 0))
(define top-left (make-vect 0 1))
(define top-right (make-vect 1 1))
#+end_src

#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
;; Setting up tangle file
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

*** Part a
#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports code :noweb yes
; we just need to make a list that makes square
(define outline-painter (segments->painter (list
                                            (make-segment bottom-left bottom-right)
                                            (make-segment bottom-right top-right)
                                            (make-segment top-right top-left)
                                            (make-segment top-left bottom-left))))

(display "Part a. The outline")
(newline)
(paint outline-painter)
#+end_src

#+RESULTS:
: #(struct:object:image-snip% ... ...)
*** Part b
You only need two segments to draw an x in the frame
#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports code :noweb yes
(define cross-painter (segments->painter (list
                                            (make-segment top-left bottom-right)
                                            (make-segment top-right bottom-left))))

(display "Part b. The cross")
(newline)
(paint cross-painter)
#+end_src
*** Part c
Build the diamond painter. In this solution, we over engineer and add a vector average procedure.
#+name: vector-average
#+begin_src racket :exports code
(define (vector-average . v)
  (define (count-aux x acc)
    (if (null? x)
        acc
        (count-aux (cdr x) (+ acc 1))))
  (define (count x)
    (count-aux x 0))
  (define (vector-sum-aux vecs acc)
    (if (null? vecs)
        acc
        (vector-sum-aux (cdr vecs) (vector-add acc (car vecs)))))
  (define (vector-sum vecs)
    (vector-sum-aux vecs zero-vector))
  (vector-scale (/ 1 (count v)) (vector-sum v)))
#+end_src

#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports code :noweb yes
<<vector-average>>

(define diamond-painter
  (segments->painter
   (list
    (make-segment (vector-average bottom-left top-left) (vector-average top-left top-right))
    (make-segment (vector-average top-left top-right) (vector-average top-right bottom-right))
    (make-segment (vector-average top-right bottom-right) (vector-average bottom-right bottom-left))
    (make-segment (vector-average bottom-right bottom-left) (vector-average bottom-left top-left)))))

(display "Part c. The diamond")
(newline)
(paint diamond-painter)
#+end_src
*** Part d
Build the wave painter.

- Actually, I won't be doing this. I don't think that it is adding that value that I want from this book. We'll see each other in the next exercise.
* Exercise 2.50
** Prompt
Define a ~flip-horiz~ that will flip a painter horizontally (left-right flip).
** Solution
#+caption: setup
#+header: :tangle ./src/exercise-2.50.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

#+caption: flip-horiz implementation
#+header: :tangle ./src/exercise-2.50.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (flip-horiz painter)
  (transform-painter painter
                     bottom-right
                     bottom-left
                     top-right))
#+end_src

#+caption: flip-horiz test
#+header: :tangle ./src/exercise-2.50.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(display "einstein")
(newline)
(paint einstein)

(display "flipped einstein")
(newline)
(paint (flip-horiz einstein))
#+end_src

* Exercise 2.51
** Prompt
Define the ~below~ procedure that takes in two painters and put the first painter below the second painter. Make this procedure twice, once the same way as the provided ~beside~ procedure, and the second time using the ~beside~ procedure.
** Solution

*** Part a
Implement ~below~ analogous to ~beside~.

#+caption: setup
#+header: :tangle ./src/exercise-2.51-a.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

#+caption: below implementation
#+header: :tangle ./src/exercise-2.51-a.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (below painter-1 painter-2)
  (let ([split-point (make-vect 0 0.5)])
    (let ([paint-below (transform-painter painter-1 (make-vect 0 0) (make-vect 1 0) split-point)]
          [paint-above (transform-painter painter-2 split-point (make-vect 1 0.5) (make-vect 0 1))])
      (lambda (frame)
        (paint-below frame)
        (paint-above frame)))))
#+end_src

#+caption: below test a
#+header: :tangle ./src/exercise-2.51-a.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(display "einstein")
(newline)
(paint einstein)

(display "below einstein")
(newline)
(paint (below einstein einstein))
#+end_src

*** Part b
Implementing ~below~ using beside and some transformations. We will pretend that a rotate procedure has already been implemented. We will rotate both input values clockwise, and then rotate the entire full image counter clockwise.

#+caption: setup
#+header: :tangle ./src/exercise-2.51-b.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

#+caption: below implementation
#+header: :tangle ./src/exercise-2.51-b.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (below painter-1 painter-2)
  (let ([paint-below (rotate90 painter-1)]
        [paint-above (rotate90 painter-2)])
    (lambda (frame) ((rotate270 (beside paint-below paint-above)) frame))))
#+end_src

#+caption: below test a
#+header: :tangle ./src/exercise-2.51-b.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(display "einstein")
(newline)
(paint einstein)

(display "below einstein")
(newline)
(paint (below einstein einstein))
#+end_src

* Exercise 2.52
** Prompt
Leverage the concept of stratification by changing different levels of the system. Here are what needs to be done.
1. Add more segment to a painter
2. Change ~corner-split~ pattern
3. Modify ~square-limit~ so that the corners are in different patterns
** Solution
We're going to implement the three features at the same time. For the first requirement, we will swap from using wave painter to using the diamond painter, and this time, we will make sure that this new version of painter is asymmetrical.

#+caption: setup
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<higher-order-painters>>
<<vect-consts>>
<<vector-average>>
#+end_src

#+caption: adding segment to a painter (not wave, since I did not make that)
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
;; Adding new segments to make the painter assymmetrical
(define diamond-painter
  (let ([mid-left (vector-average bottom-left top-left)]
        [top-central (vector-average top-left top-right)]
        [mid-right (vector-average top-right bottom-right)]
        [bottom-central (vector-average bottom-right bottom-left)]
        [middle (make-vect 0.5 0.5)])
    (segments->painter (list (make-segment mid-left top-central)
                             (make-segment top-central mid-right)
                             (make-segment mid-right bottom-central)
                             (make-segment bottom-central mid-left)
                             (make-segment middle (vector-average middle top-central))
                             (make-segment middle (vector-average middle mid-right))
                             (make-segment (vector-average middle mid-right)
                                           (vector-average middle top-central))))))
#+end_src

We're going to make the corner more asymmetrical as well.

#+caption: change the corner split pattern
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
;; Adding new segments to make the painter assymmetrical
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ([top (up-split painter (- n 1))])
        (let ([top-right (beside top top)]
              [corner (corner-split painter (- n 1))])
          (beside (below white corner)
                  (below painter top-right))))))

#+end_src

Instead of flipping the top-left and bottom-right corner, we're going to move to rotating them.

#+caption: change the square limit procedure so that the corners are more interesting
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
;; Adding new segments to make the painter assymmetrical
(define (square-limit painter n)
  (let ([cornered-painter (corner-split painter n)])
    (beside (below (rotate180 cornered-painter) (rotate90 cornered-painter))
            (below (rotate270 cornered-painter) cornered-painter))))
#+end_src


#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(paint (square-limit diamond-painter 5))
#+end_src

Now we're done.
* Exercise 2.53
** Prompt
Describe what the interpreter would output with the following expressions
** Solution
We will write the expected output as the comment. We can easily verify that this is correct by running the code.

#+begin_src racket :exports code
#lang sicp

(list 'a 'b 'c)
;; (a b c)
(list (list 'george))
;; ((george))
(cdr '((x1 x2) (y1 y2)))
;; ((y1 y2))
(cadr '((x1 x2) (y1 y2)))
;; (y1 y2)
(pair? (car '(a short list)))
;; false
(memq 'red '((red shoes) (blue socks)))
;; false
(memq 'red '(red shoes blue socks))
;; (red shoes blue socks)
#+end_src

#+RESULTS:
: (a b c)
: ((george))
: ((y1 y2))
: (y1 y2)
: #f
: #f
: (red shoes blue socks)

* Exercise 2.54
** Prompt
Define a procedure called ~equal?~ that will compare two lists using ~eq?~ and if the element is a list, navigate that one and do the same as well.
** Solution
We could implement this recursively. Our strategy is to move through both lists at the same time.

#+begin_src racket :exports both
#lang sicp
(define (equal? a b)
  (cond
    [(and (null? a) (null? b)) true]
    [(and (pair? (car a)) (pair? (car b)))
     (if (equal? (car a) (car b))
         (equal? (cdr a) (cdr b))
         false)]
    [(not (eq? (car a) (car b))) false]
    [else (equal? (cdr a) (cdr b))]))

(equal? '(this is a list) '(this is a list))
(equal? '(this is a list) '(this (is a) list))
#+end_src

#+RESULTS:
: #t
: #f

Raw testing result showed that we successfully implemented the procedure.
* Exercise 2.55
** Prompt
Eva Lu Ator types to the interpreter the following expression.

#+begin_src racket :exports both
#lang sicp
(car ''abracadabra)
#+end_src

#+RESULTS:
: quote

Why the heck did we get ~quote~. Explain.
** Solution
The ~'~ operator in Scheme will treat the values following it as the symbol, and not the value. We should wonder, how does Scheme actually interpret this? Well since we are getting the ~quote~ from a ~car~ it is safe to assume that ~''abracadabra~ will return either a pair or a list. I will not pretend I know the answer right now, so I will do a little experiment.

#+begin_src racket :exports both
#lang sicp
(car ''abracadabra)
''abracadabra
'abracadabra
(car ''(a b c d))
''(a b c d)
'''(a b c d)
(quote (a b c d))
#+end_src

#+RESULTS:
: quote
: (quote abracadabra)
: abracadabra
: quote
: (quote (a b c d))
: (quote (quote (a b c d)))
: (a b c d)

Interesting, it looks like by accessing ~'abracadabra~ with another ~'~ we are able to see the representation for the symbol access. It is a compound object with the first element being the ~quote~ symbol, and the second element being the symbol being shown. This must be used to tell the Scheme interpreter how to access and how the value that is prepended with a quote. More accurately, prepending with a ~'~ will tell the interpreter to return the symbol, and not the value. In our experiment, we did ~'''(a b c d)~ which returned ~(quote (quote (a b c d)))~ and we see that ~(quote (a b c d))~ returns ~(a b c d)~. I think with these tests, we can see that ~quote~ is a procedure that returns its parameter as a symbol. We can also see that ~'~ is actually syntactic sugar for the ~quote~ procedure, meaning that ~(car ''abradacadabra)~ is actually just ~(car (quote (quote abradacadabra)))~ where ~quote~ will evaluate first due to applicative ordered evaluation, resulting in ~(car (quote abradacadabra))~ which will finally evaluate to ~quote~.
* Exercise 2.56
** Prompt
We're working with a system for symbolic differentiation. Implementation for differentiating sums, products, variables, and constant has been given to us. We have to reduce the expression if it is simple to do so. In this exercise, extend the system to handle variables with exponents.
** Solution
Below is the implementation that is provided to us. We will proceed to extend the implementation to add exponents of variables. We'll import this around as a base to other exercises that work with symbolic differentiation.

#+name: deriv-base
#+begin_src racket :exports code
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [else (error "unknown expression type: DERIV" exp)]))
#+end_src

#+name: deriv-base-dependencies
#+begin_src racket :exports code
(define (variable? x)
  (symbol? x))
(define (same-variable? x y)
  (and (variable? x) (variable? y) (eq? x y)))
(define (=number? exp val)
  (and (number? exp) (= exp val)))
#+end_src

#+name: deriv-base-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y) (+ x y))]
    [else (list '+ x y)]))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s)
  (cadr s))
(define (augend s)
  (caddr s))
#+end_src

#+name: deriv-base-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    [else (list '* x y)]))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p)
  (cadr p))
(define (multiplicand p)
  (caddr p))
#+end_src

#+RESULTS: deriv-base-dependencies

#+name: deriv-base-test
#+begin_src racket :exports code
(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

We'll use the strategy that often used in sicp, which is to actually use the abstraction in the algorithm before building the representation. We will write this out.

#+name: deriv-exponentiation
#+begin_src racket :exports code
;; deriv with exponentiation
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [(exponentiation? exp)
     (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1)))]
    [else (error "unknown expression type: DERIV" exp)]))
#+end_src

#+name: deriv-base-exponentiation
#+begin_src racket :exports code
;; Need to now make the representation of the exponentiation expression
(define (make-exponentiation base exponent)
  (cond [(=number? exponent 0) 1]
        [(=number? exponent 1) base]
        [else (list '** base exponent)]))

(define (exponentiation? exp) (and (pair? exp) (eq? (car exp) '**)))
(define (base exp) (cadr exp))
(define (exponent exp) (caddr exp))
#+end_src

Now we will test our implementation.

#+begin_src racket :exports both :noweb yes
#lang sicp
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<deriv-exponentiation>>
<<deriv-base-exponentiation>>
<<deriv-base-test>>
(deriv '(+ (* x y) (** x 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))

The test is not exhaustive, but this does look right.

* Exercise 2.57: Multiple arguments to product and sum
** Prompt
The goal here is to extend the representation of both product and sum to handle arbitrary amount of parameters.
** Solution
We have to make sure that we don't actually need to change the implementation of the ~deriv~ procedure to make this work. Here is the current strategy that we will attempt. We don't really need dynamic parameter unpacking, we just need to make the selector be able to retrieve representation of the sum expression that have more than two elements properly. We should be surgical with where we make the changes.

In our implementation, we made the constructor merge two instances of sums, and made the augend selector handle the case where there are more than two operands. We then do the analogous implementation on the product version.

#+name: deriv-multiple-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y)) (+ x y)]
    [(sum? y) (make-sum (make-sum x (addend y) ) (augend y))]
    [else (list '+ x y)]))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s)
  (cadr s))
(define (augend s)
  (let ([ag (cddr s)])
      (cond [(null? (cdr ag)) (car ag)]
            [(null? (cddr ag)) (make-sum (car ag) (cadr ag))]
            [else (make-sum (car ag) (cons '+ (cdr ag)))])))
#+end_src


#+name: deriv-multiple-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    [(product? y) (make-product (make-product x (multiplier y)) (multiplicand y))]
    [else (list '* x y)]))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p)
  (cadr p))
(define (multiplicand p)
  (let ([mp (cddr p)])
    (cond
      [(null? (cdr mp)) (car mp)]
      [(null? (cddr mp)) (make-product (car mp) (cadr mp))]
      [else (make-product (car mp) (cons '* (cdr mp)))])))
#+end_src


#+begin_src racket :exports both :noweb yes
#lang sicp
<<deriv-base-dependencies>>
<<deriv-multiple-sum>>
<<deriv-multiple-product>>
<<deriv-exponentiation>>
<<deriv-base-exponentiation>>
<<deriv-base-test>>
(deriv '(+ (* x y) (** x 8)) 'x)
(deriv '(* x y (+ x 3)) 'x)
(deriv '(* x y (+ x 3) 0) 'x)
(deriv '(* x y (+ x 3) 1 y) 'x)
(deriv '(+ x y (* x 3) (** x 7)) 'x)
(deriv '(+ x y (* x 3) 0 (** x 7)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))
: (+ (* x y) (* y (+ x 3)))
: 0
: (+ (* (* x y) y) (* (* y (+ x 3)) y))
: (+ 4 (* 7 (** x 6)))
: (+ 4 (* 7 (** x 6)))
* Exercise 2.58: Infix operators
** Prompt
Now modify the program to work on a representation that is infix. Make two versions, first version being that all group of expression is binary, and the second using actual normal algebraic syntax, with PEDMAS order of operations.
** Solution
*** Part A
We'll implement the system to the state where it will correctly evaluate binary infix operations. The chained implementation will be done in part B.
#+name: deriv-infix-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y)) (+ x y)]
    [else (list x '+ y)]))
(define (sum? x)
  (and (pair? x) (eq? (cadr x) '+)))
(define (addend s)
  (car s))
(define (augend s)
  (caddr s))
#+end_src


#+name: deriv-infix-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    [else (list x '* y)]))
(define (product? x)
  (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p)
  (car p))
(define (multiplicand p)
  (caddr p))
#+end_src

#+name: deriv-infix-exponentiation
#+begin_src racket :exports code
;; Need to now make the representation of the exponentiation expression
(define (make-exponentiation base exponent)
  (cond [(=number? exponent 0) 1]
        [(=number? exponent 1) base]
        [else (list base '** exponent)]))

(define (exponentiation? exp) (and (pair? exp) (eq? (cadr exp) '**)))
(define (base exp) (car exp))
(define (exponent exp) (caddr exp))
#+end_src


#+begin_src racket :exports both :noweb yes
#lang sicp
<<deriv-base-dependencies>>
<<deriv-infix-sum>>
<<deriv-infix-product>>
<<deriv-infix-exponentiation>>
<<deriv-exponentiation>>
(deriv '(x + 3) 'x)
(deriv '(x * y) 'x)
(deriv '(x * y) 'y)
(deriv '((x * y) * (x + 3)) 'x)
(deriv '((x * y) * (x + 3)) 'y)
(deriv '((x * y) + (x ** 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: ((x * y) + (y * (x + 3)))
: (y + (8 * (x ** 7)))

*** Part B
In this part, we are trying to parse normal algebraic expressions, like those that people would use. This is the type of parsing that calculators do, and to do this cleanly, we'll make an abstract syntax tree. Another goal is that we should not need to change how the ~deriv~ method works.

We'll treat the representation as a list, but we'll still recursively split it into a sequence of binary operations. The way that it has to work, since we are using recursion is that the lowest priority operation will actually just take the highest precedence, in that an expression that contains the lowest level operator will be treated as a statement of that operator. What this does is that the higher level operators will have to check for the previous level, as to allow them to take precedence in the recursion. (Taking precedence actually makes it evaluate last in our recursive architecture).

#+name: deriv-normal-common
#+begin_src racket :exports code
;; Returns true if the provided symbol, v, is in the list, l
(define (contain? l v)
  (define (iter li)
    (cond
      [(null? li) false]
      [(eq? (car li) v) true]
      [else (iter (cdr li))]))
  (iter l))

;; Returns list of all elements before the value, v
(define (before-first l v)
  (cond
    [(null? l) l]
    [(eq? (car l) v) nil]
    [else (cons (car l) (before-first (cdr l) v))]))

;; Returns list of all elements after the value, v
(define (after-first l v)
  (let ([ret (memq v l)])
    (if (pair? ret) (cdr ret) nil)))
#+end_src

#+name: deriv-normal-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y)) (+ x y)]
    ;; [(sum? y) (make-sum (make-sum x (addend y) ) (augend y))]
    [else (list x '+ y)]))
(define (sum? x)
  (and (pair? x) (contain? x '+)))
;; Assumption is that the sum check has already completed before this procedure
;; is called.
;; addend will be the elements before the first '+ symbol
(define (addend s)
  (let ([v (before-first s '+)])
    (if (null? (cdr v))
        (car v)
        v)))
(define (augend s)
  (let ([v (after-first s '+)])
    (if (null? (cdr v))
        (car v)
        v)))
#+end_src


#+name: deriv-normal-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    ;; [(product? y) (make-product (make-product x (multiplier y)) (multiplicand y))]
    [else (list x '* y)]))
;; This is more tricky. It is product if there is a * in the least nested
;; layer of the expression
(define (product? x)
  (and (pair? x) (not (contain? x '+)) (contain? x '*)))
;; Assuming that product check has always happened before this line
(define (multiplier p)
  (let ([val (before-first p '*)])
    (if (null? (cdr val)) (car val) val)))
(define (multiplicand p)
  (let ([val (after-first p '*)])
    (if (null? (cdr val)) (car val) val)))
#+end_src

#+name: deriv-normal-exponentiation
#+begin_src racket :exports code
;; Need to now make the representation of the exponentiation expression
(define (make-exponentiation base exponent)
  (cond [(=number? exponent 0) 1]
        [(=number? exponent 1) base]
        [else (list base '** exponent)]))

(define (exponentiation? exp) (and (pair? exp) (not (or (contain? exp '+) (contain? exp '*))) (contain? exp '**)))
(define (base exp)
  (car exp))
(define (exponent exp) (caddr exp))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<deriv-base-dependencies>>
<<deriv-normal-common>>
<<deriv-normal-sum>>
<<deriv-normal-product>>
<<deriv-normal-exponentiation>>
<<deriv-exponentiation>>
(assert-eq "sum predicate check" (sum? '(x + 3)) #t)
(assert-eq "sum predicate check" (sum? '(x * 3)) #f)
(assert-eq "multiple sum predicate check" (sum? '(x + 3 + 4 + y)) #t)
(assert-eq "normal expression, with one product predicate check" (sum? '(x + 3 * 4 + y)) #t)
(assert-eq "normal expression, one product predicate check" (sum? '(x * 3 + 4 + y)) #t)
(assert-eq "sum predicate on variable (should fail)" (sum? '(x)) #f)
(assert-eq "sum predicate on variable (should fail)" (sum? 'x) #f)
(assert-eq "sum predicate on number (should fail)" (sum? '(3)) #f)
(assert-eq "getting the adden" (addend '(3 + 4)) 3)
(assert-eq "getting the augend" (augend '(3 + 4)) 4)
(assert-eq "getting the augend" (augend '(3 + x + y)) '(x + y))
(assert-eq "getting the augend" (augend '(3 + x + y + z)) '(x + y + z))
(assert-eq "getting the addend" (addend '(x + 3 * 4 + y)) 'x)
(assert-eq "getting the augend" (augend '(x + 3 * 4 + y)) '(3 * 4 + y))
(assert-eq "getting the addend" (addend '(x * 3 + 4 + y)) '(x * 3))
(assert-eq "getting the addend" (augend '(x * 3 + 4 + y)) '(4 + y))
(assert-eq "product predicate check" (product? '(x * 3)) #t)
(assert-eq "product predicate check" (product? '(x + 3)) #f)
(assert-eq "multiple product predicate check" (product? '(x * 3 * y)) #t)
(assert-eq "multiple product predicate check" (product? '(x + 3 + y)) #f)
(assert-eq "multiple product predicate check" (product? '(x + 3 * y)) #f)
(assert-eq "multiple product predicate check" (product? '(x * 3 + y)) #f)
(assert-eq "product predicate on variable (should fail)" (product? '(x)) #f)
(assert-eq "product predicate on variable (should fail)" (product? 'x) #f)
(assert-eq "product predicate on number (should fail)" (product? '(3)) #f)
(assert-eq "multiple exponent predicate check" (exponentiation? '(x * 3 * y)) #f)
(assert-eq "multiple exponent predicate check" (exponentiation? '(x * 3 * y ** 2)) #f)
(assert-eq "multiple exponent predicate check" (exponentiation? '(x ** 3)) #t)
(deriv '(x + 3) 'x)
(deriv '(x + 3 + y) 'x)
(deriv '(x * y) 'x)
(deriv '((x * y) * (x + 3)) 'x)
(deriv '(x + 3 * (x + y + 2)) 'x)
(deriv '((x * y) + (x ** 8)) 'x)
#+end_src

#+RESULTS:
#+begin_example
pass: sum predicate check value: #t expected: #t
pass: sum predicate check value: #f expected: #f
pass: multiple sum predicate check value: #t expected: #t
pass: normal expression, with one product predicate check value: #t expected: #t
pass: normal expression, one product predicate check value: #t expected: #t
pass: sum predicate on variable (should fail) value: #f expected: #f
pass: sum predicate on variable (should fail) value: #f expected: #f
pass: sum predicate on number (should fail) value: #f expected: #f
pass: getting the adden value: 3 expected: 3
pass: getting the augend value: 4 expected: 4
pass: getting the augend value: (x + y) expected: (x + y)
pass: getting the augend value: (x + y + z) expected: (x + y + z)
pass: getting the addend value: x expected: x
pass: getting the augend value: (3 * 4 + y) expected: (3 * 4 + y)
pass: getting the addend value: (x * 3) expected: (x * 3)
pass: getting the addend value: (4 + y) expected: (4 + y)
pass: product predicate check value: #t expected: #t
pass: product predicate check value: #f expected: #f
pass: multiple product predicate check value: #t expected: #t
pass: multiple product predicate check value: #f expected: #f
pass: multiple product predicate check value: #f expected: #f
pass: multiple product predicate check value: #f expected: #f
pass: product predicate on variable (should fail) value: #f expected: #f
pass: product predicate on variable (should fail) value: #f expected: #f
pass: product predicate on number (should fail) value: #f expected: #f
pass: multiple exponent predicate check value: #f expected: #f
pass: multiple exponent predicate check value: #f expected: #f
pass: multiple exponent predicate check value: #t expected: #t
1
1
y
((x * y) + (y * (x + 3)))
4
(y + (8 * (x ** 7)))
#+end_example

And voila! We are now able to symbolically differentiate a smaller subset of normal algebraic expressions.
* Exercise 2.59
** Prompt
Implement ~union-set~ for the unordered-list representation of a set
** Solution
The following is the provided code from sicp.

#+name: set-unordered-list
#+begin_src racket :exports code
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(equal? x (car set)) true]
    [else (element-of-set? x (cdr set))]))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond
    [(or (null? set1) (null? set2)) '()]
    [(element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))]
    [else (intersection-set (cdr set1) set2)]))
#+end_src

Set unions are the combination of two sets, all we would have to do is to make sure that we don't include an element that already exists.

#+name: set-unordered-list-union
#+begin_src racket :exports code
(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [(element-of-set? (car set1) set2) (union-set (cdr set1) set2)]
    [else (cons (car set1) (union-set (cdr set1) set2))]))
#+end_src

The following is just some checks to make sure that union is unioning.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<set-unordered-list>>
<<set-unordered-list-union>>
<<assertion-suite>>
(define seta '(a b c d e))
(define setb '(d e f g h i j))
(intersection-set seta setb)
(union-set seta setb)
#+end_src

#+RESULTS:
: (d e)
: (a b c d e f g h i j)

Judging by the result of evaluating the code block, the union is unioning.
* Exercise 2.60
** Prompt
Now let the representation allow for duplicates. Re-implement the selectors and constructors, then compare the efficiency of this representation with the noon-duplicate version.
** Solution

#+name: set-unordered-list-duplicate
#+begin_src racket :exports code
;; Does not need to change
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(equal? x (car set)) true]
    [else (element-of-set? x (cdr set))]))

;; Always add without checking. This is how we get duplicates
(define (adjoin-set x set)
  (cons x set))

(define (intersection-set set1 set2)
  (cond
    [(or (null? set1) (null? set2)) '()]
    [(element-of-set? (car set1) set2) (adjoin-set (car set1) (intersection-set (cdr set1) set2))]
    [else (intersection-set (cdr set1) set2)]))

(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [else (cons (car set1) (union-set (cdr set1) set2))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<set-unordered-list-duplicate>>
<<assertion-suite>>
(define seta '(a b c d e))
(define setb '(d e f g h i j))
(define int-set (intersection-set seta setb) )
(define uni-set (union-set seta setb) )
(element-of-set? 'a int-set)
(element-of-set? 'a uni-set)
int-set
uni-set
#+end_src

#+RESULTS:
: #f
: #t
: (d e)
: (a b c d e d e f g h i j)

Let's talk about the efficiency of this implementation. Adjoining the set, unioning a set is faster, however, after enough duplicates have been inserted into the set, lookup will become slower. This means in general, both the containment predicate and set intersection will perform worse than the non-duplicate version. The specifics of when each implementation is better than the other is very dependent on the usecase. The generalization here is that many insertion with few containment checks make duplicate good, few insertions with many containment checks make non-duplicate good.
* Exercise 2.61
** Prompt
We have now looked at the ordered list representation of the set, and how it could make intersection operations linear due to the invariant of the representation being sorted, as we no longer have to search the entire list again everytime. This is very akin to merge sort. In fact, merge sort might be easier to implement on lisp than other sorting algorithms.

Now the goal of this exercise is to implement ~adjoin-set~ and show how using ordering can, on average, make the implementation take half the steps of the unordered representation.
** Solution

#+name: ordered-list-set-base
#+begin_src racket :exports code
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(= x (car set)) true]
    [(< x (car set)) false]
    [else (element-of-set? x (cdr set))]))

(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ([x1 (car set1)]
            [x2 (car set2)])
        (cond
          [(= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2)))]
          [(< x1 x2) (intersection-set (cdr set1) set2)]
          [else (intersection-set set1 (cdr set2))]))))
#+end_src

#+name: ordered-list-set-adjoin
#+begin_src racket :exports code
;; let's make an iterative closure to check if we have gotten to the thing.
;; This procedure can either return the original set or a newly sorted
;; set.
(define (adjoin-set x set)
  (cond [(null? set) (list x)]
        [(= x (car set)) set]
        [(< x (car set)) (cons x set)]
        [else (cons (car set) (adjoin-set x (cdr set)))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<ordered-list-set-base>>
<<ordered-list-set-adjoin>>
(define test-set (list 1 2 3 6 7 10))
test-set
(adjoin-set 5 test-set)
(adjoin-set 3 test-set)
(adjoin-set 100 test-set)
#+end_src

#+RESULTS:
: (1 2 3 6 7 10)
: (1 2 3 5 6 7 10)
: (1 2 3 6 7 10)
: (1 2 3 6 7 10 100)

I'll just describe how we took advantage of ordering to half the steps on average vs the unordered method. Because ordered, we can find out when the element does not exist in the set as we traverse from the first element to the last element by seeing when the value we are trying to add is lower than the element we are looking at, as all elements after that will be even larger. If we managed to get to the end of the list, we know that the element does not exist in the set, and that it is larger than all the other element, so we could place it there.
* Exercise 2.62
** Prompt
Make ~union-set~ for ordered list set.
** Solution

#+name: ordered-list-set-union
#+begin_src racket :exports code
(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [else
     (let ([x1 (car set1)]
           [x2 (car set2)]
           [rest1 (cdr set1)]
           [rest2 (cdr set2)])
       (cond
         [(= x1 x2) (cons x1 (union-set rest1 rest2))]
         [(< x1 x2) (cons x1 (cons x2 (union-set rest1 rest2)))]
         [(< x2 x1) (cons x2 (cons x1 (union-set rest1 rest2)))]))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<ordered-list-set-base>>
<<ordered-list-set-adjoin>>
<<ordered-list-set-union>>
(define test-set (list 1 2 3 6 7 10))
(define test-set2 (list 5 6 7 8 9 10))
test-set
test-set2
(union-set test-set test-set2)
#+end_src
