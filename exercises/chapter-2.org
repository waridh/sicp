#+title: Chapter 2
#+author: Bach
* Snippets
#+name: assertion-suite
#+begin_src racket :exports code
(define (assert-predicate pred-fn test-name value expected)
  (newline)
  (display (if (pred-fn value expected) "pass: " "fail: "))
  (display test-name)
  (display " value: ")
  (display value)
  (display " expected: ")
  (display expected))

(define (assert-eq test-name value expected)
  (assert-predicate eq? test-name value expected))
(define (assert-almost-eq test-name value expected)
  (define dx 0.000001)
  (define (almost-eq? left right)
    (< (abs (- left right)) dx))
  (assert-predicate almost-eq? test-name value expected))
#+end_src
* Exercise 2.1
Make an improved ~make-rat~ that will normalize the signage of the rational number.
#+begin_src racket :exports code
#lang sicp
(define (make-rat n d)
  (define (neg? nu de)
    (or (and (> nu 0) (< de 0)) (and (< nu 0) (> de 0))))
  (define (make-rat-aux nu de)
    (let ([g (gcd nu de)]) (cons (/ nu g) (/ de g))))
  (if (neg? n d)
      (make-rat-aux (- 0 (abs n)) (abs d))
      (make-rat-aux (abs n) (abs d))))

(make-rat -4 -12)
(make-rat 4 -12)
(make-rat -4 12)
(make-rat 4 12)
#+end_src

#+RESULTS:
: (1 . 3)
: (-1 . 3)
: (-1 . 3)
: (1 . 3)

* Exercise 2.2
Design a segment, a concept where two points make up a segment. While at it, also design points, a pair of numbers. Here are the required interface:

For segment:
- Constructor
  - ~make-segment~
- Selector
  - ~start-segment~
  - ~end-segment~

For points:
- Constructor
  - ~make-point~
- Selector
  - ~x-point~
  - ~y-point~

Domain procedure:
- ~midpoint-segment~

We're provided with a print function

#+name: exercise-2.2
#+begin_src racket :exports code
;; Point printing
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
;; Point interface
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))

;; Segment interface
;; make-segment is the segment constructor that takes in a start point and an
;; end point as parameters
(define (make-segment start end)
  (cons start end))
;; start-segment takes a segment as a parameter and returns the start of the
;; segment
(define (start-segment s)
  (car s))
;; end-segment takes in a segment as parameter and returns the end point of the
;; segment
(define (end-segment s)
  (cdr s))

;; midpoint-segment takes in a segment and returns the point that represents the
;; midpoint of that segment
(define (midpoint-segment s)
  (define (average a b)
    (/ (+ a b) 2))
  (let ([start (start-segment s)]
        [end (end-segment s)])
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))
#+end_src

Testing the written values now

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<exercise-2.2>>

;; Integration test
(define test-segment-1 (make-segment (make-point -1 -2) (make-point 3 4)))
(define test-mp-1 (midpoint-segment test-segment-1))
(print-point test-mp-1)
(assert-eq "test-mp-1-x=1" (x-point test-mp-1) 1)
(assert-eq "test-mp-1-y=1" (y-point test-mp-1) 1)
#+end_src

#+RESULTS:
:
: (1,1)
: pass: test-mp-1-x=1 value: 1 expected: 1
: pass: test-mp-1-y=1 value: 1 expected: 1
* Exercise 2.3
Implement a rectangle in a plane. Write a procedure that calculates the perimeter and area of the rectangle. Then implement a different representation for a rectangle. The goal of the exercise is to abstract properly such that the perimeter and area method does not need to change.

Assuming that we are designing this datastructure to follow the rules of a two dimensional rectangle, and that we really only care about the perimeter and the area of the rectange, we really just need to be able to retrieve the height and width of the rectangle. This will be our selectors. As for conforming to the rule of the rectangle, we could make the constructor always take in less parameters, and generate the other values to follow the rules of the rectangle.

#+name: rectangle-functions
#+begin_src racket :exports code
;; We are building the rectangle for this exercise such that the interface is
;; height and width
(define (area rectangle)
  (* (width rectangle) (height rectangle)))
(define (perimeter rectangle)
  (+ (* 2 (height rectangle)) (* 2 (width rectangle))))
#+end_src

#+RESULTS: rectangle-functions

** Implementation 1
We're not doing anything fancy in this first version. Constructor will take in bottom left corner and top right corner of the rectangle, and we will use that to represent a retangular object that has it's sides parallel to the two axis of the plane. Our selectors will just be for height and length.


#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
;; Takes two points as arguments. bottom-left is the bottom left point of a
;; rectange that is parallel to the plane axis. top-right is the top right
;; point of the same rectangle
(define (make-rectangle bottom-left top-right)
  (cons bottom-left top-right))
(define (width rectangle)
  (let ([left (x-point (car rectangle))]
        [right (x-point (cdr rectangle))])
    (abs (- left right))))
(define (height rectangle)
  (let ([top (y-point (cdr rectangle))]
        [bottom (y-point (car rectangle))])
    (abs (- top bottom))))

(assert-eq "area of (0,0) (2,2) is 4" (area (make-rectangle (make-point 0 0) (make-point 2 2))) 4)
(assert-eq "perimiter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-point -1 -1) (make-point 1 1)))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimiter of (-1, -1) (1, 1) is 8 value: 8 expected: 8
** Implementation 2
Let's allow orientation. This second version takes a segment representing the base of the rectangle and an integer representing the height of the rectangle

#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
;; Takes a segment representing the base and the height as arguments
(define (make-rectangle base height)
  (cons base height))
(define (width rectangle)
  (define (position-vector segment)
    (make-segment (make-point 0 0)
                  (make-point (- (x-point (end-segment segment)) (x-point (start-segment segment)))
                              (- (y-point (end-segment segment)) (y-point (start-segment segment))))))
  (define (square x)
    (* x x))
  (define (mag x y)
    (sqrt (+ (square x) (square y))))
  (let ([pos-tip (end-segment (position-vector (car rectangle)))])
    (mag (x-point pos-tip) (y-point pos-tip))))
(define (height rectangle)
  (cdr rectangle))

(assert-eq "area of (0,0) (2,2) is 4"
           (area (make-rectangle (make-segment (make-point 0 0) (make-point 0 2)) 2))
           4)
(assert-eq "perimeter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-segment (make-point -1 -1) (make-point 1 -1)) 2))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimeter of (-1, -1) (1, 1) is 8 value: 8 expected: 8


We can see that this second implementation is importing the same rectangle functions ~area~ and ~perimeter~, and we were able to achieve the same result.
* Exercise 2.4

With the new implementation of ~cons~ and ~car~ below, implement ~cdr~.

#+name: cons-override-1
#+begin_src racket :exports code
;; Makes a lambda that accepts a procedure and applies it on both members of
;; the pairs
(define (cons x y)
  (lambda (m) (m x y)))

;; Feeds a procedure that returns the first parameter
(define (car z)
  (z (lambda (p q) p)))

;; Our implementation just needs to return the second parameter
(define (cdr z)
  (z (lambda (p q) q)))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
<<cons-override-1>>
;; Takes two points as arguments. bottom-left is the bottom left point of a
;; rectange that is parallel to the plane axis. top-right is the top right
;; point of the same rectangle
(define (make-rectangle bottom-left top-right)
  (cons bottom-left top-right))
(define (width rectangle)
  (let ([left (x-point (car rectangle))]
        [right (x-point (cdr rectangle))])
    (abs (- left right))))
(define (height rectangle)
  (let ([top (y-point (cdr rectangle))]
        [bottom (y-point (car rectangle))])
    (abs (- top bottom))))

(assert-eq "area of (0,0) (2,2) is 4" (area (make-rectangle (make-point 0 0) (make-point 2 2))) 4)
(assert-eq "perimiter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-point -1 -1) (make-point 1 1)))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimiter of (-1, -1) (1, 1) is 8 value: 8 expected: 8

* Exercise 2.5
** Prompt
Show how we can hold a pair of non-negative integers using just numbers and arithmetic operations if we represent the pair ~a~ and ~b~ as \(2^{a}3^{b}\). Make the constructor and two selectors.
** Solution
2 and 3 have non-colliding powers. We could get ~a~ just by diving the representation by 2 until the remainder is no longer 0 and count the number of applications required to get there. As for the second element, we could do the same thing as the first element, but using 3 is the target value. This just means that we need to allow the accumulation procedure to take a mod parameter.

#+name: power-integer-pairs
#+begin_src racket :exports code
(define (pcons a b)
  (* (expt 2 a) (expt 3 b)))

;; We should move to using an iterative process instead of a recursive process
;; We should do the optimization using the sqaure property.
(define (count-div base val)
  (define (iter v acc)
    (if (= (remainder v base) 0)
        (iter (/ v base) (+ acc 1))
        acc))
  (iter val 0))

(define (pcar x)
  (count-div 2 x))
(define (pcdr x)
  (count-div 3 x))
#+end_src



#+begin_src racket :exports both :noweb yes
#lang sicp
<<power-integer-pairs>>
<<assertion-suite>>

(assert-eq "pcar (2, 4) = 2" (pcar (pcons 2 4)) 2)
(assert-eq "pcdr (2, 4) = 4" (pcdr (pcons 2 4)) 4)
#+end_src

#+RESULTS:
:
: pass: pcar (2, 4) = 2 value: 2 expected: 2
: pass: pcdr (2, 4) = 4 value: 4 expected: 4
* Exercise 2.6
We're doing Church encoding, but instead of the lamda calculus representation, it is scheme. I think this is one of the few cases where scheme is less readable. Luckily, this question only ask that we show the representation of one, two, and the actual definition of the addition procedure.

#+begin_src racket :exports code
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

Let's find one using ~add-1~ on ~zero~.

#+begin_src racket :exports code
(add-1 zero)
(add-1 (lambda (f) (lambda (x) x)))
(lambda (f) (lambda (x) (f ((lambda (f) (lambda (x) x))) f) x))
(lambda (f) (lambda (x) (f ((lambda (x) x) x) )))
(lambda (f) (lambda (x) (f x)))

(define one (lambda (f) (lambda (x) (f x))))
#+end_src

From doing this, we see that ~one~ is represented as a function that takes in a function ~f~ and create a new function that applies ~f~ once on the parameter.

#+begin_src racket :exports code
(add-1 one)
(add-1 (lambda (f) (lambda (x) (f x))))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (f (f x))))

(define two (lambda (f) (lambda (x) (f (f x)))))
#+end_src

Encoding for two is a higher order procedure that takes in a procedure ~f~ and produces a procedure that applies ~f~ twice on a parameter.

We can continue this line of reasoning to say that Church encoding of a non-negative integer ~n~ is a higher order procedure that takes in a procedure ~f~ and produces a procedure that applies ~f~ ~n~ times. Now to define addition in Scheme.

#+begin_src racket :exports code
(define (add a b)
  (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+end_src

To prove that this addition procedure works, we'll evaluate this with ~a~ as ~one~ and ~b~ as ~two~, and we should see that it evaluates to ~(lambda (f) (lambda (x) (f (f (f x)))))~.

#+begin_src racket :exports code
(add one two)
(add (lambda (f) (lambda (x) (f x))) (lambda (f) (lambda (x) (f (f x)))))
(lambda (f)
  (lambda (x) (((lambda (f) (lambda (x) (f x))) f) (((lambda (f) (lambda (x) (f (f x)))) f) x))))
(lambda (f) (lambda (x) ((lambda (x) (f x)) ((lambda (x) (f (f x))) x))))
(lambda (f) (lambda (x) ((lambda (x) (f x)) (f (f x)))))
(lambda (f) (lambda (x) (f (f (f x)))))
#+end_src

And as we expected, adding one and two gets us three.
* Exercise 2.7
Implement Alyssa P. Hacker's datastructure for interval operations.

#+name: interval-data-struct
#+begin_src racket :exports code
(define (make-interval a b) (cons a b))
(define (upper-bound z)
  (max (car z) (cdr z)))
(define (lower-bound z)
  (min (car z) (cdr z)))
#+end_src
* Exercise 2.8
** Prompt
Make a subtraction analogous for the interval datastructure.
** Solution
#+name: exercise-2.8
#+begin_src racket :exports code
(define (sub-interval a b)
  (make-interval (- (upper-bound a) (lower-bound b))
                 (- (lower-bound a) (upper-bound b))))
#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<interval-data-struct>>
<<exercise-2.8>>

(assert-eq "upper bound of [-2, 2] - [-8, 4] is 10"
           (upper-bound (sub-interval (make-interval 2 -2) (make-interval 4 -8)))
           10)
(assert-eq "upper bound of [-8, 4] - [-2, 2] is 6"
           (upper-bound (sub-interval (make-interval 4 -8) (make-interval 2 -2)))
           6)
#+end_src

#+RESULTS:
:
: pass: upper bound of [-2, 2] - [-8, 4] is 10 value: 10 expected: 10
: pass: upper bound of [-8, 4] - [-2, 2] is 6 value: 6 expected: 6
* Exercise 2.9
** Prompt
The width of an interval is half the difference of the upper and lower bound. For some arithmetic functions, the width of combining two variables is a function of only the width of the argument intervals while for some other arithmetic operations, this is not the case.

Show that for addition, the sum's interval is a function of only the widths of the argument intervals. After showing this, show that this is not the case for multiplication or division.
** Solution
Let's have a look at an example problem using addition.

\[\begin{aligned}
\text{let}~w = f_{w}(i) = \frac{u - l}{2},~ \text{where}~[l, u] = i \\
i_{3} = i_{1} + i_{2} = [l_{1} + l_{2}, u_{1} + u_{2} ] = [l_{3}, u_{3}] ~ \text{where}~ l_{3} = l_{1} + l_{2}, u_{3} = u_{1} + u_{2} \\
  \text{We will show that } w_{3} = w_{1} + w_{2} = f_{w}(i_{3}) \\
  f_{w}(i_{3}) = \frac{l_{3} + u_{3}}{2} = \frac{(l_{1} + u_{1}) + (l_{2} + u_{2}) }{2} \\
  \text{Knowing that}~ w_{1} = \frac{l_{1} + u_{1}}{2}, w_{2} = \frac{l_{2} + u_{2}}{2} \\
  f_{w}(i_{3}) = w_{1} + w_{2}
\end{aligned}\]

Now we will show that this is not the case for multiplication.

\[\begin{aligned}
		\text{We just need to show one case where the result width is not a function of the input width} \\
		i_{1} = \left[ 8, 10 \right], i_{2} = \left[ 2, 5 \right]                                        \\
		w_{1} = 1, w_{2} = 1.5; w_{1} \times w_{2} = 1.5                                                 \\
		i_{3} = i_{1} * i_{2} = \left[ 16, 50 \right]                                                    \\
		w_{3} = 17 != w_{1} \times w_{2}
	\end{aligned}\]

Did not think that it was necessary to show the same property for division since division is just a multiplication against a reciprocal.
* Exercise 2.10
** Prompt
Thanks to Ben Bitdiddle, we realize that we should be treating a division against an interval that spans zero as an error. Modify the procedure the Alyssa P. Hacker wrote to do this error handling.
** Solution
#+name: alyssa-multiplication
#+begin_src racket :exports code
(define (mul-interval x y)
  (let ([p1 (* (lower-bound x) (lower-bound y))]
        [p2 (* (lower-bound x) (upper-bound y))]
        [p3 (* (upper-bound x) (lower-bound y))]
        [p4 (* (upper-bound x) (upper-bound y))])
    (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4))))
#+end_src

#+name: exercise-2.10
#+begin_src racket :exports code
(define (div-interval x y)
  (define (zero-interval? a)
    (and (< (lower-bound a) 0) (> (upper-bound a) 0)))
  (let ([reciprocal-y (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))])
    (if (zero-interval? reciprocal-y)
        (error "cannot divide by zero")
        (mul-interval x reciprocal-y))))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<interval-data-struct>>
<<alyssa-multiplication>>
<<exercise-2.10>>

(assert-almost-eq "lower [8, 10] / [2, 4] is 2" (lower-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 2.0)
(assert-almost-eq "upper [8, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 5.0)

;; The following line should throw an error
(div-interval (make-interval 8 9) (make-interval -1 0.1))
#+end_src

#+RESULTS:
:
: pass: lower [8, 10] / [2, 4] is 2 value: 2.0 expected: 2.0
: pass: upper [8, 10] / [2, 4] is 5 value: 5.0 expected: 5.0

We see that the procedure will operate normally when not dividing by zero, and thrown an error if it does divide by an interval that covers zero.
* Exercise 2.11
** Prompt
We can make the ~mul-interval~ procedure use less multiplication operations by breaking it down into 9 cases. Only one of these cases will require more than two multiplication. Implementate this improved version of ~mul-interval~.

** Solution
#+name: exercise-2.11
#+begin_src racket :exports code
(define (mul-interval x y)
  (let ([a (lower-bound x)]
        [b (upper-bound x)]
        [c (lower-bound y)]
        [d (upper-bound y)])
    (cond
      [(and (>= a 0) (>= b 0) (>= c 0) (>= d 0)) (make-interval (* a c) (* b d))]
      [(and (< a 0) (>= b 0) (>= c 0) (>= d 0)) (make-interval (* a d) (* b d))]
      [(and (>= a 0) (>= b 0) (< c 0) (>= d 0)) (make-interval (* c b) (* b d))]
      [(and (< a 0) (< b 0) (>= c 0) (>= d 0)) (make-interval (* a d) (* b c))]
      [(and (>= a 0) (>= b 0) (< c 0) (< d 0)) (make-interval (* b c) (* a d))]
      [(and (< a 0) (>= b 0) (< c 0) (>= d 0))
       (make-interval (min (* a d) (* c b)) (max (* a c) (* b d)))]
      [(and (< a 0) (>= b 0) (< c 0) (< d 0)) (make-interval (* b c) (* a c))]
      [(and (< a 0) (< b 0) (< c 0) (>= d 0)) (make-interval (* a d) (* a c))]
      [(and (< a 0) (< b 0) (< c 0) (< d 0)) (make-interval (* b d) (* a c))])))
#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<exercise-2.11>>
<<assertion-suite>>
<<interval-data-struct>>
<<exercise-2.10>>

(assert-almost-eq "lower [8, 10] / [2, 4] is 2" (lower-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 2.0)
(assert-almost-eq "upper [8, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 5.0)
(assert-almost-eq "lower [-10, 10] / [2, 4] is -5" (lower-bound (div-interval (make-interval -10 10) (make-interval 2 4))) -5)
(assert-almost-eq "upper [-10, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval -10 10) (make-interval 2 4))) 5)
(assert-almost-eq "lower [-10, 10] * [-20, 14] is -200" (lower-bound (mul-interval (make-interval -10 10) (make-interval -20 14))) -200)
(assert-almost-eq "upper [-10, 10] * [-20, 14] is 200" (upper-bound (mul-interval (make-interval -10 10) (make-interval -20 14))) 200)

;; The following line should throw an error
(div-interval (make-interval 8 9) (make-interval -1 0.1))
#+end_src

#+RESULTS:
:
: pass: lower [8, 10] / [2, 4] is 2 value: 2.0 expected: 2.0
: pass: upper [8, 10] / [2, 4] is 5 value: 5.0 expected: 5.0
: pass: lower [-10, 10] / [2, 4] is -5 value: -5.0 expected: -5
: pass: upper [-10, 10] / [2, 4] is 5 value: 5.0 expected: 5
: pass: lower [-10, 10] / [2, 4] is -5 value: -200 expected: -200
: pass: upper [-10, 10] / [2, 4] is 5 value: 200 expected: 200
