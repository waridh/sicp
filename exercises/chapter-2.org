#+title: Chapter 2
#+author: Bach
* Snippets
#+name: assertion-suite
#+begin_src racket :exports code
(define (assert-predicate pred-fn test-name value expected)
  (display (if (pred-fn value expected) "pass: " "fail: "))
  (display test-name)
  (display " value: ")
  (display value)
  (display " expected: ")
  (display expected)
  (newline))

(define (assert-eq test-name value expected)
  (assert-predicate equal? test-name value expected))
(define (assert-almost-eq test-name value expected)
  (define dx 0.0001)
  (define (almost-eq? left right)
    (< (abs (- left right)) dx))
  (assert-predicate almost-eq? test-name value expected))
#+end_src

#+name: functional-interface
#+begin_src racket :exports code
;; com-proc is the combination procedure where the acc is the left arg, and the
;; next ele in the list is the right arg
(define (left-fold com-proc initial iterable)
  (define (iter acc tail)
    (if (null? tail)
        acc
        (iter (com-proc acc (car tail)) (cdr tail))))
  (iter initial iterable))

(define (right-fold com-proc initial iterable)
  (if (null? iterable)
      initial
      (com-proc (right-fold com-proc initial (cdr iterable)) (car iterable))))
(define (reverse itera)
  (define (reverse-iter acc tail)
    (if (null? tail)
        acc
        (reverse-iter (cons (car tail) acc) (cdr tail))))
  (reverse-iter '() itera))

;; Apply a procedure on all elements of a list
(define (map proc iterable)
  (define (iter acc tail)
    (if (null? tail)
        acc
        (iter (cons (proc (car tail)) acc) (cdr tail))))
  (reverse (iter '() iterable)))

;; Filter only returns the elements that causes the predicate to turn true
(define (filter predicate iterable)
  (define (iter acc tail)
    (cond
      [(null? tail) acc]
      [(predicate (car tail)) (iter (cons (car tail) acc) (cdr tail))]
      [else (iter acc (cdr tail))]))
  (reverse (iter '() iterable)))

;; This procedure checks if the target value is contained inside the sequence
;; Currently only comparing numerical contents
(define (contain? target seq)
  (right-fold (lambda (acc ele)
                (cond
                  [(equal? ele target) true]
                  [else acc]))
              false
              seq))
#+end_src
* Exercise 2.1
Make an improved ~make-rat~ that will normalize the signage of the rational number.
#+begin_src racket :exports code
#lang sicp
(define (make-rat n d)
  (define (neg? nu de)
    (or (and (> nu 0) (< de 0)) (and (< nu 0) (> de 0))))
  (define (make-rat-aux nu de)
    (let ([g (gcd nu de)]) (cons (/ nu g) (/ de g))))
  (if (neg? n d)
      (make-rat-aux (- 0 (abs n)) (abs d))
      (make-rat-aux (abs n) (abs d))))

(make-rat -4 -12)
(make-rat 4 -12)
(make-rat -4 12)
(make-rat 4 12)
#+end_src

#+RESULTS:
: (1 . 3)
: (-1 . 3)
: (-1 . 3)
: (1 . 3)

* Exercise 2.2
Design a segment, a concept where two points make up a segment. While at it, also design points, a pair of numbers. Here are the required interface:

For segment:
- Constructor
  - ~make-segment~
- Selector
  - ~start-segment~
  - ~end-segment~

For points:
- Constructor
  - ~make-point~
- Selector
  - ~x-point~
  - ~y-point~

Domain procedure:
- ~midpoint-segment~

We're provided with a print function

#+name: exercise-2.2
#+begin_src racket :exports code
;; Point printing
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
;; Point interface
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))

;; Segment interface
;; make-segment is the segment constructor that takes in a start point and an
;; end point as parameters
(define (make-segment start end)
  (cons start end))
;; start-segment takes a segment as a parameter and returns the start of the
;; segment
(define (start-segment s)
  (car s))
;; end-segment takes in a segment as parameter and returns the end point of the
;; segment
(define (end-segment s)
  (cdr s))

;; midpoint-segment takes in a segment and returns the point that represents the
;; midpoint of that segment
(define (midpoint-segment s)
  (define (average a b)
    (/ (+ a b) 2))
  (let ([start (start-segment s)]
        [end (end-segment s)])
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))
#+end_src

Testing the written values now

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<exercise-2.2>>

;; Integration test
(define test-segment-1 (make-segment (make-point -1 -2) (make-point 3 4)))
(define test-mp-1 (midpoint-segment test-segment-1))
(print-point test-mp-1)
(assert-eq "test-mp-1-x=1" (x-point test-mp-1) 1)
(assert-eq "test-mp-1-y=1" (y-point test-mp-1) 1)
#+end_src

#+RESULTS:
:
: (1,1)
: pass: test-mp-1-x=1 value: 1 expected: 1
: pass: test-mp-1-y=1 value: 1 expected: 1
* Exercise 2.3
Implement a rectangle in a plane. Write a procedure that calculates the perimeter and area of the rectangle. Then implement a different representation for a rectangle. The goal of the exercise is to abstract properly such that the perimeter and area method does not need to change.

Assuming that we are designing this datastructure to follow the rules of a two dimensional rectangle, and that we really only care about the perimeter and the area of the rectange, we really just need to be able to retrieve the height and width of the rectangle. This will be our selectors. As for conforming to the rule of the rectangle, we could make the constructor always take in less parameters, and generate the other values to follow the rules of the rectangle.

#+name: rectangle-functions
#+begin_src racket :exports code
;; We are building the rectangle for this exercise such that the interface is
;; height and width
(define (area rectangle)
  (* (width rectangle) (height rectangle)))
(define (perimeter rectangle)
  (+ (* 2 (height rectangle)) (* 2 (width rectangle))))
#+end_src

#+RESULTS: rectangle-functions

** Implementation 1
We're not doing anything fancy in this first version. Constructor will take in bottom left corner and top right corner of the rectangle, and we will use that to represent a retangular object that has it's sides parallel to the two axis of the plane. Our selectors will just be for height and length.


#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
;; Takes two points as arguments. bottom-left is the bottom left point of a
;; rectange that is parallel to the plane axis. top-right is the top right
;; point of the same rectangle
(define (make-rectangle bottom-left top-right)
  (cons bottom-left top-right))
(define (width rectangle)
  (let ([left (x-point (car rectangle))]
        [right (x-point (cdr rectangle))])
    (abs (- left right))))
(define (height rectangle)
  (let ([top (y-point (cdr rectangle))]
        [bottom (y-point (car rectangle))])
    (abs (- top bottom))))

(assert-eq "area of (0,0) (2,2) is 4" (area (make-rectangle (make-point 0 0) (make-point 2 2))) 4)
(assert-eq "perimiter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-point -1 -1) (make-point 1 1)))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimiter of (-1, -1) (1, 1) is 8 value: 8 expected: 8
** Implementation 2
Let's allow orientation. This second version takes a segment representing the base of the rectangle and an integer representing the height of the rectangle

#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
;; Takes a segment representing the base and the height as arguments
(define (make-rectangle base height)
  (cons base height))
(define (width rectangle)
  (define (position-vector segment)
    (make-segment (make-point 0 0)
                  (make-point (- (x-point (end-segment segment)) (x-point (start-segment segment)))
                              (- (y-point (end-segment segment)) (y-point (start-segment segment))))))
  (define (square x)
    (* x x))
  (define (mag x y)
    (sqrt (+ (square x) (square y))))
  (let ([pos-tip (end-segment (position-vector (car rectangle)))])
    (mag (x-point pos-tip) (y-point pos-tip))))
(define (height rectangle)
  (cdr rectangle))

(assert-eq "area of (0,0) (2,2) is 4"
           (area (make-rectangle (make-segment (make-point 0 0) (make-point 0 2)) 2))
           4)
(assert-eq "perimeter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-segment (make-point -1 -1) (make-point 1 -1)) 2))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimeter of (-1, -1) (1, 1) is 8 value: 8 expected: 8


We can see that this second implementation is importing the same rectangle functions ~area~ and ~perimeter~, and we were able to achieve the same result.
* Exercise 2.4

With the new implementation of ~cons~ and ~car~ below, implement ~cdr~.

#+name: cons-override-1
#+begin_src racket :exports code
;; Makes a lambda that accepts a procedure and applies it on both members of
;; the pairs
(define (cons x y)
  (lambda (m) (m x y)))

;; Feeds a procedure that returns the first parameter
(define (car z)
  (z (lambda (p q) p)))

;; Our implementation just needs to return the second parameter
(define (cdr z)
  (z (lambda (p q) q)))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
;; Begin by importing exercise 2.2 and the interface
<<exercise-2.2>>
<<rectangle-functions>>
<<assertion-suite>>
<<cons-override-1>>
;; Takes two points as arguments. bottom-left is the bottom left point of a
;; rectange that is parallel to the plane axis. top-right is the top right
;; point of the same rectangle
(define (make-rectangle bottom-left top-right)
  (cons bottom-left top-right))
(define (width rectangle)
  (let ([left (x-point (car rectangle))]
        [right (x-point (cdr rectangle))])
    (abs (- left right))))
(define (height rectangle)
  (let ([top (y-point (cdr rectangle))]
        [bottom (y-point (car rectangle))])
    (abs (- top bottom))))

(assert-eq "area of (0,0) (2,2) is 4" (area (make-rectangle (make-point 0 0) (make-point 2 2))) 4)
(assert-eq "perimiter of (-1, -1) (1, 1) is 8"
           (perimeter (make-rectangle (make-point -1 -1) (make-point 1 1)))
           8)
#+end_src

#+RESULTS:
:
: pass: area of (0,0) (2,2) is 4 value: 4 expected: 4
: pass: perimiter of (-1, -1) (1, 1) is 8 value: 8 expected: 8

* Exercise 2.5
** Prompt
Show how we can hold a pair of non-negative integers using just numbers and arithmetic operations if we represent the pair ~a~ and ~b~ as \(2^{a}3^{b}\). Make the constructor and two selectors.
** Solution
2 and 3 have non-colliding powers. We could get ~a~ just by diving the representation by 2 until the remainder is no longer 0 and count the number of applications required to get there. As for the second element, we could do the same thing as the first element, but using 3 is the target value. This just means that we need to allow the accumulation procedure to take a mod parameter.

#+name: power-integer-pairs
#+begin_src racket :exports code
(define (pcons a b)
  (* (expt 2 a) (expt 3 b)))

;; We should move to using an iterative process instead of a recursive process
;; We should do the optimization using the sqaure property.
(define (count-div base val)
  (define (iter v acc)
    (if (= (remainder v base) 0)
        (iter (/ v base) (+ acc 1))
        acc))
  (iter val 0))

(define (pcar x)
  (count-div 2 x))
(define (pcdr x)
  (count-div 3 x))
#+end_src



#+begin_src racket :exports both :noweb yes
#lang sicp
<<power-integer-pairs>>
<<assertion-suite>>

(assert-eq "pcar (2, 4) = 2" (pcar (pcons 2 4)) 2)
(assert-eq "pcdr (2, 4) = 4" (pcdr (pcons 2 4)) 4)
#+end_src

#+RESULTS:
:
: pass: pcar (2, 4) = 2 value: 2 expected: 2
: pass: pcdr (2, 4) = 4 value: 4 expected: 4
* Exercise 2.6
We're doing Church encoding, but instead of the lamda calculus representation, it is scheme. I think this is one of the few cases where scheme is less readable. Luckily, this question only ask that we show the representation of one, two, and the actual definition of the addition procedure.

#+begin_src racket :exports code
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

Let's find one using ~add-1~ on ~zero~.

#+begin_src racket :exports code
(add-1 zero)
(add-1 (lambda (f) (lambda (x) x)))
(lambda (f) (lambda (x) (f ((lambda (f) (lambda (x) x))) f) x))
(lambda (f) (lambda (x) (f ((lambda (x) x) x) )))
(lambda (f) (lambda (x) (f x)))

(define one (lambda (f) (lambda (x) (f x))))
#+end_src

From doing this, we see that ~one~ is represented as a function that takes in a function ~f~ and create a new function that applies ~f~ once on the parameter.

#+begin_src racket :exports code
(add-1 one)
(add-1 (lambda (f) (lambda (x) (f x))))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (f (f x))))

(define two (lambda (f) (lambda (x) (f (f x)))))
#+end_src

Encoding for two is a higher order procedure that takes in a procedure ~f~ and produces a procedure that applies ~f~ twice on a parameter.

We can continue this line of reasoning to say that Church encoding of a non-negative integer ~n~ is a higher order procedure that takes in a procedure ~f~ and produces a procedure that applies ~f~ ~n~ times. Now to define addition in Scheme.

#+begin_src racket :exports code
(define (add a b)
  (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+end_src

To prove that this addition procedure works, we'll evaluate this with ~a~ as ~one~ and ~b~ as ~two~, and we should see that it evaluates to ~(lambda (f) (lambda (x) (f (f (f x)))))~.

#+begin_src racket :exports code
(add one two)
(add (lambda (f) (lambda (x) (f x))) (lambda (f) (lambda (x) (f (f x)))))
(lambda (f)
  (lambda (x) (((lambda (f) (lambda (x) (f x))) f) (((lambda (f) (lambda (x) (f (f x)))) f) x))))
(lambda (f) (lambda (x) ((lambda (x) (f x)) ((lambda (x) (f (f x))) x))))
(lambda (f) (lambda (x) ((lambda (x) (f x)) (f (f x)))))
(lambda (f) (lambda (x) (f (f (f x)))))
#+end_src

And as we expected, adding one and two gets us three.
* Exercise 2.7
Implement Alyssa P. Hacker's datastructure for interval operations.

#+name: interval-data-struct
#+begin_src racket :exports code
(define (make-interval a b) (cons a b))
(define (upper-bound z)
  (max (car z) (cdr z)))
(define (lower-bound z)
  (min (car z) (cdr z)))
#+end_src
* Exercise 2.8
** Prompt
Make a subtraction analogous for the interval datastructure.
** Solution
#+name: exercise-2.8
#+begin_src racket :exports code
(define (sub-interval a b)
  (make-interval (- (upper-bound a) (lower-bound b))
                 (- (lower-bound a) (upper-bound b))))
(define (add-interval a b)
  (make-interval (+ (upper-bound a) (upper-bound b))
                 (+ (lower-bound a) (lower-bound b))))

#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<interval-data-struct>>
<<exercise-2.8>>

(assert-eq "upper bound of [-2, 2] - [-8, 4] is 10"
           (upper-bound (sub-interval (make-interval 2 -2) (make-interval 4 -8)))
           10)
(assert-eq "upper bound of [-8, 4] - [-2, 2] is 6"
           (upper-bound (sub-interval (make-interval 4 -8) (make-interval 2 -2)))
           6)
#+end_src

#+RESULTS:
:
: pass: upper bound of [-2, 2] - [-8, 4] is 10 value: 10 expected: 10
: pass: upper bound of [-8, 4] - [-2, 2] is 6 value: 6 expected: 6
* Exercise 2.9
** Prompt
The width of an interval is half the difference of the upper and lower bound. For some arithmetic functions, the width of combining two variables is a function of only the width of the argument intervals while for some other arithmetic operations, this is not the case.

Show that for addition, the sum's interval is a function of only the widths of the argument intervals. After showing this, show that this is not the case for multiplication or division.
** Solution
Let's have a look at an example problem using addition.

\[\begin{aligned}
\text{let}~w = f_{w}(i) = \frac{u - l}{2},~ \text{where}~[l, u] = i \\
i_{3} = i_{1} + i_{2} = [l_{1} + l_{2}, u_{1} + u_{2} ] = [l_{3}, u_{3}] ~ \text{where}~ l_{3} = l_{1} + l_{2}, u_{3} = u_{1} + u_{2} \\
  \text{We will show that } w_{3} = w_{1} + w_{2} = f_{w}(i_{3}) \\
  f_{w}(i_{3}) = \frac{l_{3} + u_{3}}{2} = \frac{(l_{1} + u_{1}) + (l_{2} + u_{2}) }{2} \\
  \text{Knowing that}~ w_{1} = \frac{l_{1} + u_{1}}{2}, w_{2} = \frac{l_{2} + u_{2}}{2} \\
  f_{w}(i_{3}) = w_{1} + w_{2}
\end{aligned}\]

Now we will show that this is not the case for multiplication.

\[\begin{aligned}
		\text{We just need to show one case where the result width is not a function of the input width} \\
		i_{1} = \left[ 8, 10 \right], i_{2} = \left[ 2, 5 \right]                                        \\
		w_{1} = 1, w_{2} = 1.5; w_{1} \times w_{2} = 1.5                                                 \\
		i_{3} = i_{1} * i_{2} = \left[ 16, 50 \right]                                                    \\
		w_{3} = 17 != w_{1} \times w_{2}
	\end{aligned}\]

Did not think that it was necessary to show the same property for division since division is just a multiplication against a reciprocal.
* Exercise 2.10
** Prompt
Thanks to Ben Bitdiddle, we realize that we should be treating a division against an interval that spans zero as an error. Modify the procedure the Alyssa P. Hacker wrote to do this error handling.
** Solution
#+name: alyssa-multiplication
#+begin_src racket :exports code
(define (mul-interval x y)
  (let ([p1 (* (lower-bound x) (lower-bound y))]
        [p2 (* (lower-bound x) (upper-bound y))]
        [p3 (* (upper-bound x) (lower-bound y))]
        [p4 (* (upper-bound x) (upper-bound y))])
    (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4))))
#+end_src

#+name: exercise-2.10
#+begin_src racket :exports code
(define (div-interval x y)
  (define (zero-interval? a)
    (and (< (lower-bound a) 0) (> (upper-bound a) 0)))
  (let ([reciprocal-y (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))])
    (if (zero-interval? reciprocal-y)
        (error "cannot divide by zero")
        (mul-interval x reciprocal-y))))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<interval-data-struct>>
<<alyssa-multiplication>>
<<exercise-2.10>>

(assert-almost-eq "lower [8, 10] / [2, 4] is 2" (lower-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 2.0)
(assert-almost-eq "upper [8, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 5.0)

;; The following line should throw an error
(div-interval (make-interval 8 9) (make-interval -1 0.1))
#+end_src

#+RESULTS:
:
: pass: lower [8, 10] / [2, 4] is 2 value: 2.0 expected: 2.0
: pass: upper [8, 10] / [2, 4] is 5 value: 5.0 expected: 5.0

We see that the procedure will operate normally when not dividing by zero, and thrown an error if it does divide by an interval that covers zero.
* Exercise 2.11
** Prompt
We can make the ~mul-interval~ procedure use less multiplication operations by breaking it down into 9 cases. Only one of these cases will require more than two multiplication. Implementate this improved version of ~mul-interval~.

** Solution
#+name: exercise-2.11
#+begin_src racket :exports code
(define (mul-interval x y)
  (let ([a (lower-bound x)]
        [b (upper-bound x)]
        [c (lower-bound y)]
        [d (upper-bound y)])
    (cond
      [(and (>= a 0) (>= b 0) (>= c 0) (>= d 0)) (make-interval (* a c) (* b d))]
      [(and (< a 0) (>= b 0) (>= c 0) (>= d 0)) (make-interval (* a d) (* b d))]
      [(and (>= a 0) (>= b 0) (< c 0) (>= d 0)) (make-interval (* c b) (* b d))]
      [(and (< a 0) (< b 0) (>= c 0) (>= d 0)) (make-interval (* a d) (* b c))]
      [(and (>= a 0) (>= b 0) (< c 0) (< d 0)) (make-interval (* b c) (* a d))]
      [(and (< a 0) (>= b 0) (< c 0) (>= d 0))
       (make-interval (min (* a d) (* c b)) (max (* a c) (* b d)))]
      [(and (< a 0) (>= b 0) (< c 0) (< d 0)) (make-interval (* b c) (* a c))]
      [(and (< a 0) (< b 0) (< c 0) (>= d 0)) (make-interval (* a d) (* a c))]
      [(and (< a 0) (< b 0) (< c 0) (< d 0)) (make-interval (* b d) (* a c))])))
#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<exercise-2.11>>
<<assertion-suite>>
<<interval-data-struct>>
<<exercise-2.10>>

(assert-almost-eq "lower [8, 10] / [2, 4] is 2" (lower-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 2.0)
(assert-almost-eq "upper [8, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval 8 10) (make-interval 2 4))) 5.0)
(assert-almost-eq "lower [-10, 10] / [2, 4] is -5" (lower-bound (div-interval (make-interval -10 10) (make-interval 2 4))) -5)
(assert-almost-eq "upper [-10, 10] / [2, 4] is 5" (upper-bound (div-interval (make-interval -10 10) (make-interval 2 4))) 5)
(assert-almost-eq "lower [-10, 10] * [-20, 14] is -200" (lower-bound (mul-interval (make-interval -10 10) (make-interval -20 14))) -200)
(assert-almost-eq "upper [-10, 10] * [-20, 14] is 200" (upper-bound (mul-interval (make-interval -10 10) (make-interval -20 14))) 200)

;; The following line should throw an error
(div-interval (make-interval 8 9) (make-interval -1 0.1))
#+end_src

#+RESULTS:
:
: pass: lower [8, 10] / [2, 4] is 2 value: 2.0 expected: 2.0
: pass: upper [8, 10] / [2, 4] is 5 value: 5.0 expected: 5.0
: pass: lower [-10, 10] / [2, 4] is -5 value: -5.0 expected: -5
: pass: upper [-10, 10] / [2, 4] is 5 value: 5.0 expected: 5
: pass: lower [-10, 10] * [-20, 14] is -200 value: -200 expected: -200
: pass: upper [-10, 10] * [-20, 14] is 200 value: 200 expected: 200
* Exercise 2.12
** Prompt
Alyssa made an alternate constructor and selectors that represents the following \(c \pm w\). Now make a version that does percentage tolerance in the following form. \(c \pm p \%\). Also provide the percent selector.
** Solution
#+name: center-width-rep
#+begin_src racket :exports code
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (center x)
  (/ (+ (upper-bound x) (lower-bound x)) 2))
(define (width x)
  (/ (- (upper-bound x) (lower-bound x)) 2))
#+end_src

#+name: exercise-2.12
#+begin_src racket :exports code
(define (percent i)
  (* 100 (/ (width i) (abs (center i)))))

(define (make-center-percent c p)
  (let ([width (* (abs c) (/ p 100))]) (make-center-width c width)))
#+end_src
** Testing

#+begin_src racket :exports both :noweb yes
#lang sicp
<<interval-data-struct>>
<<center-width-rep>>
<<exercise-2.12>>
<<assertion-suite>>

(assert-eq "construct and then assert" (percent (make-center-percent 10 10)) 10)
#+end_src

#+RESULTS:
:
: pass: construct and then assert value: 10 expected: 10
* Exercise 2.13
** Prompt
Show that under small percentage tolerance, there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors.
** Solution
By working on exercise 2.14, we know exactly what this approximation is. At small percentage, the percentage tolerance of the product is equal to the sum of the percentage tolerance of the operands. At larger values, this breaks down.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<interval-data-struct>>
<<center-width-rep>>
<<exercise-2.12>>
<<exercise-2.11>>
<<exercise-2.10>>
<<exercise-2.8>>
<<assertion-suite>>
(define a (make-center-percent 80 0.5))
(define b (make-center-percent 210 0.8))

(assert-almost-eq "the percentage tolerance of a * b should be very close to percent tolerance a + percent tolerance b" (percent (mul-interval a b)) (+ (percent a) (percent b)))
#+end_src

#+RESULTS:
:
: pass: the percentage tolerance of a * b should be very close to percent tolerance a + percent tolerance b value: 1.2999480020799254 expected: 1.3000000000000105

* Exercise 2.14
** Prompt
The previous implementation of interval was flawed in that it was unable to give the same answer in two equivalent but different equation for the parallel resistor. Run some experiment and investigate why this issue is occurring.
** Investigation
#+begin_src racket :exports code
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2) (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ([one (make-interval 1 1)])
    (div-interva
#+end_src
*** Experiments
#+begin_src racket :exports both :noweb yes
#lang sicp
<<interval-data-struct>>
<<center-width-rep>>
<<exercise-2.12>>
<<exercise-2.11>>
<<exercise-2.10>>
<<exercise-2.8>>
(define a (make-center-percent 80 0.5))
(define b (make-center-percent 210 0.8))
(define a-prime (make-center-percent 80 40))
(define b-prime (make-center-percent 210 60))
(define c (make-center-percent 80 0.7))

(center (div-interval a a))
(percent (div-interval a a))
(center (div-interval a b))
(percent (div-interval a b))
(newline)
(display "210 +- 8% / 80 +- 5%")
(newline)
(center (div-interval a-prime b-prime))
(percent (div-interval a-prime b-prime))

(center (div-interval b a))
(percent (div-interval b a))
(center (div-interval c c))
(percent (div-interval c c))
(center (add-interval c c))
(percent (add-interval c c))
(center (add-interval c a))
(percent (add-interval c a))
(center (add-interval b a))
(percent (add-interval b a))
(center (sub-interval b a))
(percent (sub-interval b a))
(newline)
(display "210 +- 0.8% - 80 +- 0.7%")
(newline)
(center (sub-interval b c))
(percent (sub-interval b c))
(center (mul-interval c c))
(percent (mul-interval c c))
#+end_src

#+RESULTS:
#+begin_example
1.000050001250031
0.9999750006249956
0.38099200253578136
1.2999480020799312

210 +- 8% / 80 +- 5%
0.738095238095238
80.64516129032259
2.6251706292657317
1.299948002079925
1.0000980048022352
1.3999314033612358
160.0
0.7000000000000028
160.0
0.600000000000005
290.0
0.7172413793103589
130.0
1.6000000000000099

210 +- 0.8% - 80 +- 0.7%
130.0
1.7230769230769298
6400.3136
1.399931403361241
#+end_example

Interesting. In the previous implementation of the interval class, addition will cause the sum's percent to be the weighted average of the two operands. Multiplication and division will cause the product and quotient to have a percent tolerance that is the sum of the operands. Subtraction will see the tolerance increase due to multiple factors.
* Exercise 2.15
** Prompt
Eva Lu Ator says that since different intervals are calculated when using different but algebraically equivalent expressions. Eva then claims that using forms that do not repeat the same uncertain variable would produce a tighter output uncertainty, and that therefore, this is the better method. Is she correct? Why?
** Solution
Problem was that the implementation is not consistent between different equivalent algebraic problems. There should not be a better method, but Eva is correct, using this implementation, we should operate on the unique variables with uncertainty once. Specifically, what seems to be happening is that repeated operations seem to assume that there are more than one uncertain variables.
* Exercise 2.16
** Prompt
Explain why different equivalent algebraic expressions will result in different result interval. Can we devise a package that can solve this problem? Given with warning that this is a difficult task.
** Solution
I will not be attempting to build my own library for intervals, as I have things to be and placed to do. As stated in the 2.15 solution, if the same interval object is used in multiple placed, it eventually propagates its uncertainty back on itself as if they are not the same value. I am choosing to not continue to dwell on this topic, as I have places to do, and things to be.
* Exercise 2.17
** Prompt
Implement a procedure called ~last-pair~ that will return the last element of a list.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (last-pair items)
  (cond ((null? items) items)
        ((null? (cdr items)) (car items))
        (else (last-pair (cdr items)))))
(last-pair (list 1 2 43 5 12 90 58))
#+end_src

#+RESULTS:
: 58
* Exercise 2.18
** Prompt
Define reverse that will reverse a list
** Solution
Will be solving this problem using an iterative process
#+begin_src racket :exports both
#lang sicp
(define (reverse items)
  (define (iter acc nav)
    (if (null? nav)
        acc
        (iter (cons (car nav) acc) (cdr nav))))
  (iter nil items)
  )

(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)
* Exercise 2.19
** Prompt
Upgrade change counting algorithm to take the coin value as parameter as well.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (cc amount coin-values)
  (define (except-first-denomination items)
    (cdr items))
  (define (first-denomination items)
    (car items))
  (define (no-more? items)
    (null? items))
  (cond
    [(= amount 0) 1]
    [(or (< amount 0) (no-more? coin-values)) 0]
    [else
     (+ (cc amount (except-first-denomination coin-values))
        (cc (- amount (first-denomination coin-values)) coin-values))]))

(define us-coin (list 25 10 50 5 1))
(define uk-coin (list 100 50 20 10 5 2 1 0.5))

(cc 100 us-coin)
#+end_src

#+RESULTS:
: 292

Here is the learning from doing this exercise. Yes we could have just done the low level list access procedures in the cc procedure, but by defining these external access methods, we are abstracting out the lower level implementation. It is up to us to think about whether our data structure would need an abstraction layer or not.

This is a combination problem, the order of the elements in the list do not matter. If this is incorrect, and you are looking at my github, please create an issue to address this.
* Exercise 2.20
** Prompt
We can see that there are procedures in scheme that can take in a dynamic number of arguments. Well, we're going to learn how to do that here.

We can achieve this by using ~define~ with a /dotted-tail/ notation.

#+begin_src racket :exports code
(define (f a b c . z) (<body>))
(define (g . x) (<body>))
#+end_src

Semantically, this is the same as doing the following in Python. Excuse me for not just explaining it in plain English.

#+begin_src python :exports code
def f(a, b, c, *z):
    ...

def g(*x):
    ...
#+end_src

Now build a procedure called same parity that takes in a dynamic number of input and then only return the content of the input that matches the parity of the input.

** Solution
#+begin_src racket :exports both
#lang sicp
(define (same-parity x . y)
  (define (choose-predicate a)
    (if (even? a) even? odd?))
  ;; I suppose that I really just made filter. Whoops.
  (define (choose predicate items)
    (cond ((null? items) nil)
          ((predicate (car items))
           (cons (car items) (choose predicate (cdr items))))
          (else (choose predicate (cdr items)))))
  (choose (choose-predicate x) (cons x y)))

(same-parity 1 2 3 4 5 6 7)
(same-parity 2 3 4 5 6 7)
#+end_src

#+RESULTS:
: (1 3 5 7)
: (2 4 6)
* Exercise 2.21
** Prompt
Make the two implementation of ~square-list~ that will take a list of numbers and return a list of the square of those numbers.
** Solution
*** First solution
First implementation without using ~map~.
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
(define (square-list items)
  (if (null? items)
      nil
      (cons (square (car items)) (square-list (cdr items)))))
(square-list (list 1 2 3 4))
#+end_src

#+RESULTS:
: (1 4 9 16)
*** Map solution
Yes, the map solution is cleaner, why wouldn't it be?
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
(define (square-list items)
  (map square items))
(square-list (list 1 2 3 4))
#+end_src

#+RESULTS:
: (1 4 9 16)
* Exercise 2.22
** Prompt
Louis Reasoner tried to make the ~square-list~ function and his implementation produces a list in reverse order. Why is this the case? Then he made a second version of the code that does not work. Listings available below.
#+caption: Reversed list output
#+begin_src racket :exports code
#lang sicp
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
#+end_src

#+caption: Just does not work
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things) (cons answer (square (car things))))))
  (iter items nil))

(square-list (list 1 2 3 4))
#+end_src

#+RESULTS:
: ((((() . 1) . 4) . 9) . 16)

** Solution
The first listing is reversed because our Scheme list implementation only allows for appending from one direction. This means the iterative algorithms that builds a list as it is traversing another one will build a reversed list.

The second listing does not work because we are no longer following the semantics of a Scheme list. The list is being built in reverse order.
* Exercise 2.23
** Prompt
We learn what a ~for-each~ is, which is just ~map~ but no return. Good for just doin(define (make-from-real-imag
         x y)
  (define (dispatch op)
    (cond [(eq? op 'real-part) x]
          [(eq? op 'imag-part) y]
          [(eq? op 'magnitude) (sqrt (+ (square x) (square y)))]
          [(eq? op 'angle) (atan y x)]
          [else (error "unknown op: MAKE-FROM-REAL-IMAG" op)]))
  dispatch)g side effects. Make an implementation of ~for-each~
** Solution
We have an implementation of ~for-each~ using the ~let~ procedure.
#+begin_src racket :exports both
#lang sicp
(define (for-each f items)
  (if (not (null? items))
      (let ([app (f (car items))]) (for-each f (cdr items)))))

(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
#+end_src

#+RESULTS:
:
: 57
: 321
: 88
* Exercise 2.24
** Prompt
Show the result of ~(list 1 (list 2 (list 3 4)))~ from the interpreter, followed by the box and pointer diagram and the tree diagram of the structure.
** Solution
For the first part, I will just let the interpreter do the printing for me.

#+begin_src racket :exports both
#lang sicp
(list 1 (list 2 (list 3 4)))
#+end_src

#+RESULTS:
: (1 (2 (3 4)))

Second and third part will be done using uml.

#+caption: Box and pointer diagram of the given structure.
#+begin_src plantuml :exports results :file ./images/exercise-2.24-1.png
@startuml
rectangle p00
rectangle p01
rectangle p10
rectangle p11
rectangle p20
rectangle p21

p00 --> 1
p00 -> p01
p01 --> p10

p10 --> 2
p10 -> p11
p11 --> p20

p20 --> 3
p20 -> p21
p21 --> 4

@enduml
#+end_src

#+caption: Box and pointer diagram of the given structure.
#+RESULTS:
[[file:./images/exercise-2.24-1.png]]

Box and pointer representation does hide the fact that the hierarchical structure is built on top of the Scheme pairs.

#+caption: Tree representation of the given structure.
#+begin_src plantuml :exports results :file ./images/exercise-2.24-2.png
@startuml
rectangle "(list 1 (list 2 (list 3 4)))" as p0
rectangle "(list 2 (list 3 4))" as p1
rectangle "(list 3 4)" as p2

p0 --> 1
p0 --> p1

p1 --> 2
p1 --> p2

p2 --> 3
p2 --> 4

@enduml
#+end_src

#+caption: Tree representation of the given structure.
#+RESULTS:
[[file:./images/exercise-2.24-2.png]]

Tree representation abstracts away the implementation detail of using pairs.
* Exercise 2.25
** Prompt
Pick 7 from the following list using ~car~ and ~cdr~.
#+begin_src racket :exports code
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
#+end_src
** Solution
Here are the calls using just ~car~ and ~cdr~ to get the 7 in each of the lists.
#+begin_src racket :exports both
#lang sicp
(define first (list 1 3 (list 5 7) 9))
(define second (list (list 7)))
(define third (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))

(car (cdr (car (cdr (cdr first)))))
(car (car second))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr third))))))))))))
#+end_src

#+RESULTS:
: 7
: 7
: 7
* Exercise 2.26
** Prompt
Say what the output of the following list manipulation procedures.

#+begin_src racket :exports code
(define x (list 1 2 3))
(define y (list 4 5 6))
#+end_src

#+begin_src racket :exports code
(append x y)
(cons x y)
(list x y)
#+end_src
** Solution
I am writing what I see as the solution before evaluating these procedures using the interpreter.

#+begin_src racket :exports code
(1 2 3 4 5 6)
;; This is a pair, and I know that this is how racket displays this
((1 2 3) . (4 5 6))
((1 2 3) (4 5 6))
#+end_src

Now we can evaluate for proof.

#+begin_src racket :exports both
#lang sicp
(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y)
(cons x y)
(list x y)
#+end_src

#+RESULTS:
: (1 2 3 4 5 6)
: ((1 2 3) 4 5 6)
: ((1 2 3) (4 5 6))

Alright, I must admit that I was wrong. Here is what we can see. The second line is using ~cons~ on two list. Remembering what ~cons~ does, with respect to the abstraction of list, we know that ~cons~ actually appends to the front of the list. This is why we see ~x~ as the new first element of list ~y~.
* Exercise 2.27
** Prompt
Modify the solution to [[*Exercise 2.18][Exercise 2.18]] to make a procedure called ~deep-reverse~ that will reverse the main list, as well as the sub-lists.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (deep-reverse items)
  (define (iter acc nav)
    (cond ((null? nav) acc)
          ((pair? (car nav)) (iter (cons (deep-reverse (car nav)) acc) (cdr nav)))
          (else (iter (cons (car nav) acc) (cdr nav)))))
  (iter nil items)
  )

(deep-reverse (list 1 2 3 4))
(deep-reverse (list (list 1 2) (list 3 4)))
#+end_src

#+RESULTS:
: (4 3 2 1)
: ((4 3) (2 1))

This is working as expected.
* Exercise 2.28
** Prompt
Make a procedure called ~fringe~ that takes a tree make of list as input, and then outputs a list with all the leaves arranged from left to right order.
** Solution
We could re-frame the problem into flattening a list. Since I have done some of Cornell's cs3110, I know the spoiler of having to reverse the list if it is generated recursively.

#+begin_src racket :exports both
#lang sicp

(define (reverse items)
  (define (iter acc nav)
    (if (null? nav)
        acc
        (iter (cons (car nav) acc) (cdr nav))))
  (iter nil items))

(define (fringe tree)
  (define (iter acc sub-tree)
    (cond
      [(null? sub-tree) acc]
      [(pair? (car sub-tree)) (iter (iter acc (car sub-tree)) (cdr sub-tree))]
      [else (iter (cons (car sub-tree) acc) (cdr sub-tree))]))
  (reverse (iter nil tree)))

(define x (list (list 1 2) (list 3 4)))
(fringe x)
(fringe (list x x))
(let ([y (list x x)]) (fringe (list y y)))
#+end_src

#+RESULTS:
: (1 2 3 4)
: (1 2 3 4 1 2 3 4)
: (1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4)

This is lovely, but the downside is that it is not truly an iterative process, since there are branches that would cause the previous scope to wait for a new iterative process to finish evaluation. Still, this lowers the growth of memory when there are long lists in the tree.
* Exercise 2.29
** Prompt
Working with the concept of a binary mobile, which has the following constructors.
#+begin_src racket :exports code
;; make-mobile makes a binary mobile. left and right are branches.
(define (make-mobile left right) (list left right))
;; make-branch is the constructor for a branch. length must be an integer, and
;; structure could either be a number or another mobile
(define (make-branch length structure) (list length structure))
#+end_src
*** Local Analysis
This problem is introducing the concept of indirect recursive data structure.
** Solution
#+begin_src racket :exports both
#lang sicp
(define (make-mobile left right)
  (list left right))
(define (make-branch length structure)
  (list length structure))

;; Part a. make a selector for mobile called left-branch and right-branch.
;; Make a selector for branches called branch-length and branch-structure
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile)))

(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (car (cdr branch)))

(left-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))
(right-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))

(branch-length (make-branch 2 4))
(branch-structure (make-branch 2 4))

;; Part b. define a procedure called total weight that will return the total
;; weight of the mobile.
;; We're really looking to accumulate the sum of the weights, with the
;; assumption that the mobile type does not have a weight associated with it.
;; Branches are actually tagged unions, so we should have a predicate that
;; determines the type. Base case is that we have reached a branch that is a
;; weight, then we could return the value.

(define (mobile? x)
  (pair? x))

(define (total-weight mobile)
  (define (total-weight-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (total-weight local-structure)
          local-structure)))
  (+ (total-weight-branch (left-branch mobile)) (total-weight-branch (right-branch mobile))))

(define test-mobile-1
  (make-mobile
   (make-branch 4 (make-mobile (make-branch 2 2) (make-branch 4 2)))
   (make-branch 7
                (make-mobile (make-branch 3 (make-mobile (make-branch 3 3) (make-branch 3 12)))
                             (make-branch 2 2)))))

;; expect the total-weight to be 21 for test-mobile-1
(total-weight test-mobile-1)

;; Part c. Make a predicate that will determine if the mobile is balanced,
;; where balanced means that the torque of the left and right branch is
;; equal, and all the mobiles underneath are balanced as well. As a reminder,
;; torque is the product of the length of the rod and the weight it is
;; carrying.
;; For the sake of computational efficiency, we're going to calculate this
;; predicate as we traverse the tree
(define (balanced? mobile)
  (define (get-torque x)
    (car x))
  (define (get-branch-weight x)
    (cdr x))
  ;; handle-branch should return a pair of the torque and weight or propagate a
  ;; nil
  (define (handle-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (let ([mobile-return (handle-mobile local-structure)])
            (if (null? mobile-return)
                mobile-return
                (cons (* (branch-length branch) mobile-return) mobile-return)))
          (cons (* (branch-length branch) local-structure) local-structure))))
  ;; handle-mobile should either return a nil if it does not find the mobile
  ;; parameter to be balanced, else return the sum of the weight of the
  ;; two branches.
  (define (handle-mobile mobile)
    (let ([left (handle-branch (left-branch mobile))]
          [right (handle-branch (right-branch mobile))])
      (cond
        [(or (null? left) (null? right)) nil]
        [(= (get-torque left) (get-torque right))
         (+ (get-branch-weight left) (get-branch-weight right))]
        [else nil])))
  (not (null? (handle-mobile mobile))))

(balanced? test-mobile-1)
(balanced? (make-mobile (make-branch 1 1)
                        (make-branch 1 1)))
(balanced? (make-mobile (make-branch 1 8)
                        (make-branch 2 4)))
(balanced? (make-mobile (make-branch 1 (make-mobile (make-branch 1 4)
                                                    (make-branch 1 4)))
                        (make-branch 2 4)))


#+end_src

#+RESULTS:
: (2 2)
: (3 3)
: 2
: 4
: 21
: #f
: #t
: #t
: #t

In part d of the exercise, we are changing the implementation of the constructor. How many procedures must change to keep the functionality the same?

#+caption: Constructor and data structure representation changes.
#+begin_src racket :exports code
(define (make-mobile left right) (cons left right))
(define (make-branch length structure) (cons length structure))
#+end_src

The answer is just the ~cdr~ selectors, since we are using the abstraction for data structure access in all higher level procedures that work with this system. Swapping from list to pair means that you no longer need the ~car~ to access the second element, since the pair here does not need the facility to allow for dynamic extension.

#+begin_src racket :exports both
#lang sicp
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))

;; Part a. make a selector for mobile called left-branch and right-branch.
;; Make a selector for branches called branch-length and branch-structure
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))

(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))

(left-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))
(right-branch (make-mobile (make-branch 2 2) (make-branch 3 3)))

(branch-length (make-branch 2 4))
(branch-structure (make-branch 2 4))

;; Part b. define a procedure called total weight that will return the total
;; weight of the mobile.
;; We're really looking to accumulate the sum of the weights, with the
;; assumption that the mobile type does not have a weight associated with it.
;; Branches are actually tagged unions, so we should have a predicate that
;; determines the type. Base case is that we have reached a branch that is a
;; weight, then we could return the value.

(define (mobile? x)
  (pair? x))

(define (total-weight mobile)
  (define (total-weight-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (total-weight local-structure)
          local-structure)))
  (+ (total-weight-branch (left-branch mobile)) (total-weight-branch (right-branch mobile))))

(define test-mobile-1
  (make-mobile
   (make-branch 4 (make-mobile (make-branch 2 2) (make-branch 4 2)))
   (make-branch 7
                (make-mobile (make-branch 3 (make-mobile (make-branch 3 3) (make-branch 3 12)))
                             (make-branch 2 2)))))

;; expect the total-weight to be 21 for test-mobile-1
(total-weight test-mobile-1)

;; Part c. Make a predicate that will determine if the mobile is balanced,
;; where balanced means that the torque of the left and right branch is
;; equal, and all the mobiles underneath are balanced as well. As a reminder,
;; torque is the product of the length of the rod and the weight it is
;; carrying.
;; For the sake of computational efficiency, we're going to calculate this
;; predicate as we traverse the tree
(define (balanced? mobile)
  (define (get-torque x)
    (car x))
  (define (get-branch-weight x)
    (cdr x))
  ;; handle-branch should return a pair of the torque and weight or propagate a
  ;; nil
  (define (handle-branch branch)
    (let ([local-structure (branch-structure branch)])
      (if (mobile? local-structure)
          (let ([mobile-return (handle-mobile local-structure)])
            (if (null? mobile-return)
                mobile-return
                (cons (* (branch-length branch) mobile-return) mobile-return)))
          (cons (* (branch-length branch) local-structure) local-structure))))
  ;; handle-mobile should either return a nil if it does not find the mobile
  ;; parameter to be balanced, else return the sum of the weight of the
  ;; two branches.
  (define (handle-mobile mobile)
    (let ([left (handle-branch (left-branch mobile))]
          [right (handle-branch (right-branch mobile))])
      (cond
        [(or (null? left) (null? right)) nil]
        [(= (get-torque left) (get-torque right))
         (+ (get-branch-weight left) (get-branch-weight right))]
        [else nil])))
  (not (null? (handle-mobile mobile))))

(balanced? test-mobile-1)
(balanced? (make-mobile (make-branch 1 1) (make-branch 1 1)))
(balanced? (make-mobile (make-branch 1 8) (make-branch 2 4)))
(balanced? (make-mobile (make-branch 1 (make-mobile (make-branch 1 4) (make-branch 1 4)))
                        (make-branch 2 4)))
#+end_src

#+RESULTS:
: (2 . 2)
: (3 . 3)
: 2
: 4
: 21
: #f
: #t
: #t
: #t

And we can see that this was an acceptable refactor. We changed 2 procedures to accommodate for the change in the data structure representation.
* Exercise 2.30
** Prompt
Make a procedure ~square-tree~ that is analogous to the ~square-list~ procedure in exercise [[*Exercise 2.21][Exercise 2.21]]. Do this exercise with and without the ~map~ procedure.
** Solution
#+caption: Square tree without using map
#+begin_src racket :exports both
#lang sicp

(define (square x)
  (* x x))
(define (square-tree tree)
  (cond
    [(null? tree) nil]
    [(pair? tree) (cons (square-tree (car tree)) (square-tree (cdr tree)))]
    [else (square tree)]))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

#+caption: Square tree using map
#+begin_src racket :exports both
#lang sicp

(define (square x)
  (* x x))
(define (square-tree tree)
  (map (lambda (x)
         (if (pair? x)
             (square-tree x)
             (square x)))
       tree))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

I'll say, the ~map~ version of the implementation was actually easier to reason about.
* Exercise 2.31
** Prompt
Abstract tree map out of the previous implementation. Design such that the definition of ~square-tree~ from [[*Exercise 2.30][Exercise 2.30]] looks like the following code block.
#+begin_src racket :exports code
(define (square-tree tree) (tree-map square tree))
#+end_src
** Solution
For the sake of reuse, I'll implement this using the pre-existing ~map~ procedure.

#+begin_src racket :exports both
#lang sicp

(define (tree-map f items)
  (map (lambda (x)
         (if (pair? x)
             (tree-map f x)
             (f x)))
       items))

(define (square x)
  (* x x))
(define (square-tree tree)
  (tree-map square tree))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+end_src

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

Just like that, we have a clean and efficient implementation of tree map.
* Exercise 2.32
** Prompt
Knowing the definition of a set, make a procedure that generates a set of subsets using the given code.
** Solution
#+begin_src racket :exports both
#lang sicp

;; Invariant, s is a set that is represented as a list. This means that this
;; list should have no duplicate elements.
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ([rest (subsets (cdr s))]) (append rest (map (lambda (x) (cons (car s) x)) rest)))))

;; this should return (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
(subsets (list 3))
(subsets (list 2 3))
(subsets (list 1 2 3))
#+end_src

#+RESULTS:
: (() (3))
: (() (3) (2) (2 3))
: (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))

In this problem, we are working with a power set. The pattern is that we want the combination of all the elements of the input set. Recursive approach is the following. Since we are returning a set of set, the base case is the very last element of the input set, which is nil. Then the recursion case goes back one layer, where we are working with an input set of 3 and nil. This layer has two elements in the input set, and we have the power-set of the tail of the input set. Now we generate the next layer output by appending the power-set of the tail with a set of the head of the set with the power-set of the tail. The set of the head appended to the power-set of the tail will create the rest of the elements that would appear upon adding the head element to the input set. Excuse the less than clear explanation, the writer of this file did not have a very formal mathematical background.
* Exercise 2.33
** Prompt
This is the first element after learning about sequence operations and how it contributes to modular design. Task for this exercise is to define ~map~, ~append~, and ~length~ in terms of accumulate.
** Solution
This exercise makes us use right fold to achieve different solutions.
#+begin_src racket :exports both
#lang sicp
;; Accumulate designed as right fold
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))

(accumulate (lambda (x y) (+ x y)) 0 (list 1 2 3 4))

;; This implementation requires that the accumulate function be a right fold,
;; else we would not be able to build like this.
(define (map p sequence)
  (accumulate (lambda (x y)
                (cons (p x) y))
              nil
              sequence))

(map (lambda (x) (* x x)) (list 1 2 3 4))

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(append (list 1 2) (list 3 4))

(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))

(length nil)
(length (list 1 2 2 2 2))
#+end_src

#+RESULTS:
: 10
: (1 4 9 16)
: (1 2 3 4)
: 0
: 5
* Exercise 2.34
** Prompt
Using Horner's rule, evaluate the polynomial as an accumulation.

\[a_{n} x^{n} + a_{n-1}x^{n -1} + \cdots + a_{1} x + a_{0} \rightarrow \left( \cdots \left( a_{n} x + a_{n-1} \right) x + \cdots + a_{1} \right) x + a_{0}\]
** Solution
Horner's rule brings the evaluation of the \(x\) term into a recursive case, which also reduces the number of multiplication that is happening. This can be done in a single accumulation sequence operation.

#+begin_src racket :exports both
#lang sicp
;; Accumulate designed as right fold
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))

;; coefficient-sequence is given in order or a_0 to a_n
(define (horner-eval x coefficient-sequence)
  ;; accumulate must be a right fold for this implementation
  (accumulate (lambda (curr-coefficient accumulation) (+ curr-coefficient (* x accumulation)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 1 1))
(horner-eval 2 (list 1 3 0 5 0 1))
#+end_src

#+RESULTS:
: 7
: 79

Cool note. Horner's rule is the most optimal algorithm for polynomial evaluation.
* Exercise 2.35
** Prompt
Redefine ~count-leaves~ from section 2.2.2 as an accumulation.
** Solution
#+begin_src racket :exports both
#lang sicp

;; still using right fold for accumulation
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))
;; Procedure under test
(define (count-leaves t)
  (accumulate +
              0
              (map (lambda (x)
                     (if (pair? x)
                         (count-leaves x)
                         1))
                   t)))

(count-leaves (list 1 (list 3 4) 5))
#+end_src

#+RESULTS:
: 4

Modularity is a powerful tool for designing software.
* Exercise 2.36
** prompt
Make a procedure called ~accumulate-n~ where the third parameter is a sequence of equal length sequences. The accumulation will now happen on the different sequences at the same index.

#+caption: Example output
#+begin_src racket :exports code
(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
(22 26 30)
#+end_src

A template for the solution was provided. Work within the constraint.
** Solution

#+begin_src racket :exports both
#lang sicp

;; still using right fold for accumulation
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))
(define (accumulate-n op initial seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op initial (map car seqs))
            (accumulate-n op initial (map cdr seqs)))))

(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
#+end_src

#+RESULTS:
: (22 26 30)

Our solution uses sequence operators to quickly build this system. Hoping that this is sufficiently modular.
* Exercise 2.37
** Prompt
Matrix operation. Vectors \(v\) are sequences of numbers and matrices are sequence of equal length vectors. Implement ~dot-product~, ~matrix-*-vector~, ~matrix-*-matrix~, and ~transpose~. Note that the implementation of the matrix is a list of list by rows.
** Solution
#+begin_src racket :exports both
#lang sicp
;; still using right fold for accumulation
(define (accumulate p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (accumulate p initial (cdr sequence)))))
;; Need to use this for transpose
(define (accumulate-n op initial seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op initial (map car seqs)) (accumulate-n op initial (map cdr seqs)))))

(define (dot-product v w)
  (accumulate + 0 (map * v w))) ;; This is using expanded map

(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))
;; This implementation is reliant on accumulate-n being a right fold.
(define (transpose mat)
  (accumulate-n cons nil mat))

(define (matrix-*-matrix m n)
  (let ([cols (transpose n)])
    (map (lambda (x) (matrix-*-vector cols x)) m)))

(dot-product (list 1 2 3) (list 4 5 6))
(matrix-*-vector (list (list 1 2) (list 3 4)) (list 5 6))
(transpose (list (list 1 2) (list 3 4)))
(matrix-*-matrix (list (list 1 2) (list 3 4)) (list (list 5 6) (list 7 8)))
#+end_src

#+RESULTS:
: 32
: (17 39)
: ((1 3) (2 4))
: ((19 22) (43 50))

We got the expected values out of this implementation. This implementation does not focus on getting the best cache hits, but instead it was all about modularity and reusing abstractions created as we implement each of the matrix operations.
* Exercise 2.38
** Prompt
We realize that we were using a right fold for accumulate previously. Now we introduce a fold left procedure that operates from left to right. This implementation is an iterative process.
#+caption: Implementation of fold left and fold right
#+begin_src racket :exports code
(define (fold-right p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (fold-right p initial (cdr sequence)))))

(define (fold-left op initial seq)
  (define (iter acc s)
    (if (null? s)
        acc
        (iter (op acc (car s))
              (cdr s))))
  (iter initial seq))
#+end_src

Find the value of the following operations.
#+begin_src racket :exports code
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#+end_src
** Solution
#+caption: Solution (before verifying)
#+begin_src racket :exports code
;; (fold-right / 1 (list 1 2 3))
(/ 1 (/ 2 (/ 3 1)))
(3/2)
;; (fold-left / 1 (list 1 2 3))
(/ (/ (/ 1 1) 2) 3)
(1/6)
;; (fold-right list nil (list 1 2 3))
(list 1 (list 2 (list 3 nil)))
(1 (2 (3 ())))
;; (fold-left list nil (list 1 2 3))
(list (list (list nil 1) 2) 3)
(((() 1) 2) 3)
#+end_src

With that solution done, we should verify the result.

#+begin_src racket :exports both
#lang sicp
(define (fold-right p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (fold-right p initial (cdr sequence)))))

(define (fold-left op initial seq)
  (define (iter acc s)
    (if (null? s)
        acc
        (iter (op acc (car s))
              (cdr s))))
  (iter initial seq))
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#+end_src

#+RESULTS:
: 3/2
: 1/6
: (1 (2 (3 ())))
: (((() 1) 2) 3)

Nice, we were correct about the semantics of the problem. Now to talk about the property of the operator that would make ~fold-left~ and ~fold-right~ return the same value. That operator property is the commutative property. Commutative property is a property that means that the operator will produce the same output if you swap the position of the operands.
* Exercise 2.39
** Prompt
Define ~reverse~ using both ~fold-left~ and ~fold-right~.
** Solution
#+caption: Fold right implementation of reverse.
#+begin_src racket :exports both
#lang sicp
(define (fold-right p initial sequence)
  (if (null? sequence)
      initial
      (p (car sequence) (fold-right p initial (cdr sequence)))))

(define (reverse seq)
  (fold-right (lambda (x y) (if (null? y)
                                (cons x nil)
                                (append y (cons x nil)))) nil seq))

(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)

The fold right implementation requires the use of the append procedure, which is inefficient.

#+caption: Fold left implementation of reverse.
#+begin_src racket :exports both
#lang sicp
(define (fold-left op initial seq)
  (define (iter acc s)
    (if (null? s)
        acc
        (iter (op acc (car s))
              (cdr s))))
  (iter initial seq))

(define (reverse seq)
  (fold-left (lambda (x y) (cons y x)) nil seq))
(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)

Fold left is much more efficient for reversing a list, as it is an iterative process, and it avoids append.
* Exercise 2.40
** Prompt
This problem goes into the application of the ~flatmap~. Define a procedure called ~unique-map~ that when given an integer ~n~, generate the sequence of pairs (i, j) with 1 <= j < i <= n. Use this to simplify the definition of ~prime-sum-pairs~.
** Solution
#+begin_src racket :exports both
#lang sicp
;; Importing prime?
(define (square x) (* x x))
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? x y) (= (remainder y x) 0))
(define (prime? n)
  (= n (smallest-divisor n)))

(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))

(define (filter predicate seq)
  (fold-right (lambda (x y) (if (predicate x) (cons x y) y)) nil seq))


(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))

(define (unique-pairs n)
  (flatmap (lambda (x) (map (lambda (y) (list x y)) (enumerate-range 1 (- x 1))))
           (enumerate-range 2 n)))

(define (make-pair-sum pair)
  (let ((left (car pair)) (right (car (cdr pair))))
    (list left right (+ left right))))
(define (prime-sum-pairs n)
  (define (prime-sum? x) (prime? (+ (car x) (car (cdr x) ))))
  (map make-pair-sum (filter prime-sum? (unique-pairs n))))

(unique-pairs 8)
(prime-sum-pairs 8)
#+end_src

#+RESULTS:
: ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3) (5 1) (5 2) (5 3) (5 4) (6 1) (6 2) (6 3) (6 4) (6 5) (7 1) (7 2) (7 3) (7 4) (7 5) (7 6) (8 1) (8 2) (8 3) (8 4) (8 5) (8 6) (8 7))
: ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11) (7 4 11) (7 6 13) (8 3 11) (8 5 13))
* Exercise 2.41
** Prompt
Write a procedure to find all ordered triples of distinct positive integers i, j, and k less than or equal to a given integer n that sum to a given integer s
** Solution
We are looking for all ordered integers of distinct positive integers. Distinct means that we will not accept cases where i, j, or k are equal. Furthermore, the values no longer has to be less than each other, they just need to be distinct. We'd usually generate this with three for loops. Next, we will filter by summing.

#+begin_src racket :exports both
#lang sicp
(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))

(define (filter predicate seq)
  (fold-right (lambda (x y)
                (if (predicate x)
                    (cons x y)
                    y))
              nil
              seq))

(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))

;; This procedure checks if the target value is contained inside the sequence
;; Currently only comparing numerical contents
(define (contains? target seq)
  (fold-right (lambda (left right)
                (cond
                  [(= left target) #t]
                  [else right]))
              #f
              seq))

;; Enumerates from 1 to n, inclusive, but do not include the values in the
;; excl dynamic parameter.
(define (enumerate-exclusion n . excl)
  (define (enumerate-exclusion-aux lower)
    (cond
      [(> lower n) nil]
      [(contains? lower excl) (enumerate-exclusion-aux (+ lower 1))]
      [else (cons lower (enumerate-exclusion-aux (+ lower 1)))]))
  (enumerate-exclusion-aux 1))

;; constructor and selector for the triple
(define (make-triple a b c)
  (list a b c))
(define (first x)
  (car x))
(define (second x)
  (car (cdr x)))
(define (third x)
  (car (cdr (cdr x))))

;; Main function should do the following to reduce work. Only enumerate through
;; what is possible to get to the target sum. If we cannot get to the target
;; sum, then move on to the next iteration.
(define (ordered-triple-sum n s)
  (flatmap (lambda (x)
             (flatmap (lambda (y)
                        (map (lambda (z) (make-triple x y z))
                             (filter (lambda (c) (= (+ x y c) s)) (enumerate-exclusion n x y))))
                      (filter (lambda (b) (< (+ x b) s)) (enumerate-exclusion n x))))
           ;; We could subtract two from the first case because the smallest
           ;; increase with two more value is 1 + 2
           (filter (lambda (a) (< a (- s 2))) (enumerate-range 1 n))))

(ordered-triple-sum 8 11)
#+end_src

#+RESULTS:
: ((1 2 8) (1 3 7) (1 4 6) (1 6 4) (1 7 3) (1 8 2) (2 1 8) (2 3 6) (2 4 5) (2 5 4) (2 6 3) (2 8 1) (3 1 7) (3 2 6) (3 6 2) (3 7 1) (4 1 6) (4 2 5) (4 5 2) (4 6 1) (5 2 4) (5 4 2) (6 1 4) (6 2 3) (6 3 2) (6 4 1) (7 1 3) (7 3 1) (8 1 2) (8 2 1))

For the sake of performance, instead of building all the permuatations first, and then filtering them out, we could reduce the permutation problem size by filtering the enumeration out as we go.
* Exercise 2.42
** Prompt
This is the eight queens problem, which asks how to place 8 queens on a chessboard. Strategy being asked of us is to place a queen in each column. For the k-th queen, check we can place a queen in a row that will not conflict with the previously placed queens. To do this, we are asked to keep track of all the previous legal moves, and as we move forward, filter out the ones that are not legal. On the k-th queen, don't just produce one legal position, but all of them. Actually, the generalization will be done for a square chessboard of equal size. The following is the provided code, implement the rest.

#+begin_src racket :exports code
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter (lambda (positions) (safe? k positions))
                (flatmap
                 (lambda (rest-of-queens)
                   (map (lambda (new-row)
                          (adjoin-position
                           new-row k rest-of-queens))
                        (enumerate-interval 1 board-size)))
                 (queen-cols (- k 1))))))
  (queen-cols board-size))
#+end_src
** Solution
We can make our solution more flexible by making the underlying representation a pair, and forgo the index. This way, the previous queens do not have to be ordered. Our recusions could be much more efficient with this strategy of implementing this.
#+begin_src racket :exports both
#lang sicp
;; unit testing
(define (assert-predicate pred-fn test-name value expected)
  (display (if (pred-fn value expected) "pass: " "fail: "))
  (display test-name)
  (display " value: ")
  (display value)
  (display " expected: ")
  (display expected)
  (newline))
(define (assert-eq test-name value expected)
  (assert-predicate eq? test-name value expected))
(define (assert-almost-eq test-name value expected)
  (define dx 0.0001)
  (define (almost-eq? left right)
    (< (abs (- left right)) dx))
  (assert-predicate almost-eq? test-name value expected))

;; Common sequence operators
(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))
(define (fold-left op initial seq)
  (define (iter acc remaining)
    (if (null? remaining)
        acc
        (iter (op (car remaining) acc) (cdr remaining))))
  (iter initial seq))
(define (filter predicate seq)
  (fold-right (lambda (x y)
                (if (predicate x)
                    (cons x y)
                    y))
              nil
              seq))

(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))
(define (enumerate-interval lower upper)
  (enumerate-range lower upper))

;; Need to implement the representation of the queens on the board. We can
;; make this representation unordered if we store the col and row information
;; with the queen
(define empty-board nil)
(define (make-queen row col)
  (cons row col))
(define (get-row queen)
  (car queen))
(define (get-col queen)
  (cdr queen))
;; Looks like k actually does nothing for us yet
(define (adjoin-position nr k roq)
  (cons (make-queen nr k) roq))

(define (safe? k positions)
  (define (get-queen)
    (fold-left (lambda (x acc)
                 (if (null? acc)
                     (if (= (get-col x) k) x acc)
                     acc))
               nil
               positions))
  ;; check if the two queens are diag from each other
  (define (diag? a b)
    (= (abs (- (get-col a)
               (get-col b)))
     (abs (- (get-row a)
             (get-row b)))))
  ;; where target is the queen that is being tested against
  (define (safe?-aux target roq)
    (define (iter rest-of-queens)
      (cond
        [(null? rest-of-queens) #t]
        [(= (get-row target) (get-row (car rest-of-queens))) #f]
        [(= (get-col target) (get-col (car rest-of-queens))) #f]
        [(diag? target (car rest-of-queens)) #f]
        [else (iter (cdr rest-of-queens))]))
    (iter roq))
  (let ((k-queen (get-queen))) (safe?-aux k-queen
                                          (filter (lambda (x) (not (and (= (get-col x)
                                                                           (get-col k-queen))
                                                                        (= (get-row x)
                                                                           (get-row k-queen)))))
                                                  positions))))

(display "testing safe?")
(newline)
(define base-1 (adjoin-position 7 3 (adjoin-position 5 2 (adjoin-position 1 1 empty-board))))
(define base-2 (adjoin-position 1 1 empty-board))
(assert-eq "horizontal collision" (safe? 4 (adjoin-position 1 4 base-1)) #f)
(assert-eq "no collision" (safe? 4 (adjoin-position 2 4 base-1)) #t)
(assert-eq "diagonal collision 1" (safe? 4 (adjoin-position 3 4 base-1)) #f)
(assert-eq "diagonal collision 2" (safe? 4 (adjoin-position 6 4 base-1)) #f)
(assert-eq "diagonal collision 3" (safe? 4 (adjoin-position 4 4 base-1)) #f)
(assert-eq "fail by horizontal collision" (safe? 2 (adjoin-position 1 2 base-2)) #f)
(assert-eq "fail by diagonal collision" (safe? 2 (adjoin-position 2 2 base-2)) #f)
(assert-eq "safe 1" (safe? 2 (adjoin-position 3 2 base-2)) #t)
(assert-eq "safe 2" (safe? 2 (adjoin-position 4 2 base-2)) #t)
(assert-eq "safe 3" (safe? 2 (adjoin-position 5 2 base-2)) #t)
(assert-eq "safe 4" (safe? 2 (adjoin-position 6 2 base-2)) #t)
(assert-eq "safe 5" (safe? 2 (adjoin-position 7 2 base-2)) #t)
(assert-eq "safe 6" (safe? 2 (adjoin-position 8 2 base-2)) #t)
(newline)

;; We are using board-size as a local global (all the other recursion will use
;; this value to test if the system is working as intended)
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        ;; Making the base board
        (list empty-board)
        ;; filter, safe? is given the current col being tested, and positions
        ;; actually already includes the parameter
        (filter (lambda (positions) (safe? k positions))
                (flatmap (lambda (rest-of-queens)
                           (map (lambda (new-row) (adjoin-position new-row k rest-of-queens))
                                (enumerate-interval 1 board-size)))
                         (queen-cols (- k 1))))))
  (queen-cols board-size))

(display "one queens")
(newline)
(queens 1)
(display "four queens")
(newline)
(queens 4)
(display "five queens")
(newline)
(queens 5)
(display "eight queens")
(newline)
(queens 8)
#+end_src

#+RESULTS:
#+begin_example
testing safe?
pass: horizontal collision value: #f expected: #f
pass: no collision value: #t expected: #t
pass: diagonal collision 1 value: #f expected: #f
pass: diagonal collision 2 value: #f expected: #f
pass: diagonal collision 3 value: #f expected: #f
pass: fail by horizontal collision value: #f expected: #f
pass: fail by diagonal collision value: #f expected: #f
pass: safe 1 value: #t expected: #t
pass: safe 2 value: #t expected: #t
pass: safe 3 value: #t expected: #t
pass: safe 4 value: #t expected: #t
pass: safe 5 value: #t expected: #t
pass: safe 6 value: #t expected: #t

one queens
(((1 . 1)))
four queens
(((3 . 4) (1 . 3) (4 . 2) (2 . 1)) ((2 . 4) (4 . 3) (1 . 2) (3 . 1)))
five queens
(((4 . 5) (2 . 4) (5 . 3) (3 . 2) (1 . 1)) ((3 . 5) (5 . 4) (2 . 3) (4 . 2) (1 . 1)) ((5 . 5) (3 . 4) (1 . 3) (4 . 2) (2 . 1)) ((4 . 5) (1 . 4) (3 . 3) (5 . 2) (2 . 1)) ((5 . 5) (2 . 4) (4 . 3) (1 . 2) (3 . 1)) ((1 . 5) (4 . 4) (2 . 3) (5 . 2) (3 . 1)) ((2 . 5) (5 . 4) (3 . 3) (1 . 2) (4 . 1)) ((1 . 5) (3 . 4) (5 . 3) (2 . 2) (4 . 1)) ((3 . 5) (1 . 4) (4 . 3) (2 . 2) (5 . 1)) ((2 . 5) (4 . 4) (1 . 3) (3 . 2) (5 . 1)))
eight queens
(((4 . 8) (2 . 7) (7 . 6) (3 . 5) (6 . 4) (8 . 3) (5 . 2) (1 . 1)) ((5 . 8) (2 . 7) (4 . 6) (7 . 5) (3 . 4) (8 . 3) (6 . 2) (1 . 1)) ((3 . 8) (5 . 7) (2 . 6) (8 . 5) (6 . 4) (4 . 3) (7 . 2) (1 . 1)) ((3 . 8) (6 . 7) (4 . 6) (2 . 5) (8 . 4) (5 . 3) (7 . 2) (1 . 1)) ((5 . 8) (7 . 7) (1 . 6) (3 . 5) (8 . 4) (6 . 3) (4 . 2) (2 . 1)) ((4 . 8) (6 . 7) (8 . 6) (3 . 5) (1 . 4) (7 . 3) (5 . 2) (2 . 1)) ((3 . 8) (6 . 7) (8 . 6) (1 . 5) (4 . 4) (7 . 3) (5 . 2) (2 . 1)) ((5 . 8) (3 . 7) (8 . 6) (4 . 5) (7 . 4) (1 . 3) (6 . 2) (2 . 1)) ((5 . 8) (7 . 7) (4 . 6) (1 . 5) (3 . 4) (8 . 3) (6 . 2) (2 . 1)) ((4 . 8) (1 . 7) (5 . 6) (8 . 5) (6 . 4) (3 . 3) (7 . 2) (2 . 1)) ((3 . 8) (6 . 7) (4 . 6) (1 . 5) (8 . 4) (5 . 3) (7 . 2) (2 . 1)) ((4 . 8) (7 . 7) (5 . 6) (3 . 5) (1 . 4) (6 . 3) (8 . 2) (2 . 1)) ((6 . 8) (4 . 7) (2 . 6) (8 . 5) (5 . 4) (7 . 3) (1 . 2) (3 . 1)) ((6 . 8) (4 . 7) (7 . 6) (1 . 5) (8 . 4) (2 . 3) (5 . 2) (3 . 1)) ((1 . 8) (7 . 7) (4 . 6) (6 . 5) (8 . 4) (2 . 3) (5 . 2) (3 . 1)) ((6 . 8) (8 . 7) (2 . 6) (4 . 5) (1 . 4) (7 . 3) (5 . 2) (3 . 1)) ((6 . 8) (2 . 7) (7 . 6) (1 . 5) (4 . 4) (8 . 3) (5 . 2) (3 . 1)) ((4 . 8) (7 . 7) (1 . 6) (8 . 5) (5 . 4) (2 . 3) (6 . 2) (3 . 1)) ((5 . 8) (8 . 7) (4 . 6) (1 . 5) (7 . 4) (2 . 3) (6 . 2) (3 . 1)) ((4 . 8) (8 . 7) (1 . 6) (5 . 5) (7 . 4) (2 . 3) (6 . 2) (3 . 1)) ((2 . 8) (7 . 7) (5 . 6) (8 . 5) (1 . 4) (4 . 3) (6 . 2) (3 . 1)) ((1 . 8) (7 . 7) (5 . 6) (8 . 5) (2 . 4) (4 . 3) (6 . 2) (3 . 1)) ((2 . 8) (5 . 7) (7 . 6) (4 . 5) (1 . 4) (8 . 3) (6 . 2) (3 . 1)) ((4 . 8) (2 . 7) (7 . 6) (5 . 5) (1 . 4) (8 . 3) (6 . 2) (3 . 1)) ((5 . 8) (7 . 7) (1 . 6) (4 . 5) (2 . 4) (8 . 3) (6 . 2) (3 . 1)) ((6 . 8) (4 . 7) (1 . 6) (5 . 5) (8 . 4) (2 . 3) (7 . 2) (3 . 1)) ((5 . 8) (1 . 7) (4 . 6) (6 . 5) (8 . 4) (2 . 3) (7 . 2) (3 . 1)) ((5 . 8) (2 . 7) (6 . 6) (1 . 5) (7 . 4) (4 . 3) (8 . 2) (3 . 1)) ((6 . 8) (3 . 7) (7 . 6) (2 . 5) (8 . 4) (5 . 3) (1 . 2) (4 . 1)) ((2 . 8) (7 . 7) (3 . 6) (6 . 5) (8 . 4) (5 . 3) (1 . 2) (4 . 1)) ((7 . 8) (3 . 7) (1 . 6) (6 . 5) (8 . 4) (5 . 3) (2 . 2) (4 . 1)) ((5 . 8) (1 . 7) (8 . 6) (6 . 5) (3 . 4) (7 . 3) (2 . 2) (4 . 1)) ((1 . 8) (5 . 7) (8 . 6) (6 . 5) (3 . 4) (7 . 3) (2 . 2) (4 . 1)) ((3 . 8) (6 . 7) (8 . 6) (1 . 5) (5 . 4) (7 . 3) (2 . 2) (4 . 1)) ((6 . 8) (3 . 7) (1 . 6) (7 . 5) (5 . 4) (8 . 3) (2 . 2) (4 . 1)) ((7 . 8) (5 . 7) (3 . 6) (1 . 5) (6 . 4) (8 . 3) (2 . 2) (4 . 1)) ((7 . 8) (3 . 7) (8 . 6) (2 . 5) (5 . 4) (1 . 3) (6 . 2) (4 . 1)) ((5 . 8) (3 . 7) (1 . 6) (7 . 5) (2 . 4) (8 . 3) (6 . 2) (4 . 1)) ((2 . 8) (5 . 7) (7 . 6) (1 . 5) (3 . 4) (8 . 3) (6 . 2) (4 . 1)) ((3 . 8) (6 . 7) (2 . 6) (5 . 5) (8 . 4) (1 . 3) (7 . 2) (4 . 1)) ((6 . 8) (1 . 7) (5 . 6) (2 . 5) (8 . 4) (3 . 3) (7 . 2) (4 . 1)) ((8 . 8) (3 . 7) (1 . 6) (6 . 5) (2 . 4) (5 . 3) (7 . 2) (4 . 1)) ((2 . 8) (8 . 7) (6 . 6) (1 . 5) (3 . 4) (5 . 3) (7 . 2) (4 . 1)) ((5 . 8) (7 . 7) (2 . 6) (6 . 5) (3 . 4) (1 . 3) (8 . 2) (4 . 1)) ((3 . 8) (6 . 7) (2 . 6) (7 . 5) (5 . 4) (1 . 3) (8 . 2) (4 . 1)) ((6 . 8) (2 . 7) (7 . 6) (1 . 5) (3 . 4) (5 . 3) (8 . 2) (4 . 1)) ((3 . 8) (7 . 7) (2 . 6) (8 . 5) (6 . 4) (4 . 3) (1 . 2) (5 . 1)) ((6 . 8) (3 . 7) (7 . 6) (2 . 5) (4 . 4) (8 . 3) (1 . 2) (5 . 1)) ((4 . 8) (2 . 7) (7 . 6) (3 . 5) (6 . 4) (8 . 3) (1 . 2) (5 . 1)) ((7 . 8) (1 . 7) (3 . 6) (8 . 5) (6 . 4) (4 . 3) (2 . 2) (5 . 1)) ((1 . 8) (6 . 7) (8 . 6) (3 . 5) (7 . 4) (4 . 3) (2 . 2) (5 . 1)) ((3 . 8) (8 . 7) (4 . 6) (7 . 5) (1 . 4) (6 . 3) (2 . 2) (5 . 1)) ((6 . 8) (3 . 7) (7 . 6) (4 . 5) (1 . 4) (8 . 3) (2 . 2) (5 . 1)) ((7 . 8) (4 . 7) (2 . 6) (8 . 5) (6 . 4) (1 . 3) (3 . 2) (5 . 1)) ((4 . 8) (6 . 7) (8 . 6) (2 . 5) (7 . 4) (1 . 3) (3 . 2) (5 . 1)) ((2 . 8) (6 . 7) (1 . 6) (7 . 5) (4 . 4) (8 . 3) (3 . 2) (5 . 1)) ((2 . 8) (4 . 7) (6 . 6) (8 . 5) (3 . 4) (1 . 3) (7 . 2) (5 . 1)) ((3 . 8) (6 . 7) (8 . 6) (2 . 5) (4 . 4) (1 . 3) (7 . 2) (5 . 1)) ((6 . 8) (3 . 7) (1 . 6) (8 . 5) (4 . 4) (2 . 3) (7 . 2) (5 . 1)) ((8 . 8) (4 . 7) (1 . 6) (3 . 5) (6 . 4) (2 . 3) (7 . 2) (5 . 1)) ((4 . 8) (8 . 7) (1 . 6) (3 . 5) (6 . 4) (2 . 3) (7 . 2) (5 . 1)) ((2 . 8) (6 . 7) (8 . 6) (3 . 5) (1 . 4) (4 . 3) (7 . 2) (5 . 1)) ((7 . 8) (2 . 7) (6 . 6) (3 . 5) (1 . 4) (4 . 3) (8 . 2) (5 . 1)) ((3 . 8) (6 . 7) (2 . 6) (7 . 5) (1 . 4) (4 . 3) (8 . 2) (5 . 1)) ((4 . 8) (7 . 7) (3 . 6) (8 . 5) (2 . 4) (5 . 3) (1 . 2) (6 . 1)) ((4 . 8) (8 . 7) (5 . 6) (3 . 5) (1 . 4) (7 . 3) (2 . 2) (6 . 1)) ((3 . 8) (5 . 7) (8 . 6) (4 . 5) (1 . 4) (7 . 3) (2 . 2) (6 . 1)) ((4 . 8) (2 . 7) (8 . 6) (5 . 5) (7 . 4) (1 . 3) (3 . 2) (6 . 1)) ((5 . 8) (7 . 7) (2 . 6) (4 . 5) (8 . 4) (1 . 3) (3 . 2) (6 . 1)) ((7 . 8) (4 . 7) (2 . 6) (5 . 5) (8 . 4) (1 . 3) (3 . 2) (6 . 1)) ((8 . 8) (2 . 7) (4 . 6) (1 . 5) (7 . 4) (5 . 3) (3 . 2) (6 . 1)) ((7 . 8) (2 . 7) (4 . 6) (1 . 5) (8 . 4) (5 . 3) (3 . 2) (6 . 1)) ((5 . 8) (1 . 7) (8 . 6) (4 . 5) (2 . 4) (7 . 3) (3 . 2) (6 . 1)) ((4 . 8) (1 . 7) (5 . 6) (8 . 5) (2 . 4) (7 . 3) (3 . 2) (6 . 1)) ((5 . 8) (2 . 7) (8 . 6) (1 . 5) (4 . 4) (7 . 3) (3 . 2) (6 . 1)) ((3 . 8) (7 . 7) (2 . 6) (8 . 5) (5 . 4) (1 . 3) (4 . 2) (6 . 1)) ((3 . 8) (1 . 7) (7 . 6) (5 . 5) (8 . 4) (2 . 3) (4 . 2) (6 . 1)) ((8 . 8) (2 . 7) (5 . 6) (3 . 5) (1 . 4) (7 . 3) (4 . 2) (6 . 1)) ((3 . 8) (5 . 7) (2 . 6) (8 . 5) (1 . 4) (7 . 3) (4 . 2) (6 . 1)) ((3 . 8) (5 . 7) (7 . 6) (1 . 5) (4 . 4) (2 . 3) (8 . 2) (6 . 1)) ((5 . 8) (2 . 7) (4 . 6) (6 . 5) (8 . 4) (3 . 3) (1 . 2) (7 . 1)) ((6 . 8) (3 . 7) (5 . 6) (8 . 5) (1 . 4) (4 . 3) (2 . 2) (7 . 1)) ((5 . 8) (8 . 7) (4 . 6) (1 . 5) (3 . 4) (6 . 3) (2 . 2) (7 . 1)) ((4 . 8) (2 . 7) (5 . 6) (8 . 5) (6 . 4) (1 . 3) (3 . 2) (7 . 1)) ((4 . 8) (6 . 7) (1 . 6) (5 . 5) (2 . 4) (8 . 3) (3 . 2) (7 . 1)) ((6 . 8) (3 . 7) (1 . 6) (8 . 5) (5 . 4) (2 . 3) (4 . 2) (7 . 1)) ((5 . 8) (3 . 7) (1 . 6) (6 . 5) (8 . 4) (2 . 3) (4 . 2) (7 . 1)) ((4 . 8) (2 . 7) (8 . 6) (6 . 5) (1 . 4) (3 . 3) (5 . 2) (7 . 1)) ((6 . 8) (3 . 7) (5 . 6) (7 . 5) (1 . 4) (4 . 3) (2 . 2) (8 . 1)) ((6 . 8) (4 . 7) (7 . 6) (1 . 5) (3 . 4) (5 . 3) (2 . 2) (8 . 1)) ((4 . 8) (7 . 7) (5 . 6) (2 . 5) (6 . 4) (1 . 3) (3 . 2) (8 . 1)) ((5 . 8) (7 . 7) (2 . 6) (6 . 5) (3 . 4) (1 . 3) (4 . 2) (8 . 1)))
#+end_example
* Exercise 2.43
** Prompt
Louis Reasoner has a slower implementation of queens than we do. His code difference is provided. Please explain why it is running slower, and if our program queens runs in T, how long would Louis's implementation take to run?
#+begin_src racket :exports code
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
#+end_src
** Solution
Louis's queen's implementation is slow because each iteration in the recursion is calling the next recursion step multiple times, causing repeated work. This problem compounds heavily fast.

To estimate runtime differences, we should look at the different components of the program that are executed at each of the recursive stage. Let's start with our version of the program. First, at the base case of k = 0, we immediately return, preventing work from occurring. Let's call this constant cost C_{0}. In the other case, we get the result from the k - 1 recursive case of the process. Here are just some quantitative estimation of the runtime of the process. First, we can observe that the base case of ~queen-cols~ has nearly no work being done, just a single conditional, followed by the construction of an empty board. In the recursive case of the program that we implement, we see that the size of the board we are working with multiplies by the width of the board. Finally, the ~safe?~ procedure is ran on the expanding result size. This problem could be tricky to model, since the runtime of ~safe?~ will grow linearly with the size of the board that has already been built, and the number of times that ~safe?~ is called also increases as we find more permutations. Luckily, our implementation of adjoin position is a constant time operation because we have decided to keep track of both the row and column for each of the queen, opening us up to future unordered implementations, while sacrificing twice the amount of memory as other solutions. Let's write the equation for the growth of our process now.

T_{k} = T_{k - 1} + ((b * C_{1} + k * C_{2}) * N_{k})

Where N_{k} is the number of returns from ~queens~ at the problem size, b is the board size, C_{1} is the time it takes to append a new queen on to the board and C_{2} is the time it takes to check if the queen is in a valid position one a board on size one. Now we should consider the base case, T_{0} and T_{0}' for the Louis implementation. We could say that it takes constant time C_{0}, and that it is nearly 0 due to the fact that it is one conditional. As a good engineer, I will just take that as fact, and make T_{0} disappear when faced with it.

Now we'll define the expression for the Louis case, which really just multiplies the recursive case by the width of the board, along with a few difference in the nesting.

T_{k}' = b * (T_{k - 1}' + C_{1} * N_{k} ) + (k * C_{2} * N_{k})

Now we should calculate how long it takes to run the two cases for b = 8.

#+begin_src racket :exports both
#lang sicp

(define (fold-right op initial seq)
  (if (null? seq)
      initial
      (op (car seq) (fold-right op initial (cdr seq)))))
(define (fold-left op initial seq)
  (define (iter acc remaining)
    (if (null? remaining)
        acc
        (iter (op (car remaining) acc) (cdr remaining))))
  (iter initial seq))
(define (filter predicate seq)
  (fold-right (lambda (x y)
                (if (predicate x)
                    (cons x y)
                    y))
              nil
              seq))

(define (flatmap f seq)
  (fold-right append nil (map f seq)))
(define (enumerate-range lower upper)
  (if (> lower upper)
      nil
      (cons lower (enumerate-range (+ lower 1) upper))))
(define (enumerate-interval lower upper)
  (enumerate-range lower upper))

;; Need to implement the representation of the queens on the board. We can
;; make this representation unordered if we store the col and row information
;; with the queen
(define empty-board nil)
(define (make-queen row col)
  (cons row col))
(define (get-row queen)
  (car queen))
(define (get-col queen)
  (cdr queen))
;; Looks like k actually does nothing for us yet
(define (adjoin-position nr k roq)
  (cons (make-queen nr k) roq))

(define (safe? k positions)
  (define (get-queen)
    (fold-left (lambda (x acc)
                 (if (null? acc)
                     (if (= (get-col x) k) x acc)
                     acc))
               nil
               positions))
  ;; check if the two queens are diag from each other
  (define (diag? a b)
    (= (abs (- (get-col a) (get-col b))) (abs (- (get-row a) (get-row b)))))
  ;; where target is the queen that is being tested against
  (define (safe?-aux target roq)
    (define (iter rest-of-queens)
      (cond
        [(null? rest-of-queens) #t]
        [(= (get-row target) (get-row (car rest-of-queens))) #f]
        [(= (get-col target) (get-col (car rest-of-queens))) #f]
        [(diag? target (car rest-of-queens)) #f]
        [else (iter (cdr rest-of-queens))]))
    (iter roq))
  (let ([k-queen (get-queen)])
    (safe?-aux k-queen
               (filter (lambda (x)
                         (not (and (= (get-col x) (get-col k-queen))
                                   (= (get-row x) (get-row k-queen)))))
                       positions))))

;; We are using board-size as a local global (all the other recursion will use
;; this value to test if the system is working as intended)
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        ;; Making the base board
        (list empty-board)
        ;; filter, safe? is given the current col being tested, and positions
        ;; actually already includes the parameter
        (filter (lambda (positions) (safe? k positions))
                (flatmap (lambda (rest-of-queens)
                           (map (lambda (new-row) (adjoin-position new-row k rest-of-queens))
                                (enumerate-interval 1 board-size)))
                         (queen-cols (- k 1))))))
  (queen-cols board-size))
(define (tk-prime b c1 c2)
  (define (iter k)
    (let ([nk (length (queens k))])
      (if (= k 0)
          0
          (+ (* b (+ (iter (- k 1)) (* c1 nk))) (* k c2 nk)))))
  (iter b))
(define (tk b c1 c2)
  (define (iter acc k)
    (if (> k b)
        acc
        (iter (+ acc (* (length (queens k)) (+ (* b c1) (* k c2)))) (+ k 1))))
  (iter 0 0))

(/ (tk-prime 8 0.1 0.5) (tk 8 0.1 0.5))
#+end_src

#+RESULTS
: 4135.805227781927

So we can see that the Louis implementation is approximately 3 order of magnitudes more expensive to run than our implementation.
* Exercise 2.44
** Prompt
Define ~up-split~ which is similar to ~right-split~, but upwards.
** Solution
Luckily for us, Racket's ~sicp~ package comes with the picture language, so we could just printout the solution to a file and render it on Org. In this solution, we will start to use ~org-tangle~, since it is helpful in literate programming.
#+header: :tangle ./src/exercise-2.44.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
#lang sicp
(#%require sicp-pict)
(define (up-split p n)
  (if (= n 0)
      p
      (let ((up (up-split p (- n 1))))
        (below p (beside up up)))))
(paint (up-split einstein 10))
#+end_src

#+RESULTS:
: #(struct:object:image-snip% ... ...)

#+name: higher-order-painters
#+begin_src racket :exports none
(define (up-split p n)
  (if (= n 0)
      p
      (let ((up (up-split p (- n 1))))
        (below p (beside up up)))))
(define (right-split p n)
  (if (= n 0)
      p
      (let ((right (right-split p (- n 1))))
        (beside p (below right right)))))
#+end_src


Result can be obtained through DrRacket with the ~sicp~ package.
* Exercise 2.45
** Prompt
Make ~right-split~ and ~up-split~ use a higher order procedure in it's implementation. Allow it to be built like the following.

#+begin_src racket :exports code
(define right-split (split beside below))
(define up-split (split below beside))
#+end_src
** Solution
Tangling again.

#+header: :tangle ./src/exercise-2.45.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
#lang sicp
(#%require sicp-pict)
(define (split first-proc second-proc)
  (define (proc p n)
    (if (= n 0)
        p
        (let ([rec (proc p (- n 1))]) (first-proc p (second-proc rec rec)))))
  proc)
(define right-split (split beside below))
(define up-split (split below beside))

(paint (right-split mark-of-zorro 10))
(paint (up-split einstein 10))
#+end_src

#+RESULTS:
: #(struct:object:image-snip% ... ...)
: #(struct:object:image-snip% ... ...)

Running this on DrRacket produced the expected result.
* Exercise 2.46
** Prompt
Make the constructor and selector for the vector we are working with. Following this, implement ~add-vect~, ~sub-vect~, and ~scale-vect~ that does the corresponding vector operations.
** Solution
#+name: vect-def
#+header: :tangle ./src/exercise-2.46.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (make-vect x y)
  (cons x y))
(define (xcor-vect v)
  (car v))
(define (ycor-vect v)
  (cdr v))

(define (add-vect a b)
  (make-vect (+ (xcor-vect a) (xcor-vect b)) (+ (ycor-vect a) (ycor-vect b))))
(define (sub-vect a b)
  (make-vect (- (xcor-vect a) (xcor-vect b)) (- (ycor-vect a) (ycor-vect b))))
(define (scale-vect s v)
  (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))
#+end_src
* Exercise 2.47
** Prompt
There are two possible constructors for the frames, make selectors for them.
#+caption: The two possible constructors for frames.
#+begin_src racket :exports code
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
#+end_src
** Solution
#+caption: List implementation selectors
#+name: list-frame
#+begin_src racket :exports both
#lang sicp
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (caddr f))
;; This is really bad testing since we should be testing with vectors
(define test-frame (make-frame 1 2 3 ))
(origin-frame test-frame)
(edge1-frame test-frame)
(edge2-frame test-frame)
#+end_src

#+RESULTS: list-frame
: 1
: 2
: 3

#+caption: Pair of pair implementation selectors
#+begin_src racket :exports both
#lang sicp
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))

(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (cddr f))
;; This is really bad testing since we should be testing with vectors
(define test-frame (make-frame 1 2 3))
(origin-frame test-frame)
(edge1-frame test-frame)
(edge2-frame test-frame)
#+end_src

#+RESULTS:
: 1
: 2
: 3

We can see that the selectors can obtain the values that corresponds to each of the argument used to build the frame.
* Exercise 2.48
** Prompt
A direct line segment on a plane could be represented as a vector from origin to the start point and a vector from origin from the origin to the end point. Using the vector representation from 2.46, define the representation for the segment with ~make-segment~ as the constructor and ~start-segment~ and ~end-segment~ as the selectors
** Solution
Will need to import the definition for vectors.

#+name: segment-representation
#+begin_src racket :exports both
(define (make-vect x y)
  (cons x y))
(define (xcor-vect v)
  (car v))
(define (ycor-vect v)
  (cdr v))

(define (add-vect a b)
  (make-vect (+ (xcor-vect a) (xcor-vect b)) (+ (ycor-vect a) (ycor-vect b))))
(define (sub-vect a b)
  (make-vect (- (xcor-vect a) (xcor-vect b)) (- (ycor-vect a) (ycor-vect b))))
(define (scale-vect s v)
  (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))

(define (make-segment start end)
  (cons start end))
(define (start-segment s) (car s))
(define (end-segment s) (cdr s))
#+end_src
* Exercise 2.49
** Prompt
Use ~segment->painter~ to define the following primitive painters
a. The painter that draws the outline of the designated frame
b. The painter that draws an "X" by connecting opposite corners of the frame
c. The painter that draws a diamond shape by connecting the midpoints of the sides
** Solution
Great thing about the sicp language in Racket is that it comes with a picture language implementation that already implements ~segment~ and ~vect~.
#+name: vect-consts
#+begin_src racket :exports code
(define bottom-left (make-vect 0 0))
(define bottom-right (make-vect 1 0))
(define top-left (make-vect 0 1))
(define top-right (make-vect 1 1))
#+end_src

#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
;; Setting up tangle file
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

*** Part a
#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports code :noweb yes
; we just need to make a list that makes square
(define outline-painter (segments->painter (list
                                            (make-segment bottom-left bottom-right)
                                            (make-segment bottom-right top-right)
                                            (make-segment top-right top-left)
                                            (make-segment top-left bottom-left))))

(display "Part a. The outline")
(newline)
(paint outline-painter)
#+end_src

#+RESULTS:
: #(struct:object:image-snip% ... ...)
*** Part b
You only need two segments to draw an x in the frame
#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports code :noweb yes
(define cross-painter (segments->painter (list
                                            (make-segment top-left bottom-right)
                                            (make-segment top-right bottom-left))))

(display "Part b. The cross")
(newline)
(paint cross-painter)
#+end_src
*** Part c
Build the diamond painter. In this solution, we over engineer and add a vector average procedure.
#+name: vector-average
#+begin_src racket :exports code
(define (vector-average . v)
  (define (count-aux x acc)
    (if (null? x)
        acc
        (count-aux (cdr x) (+ acc 1))))
  (define (count x)
    (count-aux x 0))
  (define (vector-sum-aux vecs acc)
    (if (null? vecs)
        acc
        (vector-sum-aux (cdr vecs) (vector-add acc (car vecs)))))
  (define (vector-sum vecs)
    (vector-sum-aux vecs zero-vector))
  (vector-scale (/ 1 (count v)) (vector-sum v)))
#+end_src

#+header: :tangle ./src/exercise-2.49.rkt :mkdirp yes :comments link
#+begin_src racket :exports code :noweb yes
<<vector-average>>

(define diamond-painter
  (segments->painter
   (list
    (make-segment (vector-average bottom-left top-left) (vector-average top-left top-right))
    (make-segment (vector-average top-left top-right) (vector-average top-right bottom-right))
    (make-segment (vector-average top-right bottom-right) (vector-average bottom-right bottom-left))
    (make-segment (vector-average bottom-right bottom-left) (vector-average bottom-left top-left)))))

(display "Part c. The diamond")
(newline)
(paint diamond-painter)
#+end_src
*** Part d
Build the wave painter.

- Actually, I won't be doing this. I don't think that it is adding that value that I want from this book. We'll see each other in the next exercise.
* Exercise 2.50
** Prompt
Define a ~flip-horiz~ that will flip a painter horizontally (left-right flip).
** Solution
#+caption: setup
#+header: :tangle ./src/exercise-2.50.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

#+caption: flip-horiz implementation
#+header: :tangle ./src/exercise-2.50.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (flip-horiz painter)
  (transform-painter painter
                     bottom-right
                     bottom-left
                     top-right))
#+end_src

#+caption: flip-horiz test
#+header: :tangle ./src/exercise-2.50.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(display "einstein")
(newline)
(paint einstein)

(display "flipped einstein")
(newline)
(paint (flip-horiz einstein))
#+end_src

* Exercise 2.51
** Prompt
Define the ~below~ procedure that takes in two painters and put the first painter below the second painter. Make this procedure twice, once the same way as the provided ~beside~ procedure, and the second time using the ~beside~ procedure.
** Solution

*** Part a
Implement ~below~ analogous to ~beside~.

#+caption: setup
#+header: :tangle ./src/exercise-2.51-a.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

#+caption: below implementation
#+header: :tangle ./src/exercise-2.51-a.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (below painter-1 painter-2)
  (let ([split-point (make-vect 0 0.5)])
    (let ([paint-below (transform-painter painter-1 (make-vect 0 0) (make-vect 1 0) split-point)]
          [paint-above (transform-painter painter-2 split-point (make-vect 1 0.5) (make-vect 0 1))])
      (lambda (frame)
        (paint-below frame)
        (paint-above frame)))))
#+end_src

#+caption: below test a
#+header: :tangle ./src/exercise-2.51-a.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(display "einstein")
(newline)
(paint einstein)

(display "below einstein")
(newline)
(paint (below einstein einstein))
#+end_src

*** Part b
Implementing ~below~ using beside and some transformations. We will pretend that a rotate procedure has already been implemented. We will rotate both input values clockwise, and then rotate the entire full image counter clockwise.

#+caption: setup
#+header: :tangle ./src/exercise-2.51-b.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<vect-consts>>
#+end_src

#+caption: below implementation
#+header: :tangle ./src/exercise-2.51-b.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
(define (below painter-1 painter-2)
  (let ([paint-below (rotate90 painter-1)]
        [paint-above (rotate90 painter-2)])
    (lambda (frame) ((rotate270 (beside paint-below paint-above)) frame))))
#+end_src

#+caption: below test a
#+header: :tangle ./src/exercise-2.51-b.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(display "einstein")
(newline)
(paint einstein)

(display "below einstein")
(newline)
(paint (below einstein einstein))
#+end_src

* Exercise 2.52
** Prompt
Leverage the concept of stratification by changing different levels of the system. Here are what needs to be done.
1. Add more segment to a painter
2. Change ~corner-split~ pattern
3. Modify ~square-limit~ so that the corners are in different patterns
** Solution
We're going to implement the three features at the same time. For the first requirement, we will swap from using wave painter to using the diamond painter, and this time, we will make sure that this new version of painter is asymmetrical.

#+caption: setup
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports none :noweb yes
#lang sicp
(#%require sicp-pict)
<<higher-order-painters>>
<<vect-consts>>
<<vector-average>>
#+end_src

#+caption: adding segment to a painter (not wave, since I did not make that)
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
;; Adding new segments to make the painter assymmetrical
(define diamond-painter
  (let ([mid-left (vector-average bottom-left top-left)]
        [top-central (vector-average top-left top-right)]
        [mid-right (vector-average top-right bottom-right)]
        [bottom-central (vector-average bottom-right bottom-left)]
        [middle (make-vect 0.5 0.5)])
    (segments->painter (list (make-segment mid-left top-central)
                             (make-segment top-central mid-right)
                             (make-segment mid-right bottom-central)
                             (make-segment bottom-central mid-left)
                             (make-segment middle (vector-average middle top-central))
                             (make-segment middle (vector-average middle mid-right))
                             (make-segment (vector-average middle mid-right)
                                           (vector-average middle top-central))))))
#+end_src

We're going to make the corner more asymmetrical as well.

#+caption: change the corner split pattern
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
;; Adding new segments to make the painter assymmetrical
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ([top (up-split painter (- n 1))])
        (let ([top-right (beside top top)]
              [corner (corner-split painter (- n 1))])
          (beside (below white corner)
                  (below painter top-right))))))

#+end_src

Instead of flipping the top-left and bottom-right corner, we're going to move to rotating them.

#+caption: change the square limit procedure so that the corners are more interesting
#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports code
;; Adding new segments to make the painter assymmetrical
(define (square-limit painter n)
  (let ([cornered-painter (corner-split painter n)])
    (beside (below (rotate180 cornered-painter) (rotate90 cornered-painter))
            (below (rotate270 cornered-painter) cornered-painter))))
#+end_src


#+header: :tangle ./src/exercise-2.52.rkt :mkdirp yes :comments link
#+begin_src racket :exports none
(paint (square-limit diamond-painter 5))
#+end_src

Now we're done.
* Exercise 2.53
** Prompt
Describe what the interpreter would output with the following expressions
** Solution
We will write the expected output as the comment. We can easily verify that this is correct by running the code.

#+begin_src racket :exports code
#lang sicp

(list 'a 'b 'c)
;; (a b c)
(list (list 'george))
;; ((george))
(cdr '((x1 x2) (y1 y2)))
;; ((y1 y2))
(cadr '((x1 x2) (y1 y2)))
;; (y1 y2)
(pair? (car '(a short list)))
;; false
(memq 'red '((red shoes) (blue socks)))
;; false
(memq 'red '(red shoes blue socks))
;; (red shoes blue socks)
#+end_src

#+RESULTS:
: (a b c)
: ((george))
: ((y1 y2))
: (y1 y2)
: #f
: #f
: (red shoes blue socks)

* Exercise 2.54
** Prompt
Define a procedure called ~equal?~ that will compare two lists using ~eq?~ and if the element is a list, navigate that one and do the same as well.
** Solution
We could implement this recursively. Our strategy is to move through both lists at the same time.

#+begin_src racket :exports both
#lang sicp
(define (equal? a b)
  (cond
    [(and (null? a) (null? b)) true]
    [(and (pair? (car a)) (pair? (car b)))
     (if (equal? (car a) (car b))
         (equal? (cdr a) (cdr b))
         false)]
    [(not (eq? (car a) (car b))) false]
    [else (equal? (cdr a) (cdr b))]))

(equal? '(this is a list) '(this is a list))
(equal? '(this is a list) '(this (is a) list))
#+end_src

#+RESULTS:
: #t
: #f

Raw testing result showed that we successfully implemented the procedure.
* Exercise 2.55
** Prompt
Eva Lu Ator types to the interpreter the following expression.

#+begin_src racket :exports both
#lang sicp
(car ''abracadabra)
#+end_src

#+RESULTS:
: quote

Why the heck did we get ~quote~. Explain.
** Solution
The ~'~ operator in Scheme will treat the values following it as the symbol, and not the value. We should wonder, how does Scheme actually interpret this? Well since we are getting the ~quote~ from a ~car~ it is safe to assume that ~''abracadabra~ will return either a pair or a list. I will not pretend I know the answer right now, so I will do a little experiment.

#+begin_src racket :exports both
#lang sicp
(car ''abracadabra)
''abracadabra
'abracadabra
(car ''(a b c d))
''(a b c d)
'''(a b c d)
(quote (a b c d))
#+end_src

#+RESULTS:
: quote
: (quote abracadabra)
: abracadabra
: quote
: (quote (a b c d))
: (quote (quote (a b c d)))
: (a b c d)

Interesting, it looks like by accessing ~'abracadabra~ with another ~'~ we are able to see the representation for the symbol access. It is a compound object with the first element being the ~quote~ symbol, and the second element being the symbol being shown. This must be used to tell the Scheme interpreter how to access and how the value that is prepended with a quote. More accurately, prepending with a ~'~ will tell the interpreter to return the symbol, and not the value. In our experiment, we did ~'''(a b c d)~ which returned ~(quote (quote (a b c d)))~ and we see that ~(quote (a b c d))~ returns ~(a b c d)~. I think with these tests, we can see that ~quote~ is a procedure that returns its parameter as a symbol. We can also see that ~'~ is actually syntactic sugar for the ~quote~ procedure, meaning that ~(car ''abradacadabra)~ is actually just ~(car (quote (quote abradacadabra)))~ where ~quote~ will evaluate first due to applicative ordered evaluation, resulting in ~(car (quote abradacadabra))~ which will finally evaluate to ~quote~.
* Exercise 2.56
** Prompt
We're working with a system for symbolic differentiation. Implementation for differentiating sums, products, variables, and constant has been given to us. We have to reduce the expression if it is simple to do so. In this exercise, extend the system to handle variables with exponents.
** Solution
Below is the implementation that is provided to us. We will proceed to extend the implementation to add exponents of variables. We'll import this around as a base to other exercises that work with symbolic differentiation.

#+name: deriv-base
#+begin_src racket :exports code
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [else (error "unknown expression type: DERIV" exp)]))
#+end_src

#+name: deriv-base-dependencies
#+begin_src racket :exports code
(define (variable? x)
  (symbol? x))
(define (same-variable? x y)
  (and (variable? x) (variable? y) (eq? x y)))
(define (=number? exp val)
  (and (number? exp) (= exp val)))
#+end_src

#+name: deriv-base-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y) (+ x y))]
    [else (list '+ x y)]))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s)
  (cadr s))
(define (augend s)
  (caddr s))
#+end_src

#+name: deriv-base-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    [else (list '* x y)]))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p)
  (cadr p))
(define (multiplicand p)
  (caddr p))
#+end_src

#+RESULTS: deriv-base-dependencies

#+name: deriv-base-test
#+begin_src racket :exports code
(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

We'll use the strategy that often used in sicp, which is to actually use the abstraction in the algorithm before building the representation. We will write this out.

#+name: deriv-exponentiation
#+begin_src racket :exports code
;; deriv with exponentiation
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [(exponentiation? exp)
     (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1)))]
    [else (error "unknown expression type: DERIV" exp)]))
#+end_src

#+name: deriv-base-exponentiation
#+begin_src racket :exports code
;; Need to now make the representation of the exponentiation expression
(define (make-exponentiation base exponent)
  (cond [(=number? exponent 0) 1]
        [(=number? exponent 1) base]
        [else (list '** base exponent)]))

(define (exponentiation? exp) (and (pair? exp) (eq? (car exp) '**)))
(define (base exp) (cadr exp))
(define (exponent exp) (caddr exp))
#+end_src

Now we will test our implementation.

#+begin_src racket :exports both :noweb yes
#lang sicp
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<deriv-exponentiation>>
<<deriv-base-exponentiation>>
<<deriv-base-test>>
(deriv '(+ (* x y) (** x 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))

The test is not exhaustive, but this does look right.

* Exercise 2.57: Multiple arguments to product and sum
** Prompt
The goal here is to extend the representation of both product and sum to handle arbitrary amount of parameters.
** Solution
We have to make sure that we don't actually need to change the implementation of the ~deriv~ procedure to make this work. Here is the current strategy that we will attempt. We don't really need dynamic parameter unpacking, we just need to make the selector be able to retrieve representation of the sum expression that have more than two elements properly. We should be surgical with where we make the changes.

In our implementation, we made the constructor merge two instances of sums, and made the augend selector handle the case where there are more than two operands. We then do the analogous implementation on the product version.

#+name: deriv-multiple-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y)) (+ x y)]
    [(sum? y) (make-sum (make-sum x (addend y) ) (augend y))]
    [else (list '+ x y)]))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s)
  (cadr s))
(define (augend s)
  (let ([ag (cddr s)])
      (cond [(null? (cdr ag)) (car ag)]
            [(null? (cddr ag)) (make-sum (car ag) (cadr ag))]
            [else (make-sum (car ag) (cons '+ (cdr ag)))])))
#+end_src


#+name: deriv-multiple-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    [(product? y) (make-product (make-product x (multiplier y)) (multiplicand y))]
    [else (list '* x y)]))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p)
  (cadr p))
(define (multiplicand p)
  (let ([mp (cddr p)])
    (cond
      [(null? (cdr mp)) (car mp)]
      [(null? (cddr mp)) (make-product (car mp) (cadr mp))]
      [else (make-product (car mp) (cons '* (cdr mp)))])))
#+end_src


#+begin_src racket :exports both :noweb yes
#lang sicp
<<deriv-base-dependencies>>
<<deriv-multiple-sum>>
<<deriv-multiple-product>>
<<deriv-exponentiation>>
<<deriv-base-exponentiation>>
<<deriv-base-test>>
(deriv '(+ (* x y) (** x 8)) 'x)
(deriv '(* x y (+ x 3)) 'x)
(deriv '(* x y (+ x 3) 0) 'x)
(deriv '(* x y (+ x 3) 1 y) 'x)
(deriv '(+ x y (* x 3) (** x 7)) 'x)
(deriv '(+ x y (* x 3) 0 (** x 7)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))
: (+ (* x y) (* y (+ x 3)))
: 0
: (+ (* (* x y) y) (* (* y (+ x 3)) y))
: (+ 4 (* 7 (** x 6)))
: (+ 4 (* 7 (** x 6)))
* Exercise 2.58: Infix operators
** Prompt
Now modify the program to work on a representation that is infix. Make two versions, first version being that all group of expression is binary, and the second using actual normal algebraic syntax, with PEDMAS order of operations.
** Solution
*** Part A
We'll implement the system to the state where it will correctly evaluate binary infix operations. The chained implementation will be done in part B.
#+name: deriv-infix-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y)) (+ x y)]
    [else (list x '+ y)]))
(define (sum? x)
  (and (pair? x) (eq? (cadr x) '+)))
(define (addend s)
  (car s))
(define (augend s)
  (caddr s))
#+end_src


#+name: deriv-infix-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    [else (list x '* y)]))
(define (product? x)
  (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p)
  (car p))
(define (multiplicand p)
  (caddr p))
#+end_src

#+name: deriv-infix-exponentiation
#+begin_src racket :exports code
;; Need to now make the representation of the exponentiation expression
(define (make-exponentiation base exponent)
  (cond [(=number? exponent 0) 1]
        [(=number? exponent 1) base]
        [else (list base '** exponent)]))

(define (exponentiation? exp) (and (pair? exp) (eq? (cadr exp) '**)))
(define (base exp) (car exp))
(define (exponent exp) (caddr exp))
#+end_src


#+begin_src racket :exports both :noweb yes
#lang sicp
<<deriv-base-dependencies>>
<<deriv-infix-sum>>
<<deriv-infix-product>>
<<deriv-infix-exponentiation>>
<<deriv-exponentiation>>
(deriv '(x + 3) 'x)
(deriv '(x * y) 'x)
(deriv '(x * y) 'y)
(deriv '((x * y) * (x + 3)) 'x)
(deriv '((x * y) * (x + 3)) 'y)
(deriv '((x * y) + (x ** 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: ((x * y) + (y * (x + 3)))
: (y + (8 * (x ** 7)))

*** Part B
In this part, we are trying to parse normal algebraic expressions, like those that people would use. This is the type of parsing that calculators do, and to do this cleanly, we'll make an abstract syntax tree. Another goal is that we should not need to change how the ~deriv~ method works.

We'll treat the representation as a list, but we'll still recursively split it into a sequence of binary operations. The way that it has to work, since we are using recursion is that the lowest priority operation will actually just take the highest precedence, in that an expression that contains the lowest level operator will be treated as a statement of that operator. What this does is that the higher level operators will have to check for the previous level, as to allow them to take precedence in the recursion. (Taking precedence actually makes it evaluate last in our recursive architecture).

#+name: deriv-normal-common
#+begin_src racket :exports code
;; Returns true if the provided symbol, v, is in the list, l
(define (contain? l v)
  (define (iter li)
    (cond
      [(null? li) false]
      [(eq? (car li) v) true]
      [else (iter (cdr li))]))
  (iter l))

;; Returns list of all elements before the value, v
(define (before-first l v)
  (cond
    [(null? l) l]
    [(eq? (car l) v) nil]
    [else (cons (car l) (before-first (cdr l) v))]))

;; Returns list of all elements after the value, v
(define (after-first l v)
  (let ([ret (memq v l)])
    (if (pair? ret) (cdr ret) nil)))
#+end_src

#+name: deriv-normal-sum
#+begin_src racket :exports code
(define (make-sum x y)
  (cond
    [(=number? x 0) y]
    [(=number? y 0) x]
    [(and (number? x) (number? y)) (+ x y)]
    ;; [(sum? y) (make-sum (make-sum x (addend y) ) (augend y))]
    [else (list x '+ y)]))
(define (sum? x)
  (and (pair? x) (contain? x '+)))
;; Assumption is that the sum check has already completed before this procedure
;; is called.
;; addend will be the elements before the first '+ symbol
(define (addend s)
  (let ([v (before-first s '+)])
    (if (null? (cdr v))
        (car v)
        v)))
(define (augend s)
  (let ([v (after-first s '+)])
    (if (null? (cdr v))
        (car v)
        v)))
#+end_src


#+name: deriv-normal-product
#+begin_src racket :exports code
(define (make-product x y)
  (cond
    [(or (=number? x 0) (=number? y 0)) 0]
    [(=number? x 1) y]
    [(=number? y 1) x]
    [(and (number? x) (number? y)) (* x y)]
    ;; [(product? y) (make-product (make-product x (multiplier y)) (multiplicand y))]
    [else (list x '* y)]))
;; This is more tricky. It is product if there is a * in the least nested
;; layer of the expression
(define (product? x)
  (and (pair? x) (not (contain? x '+)) (contain? x '*)))
;; Assuming that product check has always happened before this line
(define (multiplier p)
  (let ([val (before-first p '*)])
    (if (null? (cdr val)) (car val) val)))
(define (multiplicand p)
  (let ([val (after-first p '*)])
    (if (null? (cdr val)) (car val) val)))
#+end_src

#+name: deriv-normal-exponentiation
#+begin_src racket :exports code
;; Need to now make the representation of the exponentiation expression
(define (make-exponentiation base exponent)
  (cond [(=number? exponent 0) 1]
        [(=number? exponent 1) base]
        [else (list base '** exponent)]))

(define (exponentiation? exp) (and (pair? exp) (not (or (contain? exp '+) (contain? exp '*))) (contain? exp '**)))
(define (base exp)
  (car exp))
(define (exponent exp) (caddr exp))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<assertion-suite>>
<<deriv-base-dependencies>>
<<deriv-normal-common>>
<<deriv-normal-sum>>
<<deriv-normal-product>>
<<deriv-normal-exponentiation>>
<<deriv-exponentiation>>
(assert-eq "sum predicate check" (sum? '(x + 3)) #t)
(assert-eq "sum predicate check" (sum? '(x * 3)) #f)
(assert-eq "multiple sum predicate check" (sum? '(x + 3 + 4 + y)) #t)
(assert-eq "normal expression, with one product predicate check" (sum? '(x + 3 * 4 + y)) #t)
(assert-eq "normal expression, one product predicate check" (sum? '(x * 3 + 4 + y)) #t)
(assert-eq "sum predicate on variable (should fail)" (sum? '(x)) #f)
(assert-eq "sum predicate on variable (should fail)" (sum? 'x) #f)
(assert-eq "sum predicate on number (should fail)" (sum? '(3)) #f)
(assert-eq "getting the adden" (addend '(3 + 4)) 3)
(assert-eq "getting the augend" (augend '(3 + 4)) 4)
(assert-eq "getting the augend" (augend '(3 + x + y)) '(x + y))
(assert-eq "getting the augend" (augend '(3 + x + y + z)) '(x + y + z))
(assert-eq "getting the addend" (addend '(x + 3 * 4 + y)) 'x)
(assert-eq "getting the augend" (augend '(x + 3 * 4 + y)) '(3 * 4 + y))
(assert-eq "getting the addend" (addend '(x * 3 + 4 + y)) '(x * 3))
(assert-eq "getting the addend" (augend '(x * 3 + 4 + y)) '(4 + y))
(assert-eq "product predicate check" (product? '(x * 3)) #t)
(assert-eq "product predicate check" (product? '(x + 3)) #f)
(assert-eq "multiple product predicate check" (product? '(x * 3 * y)) #t)
(assert-eq "multiple product predicate check" (product? '(x + 3 + y)) #f)
(assert-eq "multiple product predicate check" (product? '(x + 3 * y)) #f)
(assert-eq "multiple product predicate check" (product? '(x * 3 + y)) #f)
(assert-eq "product predicate on variable (should fail)" (product? '(x)) #f)
(assert-eq "product predicate on variable (should fail)" (product? 'x) #f)
(assert-eq "product predicate on number (should fail)" (product? '(3)) #f)
(assert-eq "multiple exponent predicate check" (exponentiation? '(x * 3 * y)) #f)
(assert-eq "multiple exponent predicate check" (exponentiation? '(x * 3 * y ** 2)) #f)
(assert-eq "multiple exponent predicate check" (exponentiation? '(x ** 3)) #t)
(deriv '(x + 3) 'x)
(deriv '(x + 3 + y) 'x)
(deriv '(x * y) 'x)
(deriv '((x * y) * (x + 3)) 'x)
(deriv '(x + 3 * (x + y + 2)) 'x)
(deriv '((x * y) + (x ** 8)) 'x)
#+end_src

#+RESULTS:
#+begin_example
pass: sum predicate check value: #t expected: #t
pass: sum predicate check value: #f expected: #f
pass: multiple sum predicate check value: #t expected: #t
pass: normal expression, with one product predicate check value: #t expected: #t
pass: normal expression, one product predicate check value: #t expected: #t
pass: sum predicate on variable (should fail) value: #f expected: #f
pass: sum predicate on variable (should fail) value: #f expected: #f
pass: sum predicate on number (should fail) value: #f expected: #f
pass: getting the adden value: 3 expected: 3
pass: getting the augend value: 4 expected: 4
pass: getting the augend value: (x + y) expected: (x + y)
pass: getting the augend value: (x + y + z) expected: (x + y + z)
pass: getting the addend value: x expected: x
pass: getting the augend value: (3 * 4 + y) expected: (3 * 4 + y)
pass: getting the addend value: (x * 3) expected: (x * 3)
pass: getting the addend value: (4 + y) expected: (4 + y)
pass: product predicate check value: #t expected: #t
pass: product predicate check value: #f expected: #f
pass: multiple product predicate check value: #t expected: #t
pass: multiple product predicate check value: #f expected: #f
pass: multiple product predicate check value: #f expected: #f
pass: multiple product predicate check value: #f expected: #f
pass: product predicate on variable (should fail) value: #f expected: #f
pass: product predicate on variable (should fail) value: #f expected: #f
pass: product predicate on number (should fail) value: #f expected: #f
pass: multiple exponent predicate check value: #f expected: #f
pass: multiple exponent predicate check value: #f expected: #f
pass: multiple exponent predicate check value: #t expected: #t
1
1
y
((x * y) + (y * (x + 3)))
4
(y + (8 * (x ** 7)))
#+end_example

And voila! We are now able to symbolically differentiate a smaller subset of normal algebraic expressions.
* Exercise 2.59
** Prompt
Implement ~union-set~ for the unordered-list representation of a set
** Solution
The following is the provided code from sicp.

#+name: set-unordered-list
#+begin_src racket :exports code
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(equal? x (car set)) true]
    [else (element-of-set? x (cdr set))]))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond
    [(or (null? set1) (null? set2)) '()]
    [(element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))]
    [else (intersection-set (cdr set1) set2)]))
#+end_src

Set unions are the combination of two sets, all we would have to do is to make sure that we don't include an element that already exists.

#+name: set-unordered-list-union
#+begin_src racket :exports code
(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [(element-of-set? (car set1) set2) (union-set (cdr set1) set2)]
    [else (cons (car set1) (union-set (cdr set1) set2))]))
#+end_src

The following is just some checks to make sure that union is unioning.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<set-unordered-list>>
<<set-unordered-list-union>>
<<assertion-suite>>
(define seta '(a b c d e))
(define setb '(d e f g h i j))
(intersection-set seta setb)
(union-set seta setb)
#+end_src

#+RESULTS:
: (d e)
: (a b c d e f g h i j)

Judging by the result of evaluating the code block, the union is unioning.
* Exercise 2.60
** Prompt
Now let the representation allow for duplicates. Re-implement the selectors and constructors, then compare the efficiency of this representation with the noon-duplicate version.
** Solution

#+name: set-unordered-list-duplicate
#+begin_src racket :exports code
;; Does not need to change
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(equal? x (car set)) true]
    [else (element-of-set? x (cdr set))]))

;; Always add without checking. This is how we get duplicates
(define (adjoin-set x set)
  (cons x set))

(define (intersection-set set1 set2)
  (cond
    [(or (null? set1) (null? set2)) '()]
    [(element-of-set? (car set1) set2) (adjoin-set (car set1) (intersection-set (cdr set1) set2))]
    [else (intersection-set (cdr set1) set2)]))

(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [else (cons (car set1) (union-set (cdr set1) set2))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<set-unordered-list-duplicate>>
<<assertion-suite>>
(define seta '(a b c d e))
(define setb '(d e f g h i j))
(define int-set (intersection-set seta setb) )
(define uni-set (union-set seta setb) )
(element-of-set? 'a int-set)
(element-of-set? 'a uni-set)
int-set
uni-set
#+end_src

#+RESULTS:
: #f
: #t
: (d e)
: (a b c d e d e f g h i j)

Let's talk about the efficiency of this implementation. Adjoining the set, unioning a set is faster, however, after enough duplicates have been inserted into the set, lookup will become slower. This means in general, both the containment predicate and set intersection will perform worse than the non-duplicate version. The specifics of when each implementation is better than the other is very dependent on the usecase. The generalization here is that many insertion with few containment checks make duplicate good, few insertions with many containment checks make non-duplicate good.
* Exercise 2.61
** Prompt
We have now looked at the ordered list representation of the set, and how it could make intersection operations linear due to the invariant of the representation being sorted, as we no longer have to search the entire list again everytime. This is very akin to merge sort. In fact, merge sort might be easier to implement on lisp than other sorting algorithms.

Now the goal of this exercise is to implement ~adjoin-set~ and show how using ordering can, on average, make the implementation take half the steps of the unordered representation.
** Solution

#+name: ordered-list-set-base
#+begin_src racket :exports code
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(= x (car set)) true]
    [(< x (car set)) false]
    [else (element-of-set? x (cdr set))]))

(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ([x1 (car set1)]
            [x2 (car set2)])
        (cond
          [(= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2)))]
          [(< x1 x2) (intersection-set (cdr set1) set2)]
          [else (intersection-set set1 (cdr set2))]))))
#+end_src

#+name: ordered-list-set-adjoin
#+begin_src racket :exports code
;; let's make an iterative closure to check if we have gotten to the thing.
;; This procedure can either return the original set or a newly sorted
;; set.
(define (adjoin-set x set)
  (cond [(null? set) (list x)]
        [(= x (car set)) set]
        [(< x (car set)) (cons x set)]
        [else (cons (car set) (adjoin-set x (cdr set)))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<ordered-list-set-base>>
<<ordered-list-set-adjoin>>
(define test-set (list 1 2 3 6 7 10))
test-set
(adjoin-set 5 test-set)
(adjoin-set 3 test-set)
(adjoin-set 100 test-set)
#+end_src

#+RESULTS:
: (1 2 3 6 7 10)
: (1 2 3 5 6 7 10)
: (1 2 3 6 7 10)
: (1 2 3 6 7 10 100)

I'll just describe how we took advantage of ordering to half the steps on average vs the unordered method. Because ordered, we can find out when the element does not exist in the set as we traverse from the first element to the last element by seeing when the value we are trying to add is lower than the element we are looking at, as all elements after that will be even larger. If we managed to get to the end of the list, we know that the element does not exist in the set, and that it is larger than all the other element, so we could place it there.
* Exercise 2.62
** Prompt
Make ~union-set~ for ordered list set.
** Solution

#+name: ordered-list-set-union
#+begin_src racket :exports code
(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [else
     (let ([x1 (car set1)]
           [x2 (car set2)])
       (cond
         [(= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2)))]
         [(< x1 x2) (cons x1 (union-set (cdr set1) set2))]
         [(< x2 x1) (cons x2 (union-set set1 (cdr set2)))]))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<ordered-list-set-base>>
<<ordered-list-set-adjoin>>
<<ordered-list-set-union>>
(define test-set (list 1 2 3 6 7 10))
(define test-set2 (list 5 6 7 8 9 10))
test-set
test-set2
(union-set test-set test-set2)
#+end_src

#+RESULTS:
: (1 2 3 6 7 10)
: (5 6 7 8 9 10)
: (1 2 3 5 6 7 8 9 10)
* Exercise 2.63
** Prompt
We are provided two procedures that transforms a tree into a list. Answer the following two questions:
a. Do the two procedures generate the same output for every tree? If not, how do they differ? We are provided three input trees, what list do they make?
b. Do the two procedures have the same order of growth (balanced tree only)? If not, which one grows more slowly?
** Solution
#+name: base-tree-representation
#+begin_src racket :exports code
(define (entry tree)
  (car tree))
(define (left-branch tree)
  (cadr tree))
(define (right-branch tree)
  (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
#+end_src

#+name: flat-tree-1
#+begin_src racket :exports code
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree) (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree) (copy-to-list (right-branch tree) result-list)))))
  (copy-to-list tree '()))
#+end_src

#+name: trees-2.16
#+begin_src racket :exports code
(define tree-1
  (make-tree 7
             (make-tree 3 (make-tree 1 '() '()) (make-tree 5 '() '()))
             (make-tree 9 '() (make-tree 11 '() '()))))
(define tree-2
  (make-tree 3
             (make-tree 1 '() '())
             (make-tree 7 (make-tree 5 '() '()) (make-tree 9 '() (make-tree 11 '() '())))))
(define tree-3
  (make-tree 5
             (make-tree 3  (make-tree 1 '() '()) '())
             (make-tree 9 (make-tree 7 '() '()) (make-tree 11 '() '()))))
#+end_src
*** Part a
They make the same output. They are both built with recursive breakdown of the tree where each unit of the procedure is combining the flatten list of the left subtree is combined with the right flattened list of the right subtree with the entry as the value in between these new flattened list. This means that the output of both the procedures will generate the same value. Actually, because of the invariant of the binary tree, the output list will just be a sorted list.

Running the procedure on all three trees in [[trees-2.16]] will result in the following lists.

#+beg
(1 3 5 7 9 11)
(1 3 5 7 9 11)
(1 3 5 7 9 11)
#+end_example

The above solution was done before evaluating the procedure on the sample trees. As a good engineer, we should double check the work.

#+begin_src racket :exports both :noweb yes
#lang sicp
<<base-tree-representation>>
<<flat-tree-1>>
<<trees-2.16>>
(tree->list-1 tree-1)
(tree->list-1 tree-2)
(tree->list-1 tree-3)
(tree->list-2 tree-1)
(tree->list-2 tree-2)
(tree->list-2 tree-3)
#+end_src

#+RESULTS:
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)
: (1 3 5 7 9 11)

Wow, that's crazy.
*** Part b
Do they have the same order of growth? If not, which one grows more slowly.

Well this question is implementation specific. If we're using the Scheme in the SICP lectures, it's important to analyze ~append~. ~append~ is a procedure that combines two LISP lists together, and since the Scheme list is a singly linked list, ~append~ must generate a new list by iterating over all element of one of them, and using ~cons~ to make the combined one. Although we are under the illusion that we arrive at each nodes once, ~tree->list-1~ is actually \(\Theta \left( n^{2} \right)\), while ~tree->list-2~ grows at \(\Theta \left( n \right)\), which is really a lession on how data structures could subtly affect the best algorithm implementation.
* Exercise 2.64
** Prompt
We are given a procedure that converts a list to a tree. It uses a helper procedure called ~partial-tree~ that takes an argument ~n~ for the number of elements of the list to be transformed into a tree, and the list of elements to be transformed. Answer the following two questions:
a. Write a short paragraph explaining, as clearly as possible, how ~partial-tree~ works. Then draw the tree ~(1 3 5 7 9 11)~ produced from ~list->tree~
b. What is the order of growth for the ~list->tree~ for a list of ~n~ elements?
** Solution
#+name: list->tree
#+begin_src racket :exports code
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ([left-size (quotient (- n 1) 2)])
        (let ([left-result (partial-tree elts left-size)])
          (let ([left-tree (car left-result)]
                [non-left-elts (cdr left-result)]
                [right-size (- n (+ left-size 1))])
            (let ([this-entry (car non-left-elts)]
                  [right-result (partial-tree (cdr non-left-elts) right-size)])
              (let ([right-tree (car right-result)]
                    [remaining-elts (cdr right-result)])
                (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))
#+end_src
*** Part a
Let's explain what the ~partial-tree~ procedure is doing. This helper procedure lets build arbitrary balanced trees in a recursive manner. The input parameter ~n~ and the ~remaining-elts~ return value allow flexible use of the procedure. Let's get into what it is doing. At a high level, the procedure is splitting the input list into left side, and right side, where it will build the left side first. Because of the ~(quotient (- n 1) 2)~ as the ~n~ for the left side, it means that the left branch of the tree will be filled last. It will do recursive calls on the tree until it cannot get a left branch anymore, which occurs at ~n~ equals or less than 2. Once this happens, it will use the first element of the list as the current sub-tree entry, and the remaining ~n~ values that do not count the left tree entries and the current entry as the right subtree. The algorithm of the right subtree is the same. Once both the left and right subtrees are built (although the left subtree would be empty), the left and right trees are combined with the current entry as the top-level node. After this, we return both the newly constructed tree and the rest of the elements that are not used in constructing the tree. And then the same process is done. Procedure can operate without knowing if it is building the left or the right tree.

#+caption: Diagram of the tree that is built from list->tree
#+begin_example
   5
 /   \
1     9
 \   / \
  3 7   11
#+end_example
*** Part b
What is the order of growth for the steps for a list of ~n~ elements?

This is a linear algorithm, the elements becomes a node exactly once. \(\Theta \left( n \right)\).
* Exercise 2.65
** Prompt
Create a \Theta(n) implementation of ~union-set~ and ~intersection-set~ for the set implementation of the balanced binary tree

** Solution
#+name: tree-set-unit
#+begin_src racket :exports code
(define (element-of-set? x set)
  (cond
    [(null? set) false]
    [(= x (entry set) true)]
    [(< x (entry set)) (element-of-set? x (left-branch set))]
    [else (element-of-set? x (right-branch set))]))

(define (adjoin-set x set)
  (cond
    [(null? set) (make-tree x '() '())]
    [(= x (entry set)) set]
    [(< x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))]
    [else (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))]))
#+end_src

So if we want to intersection or union, at best it will be a linear algorithm (we'll have to iterate through at least one, at most both of the elements of the sets). We've solved this problem pretty well using ordered list representation of set, and we happen to have the ability to make an ordered list from the tree representation. Obviously, we will just do that again.

#+name: tree-set-union
#+begin_src racket :exports code
(define (union-ordered-list list1 list2)
  (cond
    [(null? list1) list2]
    [(null? list2) list1]
    [else
     (let ([x1 (car list1)]
           [x2 (car list2)])
       (cond
         [(= x1 x2) (cons x1 (union-ordered-list (cdr list1) (cdr list2)))]
         [(< x1 x2) (cons x1 (union-ordered-list (cdr list1) list2))]
         [(< x2 x1) (cons x2 (union-ordered-list list1 (cdr list2)))]))]))
(define (union-set set1 set2)
  (let ([list1 (tree->list-2 set1)]
        [list2 (tree->list-2 set2)])
    (list->tree (union-ordered-list list1 list2))))

#+end_src

#+name: tree-set-intersection
#+begin_src racket :exports code
(define (intersection-ordered-list list1 list2)
  (if (or (null? list1) (null? list2))
      '()
      (let ([x1 (car list1)]
            [x2 (car list2)])
        (cond
          [(= x1 x2) (cons x1 (intersection-ordered-list (cdr list1) (cdr list2)))]
          [(< x1 x2) (intersection-ordered-list (cdr list1) list2)]
          [else (intersection-ordered-list list1 (cdr list2))]))))

(define (intersection-set set1 set2)
  (let ([list1 (tree->list-2 set1)]
        [list2 (tree->list-2 set2)])
    (list->tree (intersection-ordered-list list1 list2))))
#+end_src


#+name: tree-set-intersect
#+begin_src racket :exports code
#+end_src

#+RESULTS: tree-set-intersect

#+begin_src racket :exports both :noweb yes
#lang sicp
<<base-tree-representation>>
<<flat-tree-1>>
<<list->tree>>
<<tree-set-unit>>
<<tree-set-union>>
<<tree-set-intersection>>
(define test-set (list->tree (list 1 2 3 6 7 10)))
(define test-set2 (list->tree (list 5 6 7 8 9 10)))
test-set
test-set2
(union-set test-set test-set2)
(intersection-set test-set test-set2)
(tree->list-2 test-set)
(tree->list-2 test-set2)
(tree->list-2 (union-set test-set test-set2))
(tree->list-2 (intersection-set test-set test-set2))
#+end_src

#+RESULTS:
: (3 (1 () (2 () ())) (7 (6 () ()) (10 () ())))
: (7 (5 () (6 () ())) (9 (8 () ()) (10 () ())))
: (6 (2 (1 () ()) (3 () (5 () ()))) (8 (7 () ()) (9 () (10 () ()))))
: (7 (6 () ()) (10 () ()))
: (1 2 3 6 7 10)
: (5 6 7 8 9 10)
: (1 2 3 5 6 7 8 9 10)
: (6 7 10)

Yep, here is your \Theta(n) implementation of the union and intersection operators.
* Exercise 2.66
** Prompt
Implement the ~lookup~ procedure for the case where the set of records is structured as binary tree ordered by the numerical values of the keys
** Solution
#+name: binary-tree-lookup
#+begin_src racket :exports code
(define (lookup given-key bin-tree)
  (if (null? bin-tree) false
      (let ([curr-val (entry bin-tree)])
        (cond [(= given-key curr-val) bin-tree]
              [(< given-key curr-val) (lookup given-key (left-branch bin-tree))]
              [else (lookup given-key (right-branch bin-tree))]))))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<base-tree-representation>>
<<flat-tree-1>>
<<list->tree>>
<<tree-set-unit>>
<<tree-set-union>>
<<tree-set-intersection>>
<<binary-tree-lookup>>
(define test-set (list->tree (list 1 2 3 6 7 10)))
(define test-set2 (list->tree (list 5 6 7 8 9 10)))
test-set
test-set2
(lookup 1000 test-set)
(lookup 1 test-set)
(lookup 8 test-set2)
#+end_src

#+RESULTS:
: (3 (1 () (2 () ())) (7 (6 () ()) (10 () ())))
: (7 (5 () (6 () ())) (9 (8 () ()) (10 () ())))
: #f
: (1 () (2 () ()))
: (8 () ())

Yes, it works, and it is not so bad to implement.
* Exercise 2.67
** Prompt
This is a non-problem. We are given a Huffman tree and a code. Evaluate.
** Solution
Only thing we really need to do here is port over the procedure from the chapter, and then run the procedure on the exercise data. Technically, I could just hand evaluate the code, but that would come back and waste my time in the next exercises.

#+name: huffman-leaf
#+begin_src racket :exports code
;; This is just the representation that we chose for the leaf
(define (make-leaf symbol weight) (list 'leaf symbol weight))
(define (leaf? object) (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
#+end_src

#+name: huffman-tree
#+begin_src racket :exports code
;; Constructors and selectors for the component in the huffman tree
;; for navigation
(define (make-code-tree left right)
  (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right))))
(define (left-branch tree)
  (car tree))
(define (right-branch tree)
  (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
#+end_src

#+name: huffman-tree-decode
#+begin_src racket :exports code
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond [(= bit 0) (left-branch branch)]
        [(= bit 1) (right-branch branch)]
        [else (error "bad bit: CHOOSE-BRANCH" bit)]))
#+end_src

#+name: weighted-set
#+begin_src racket :exports code
(define (adjoin-set x set)
  (cond
    [(null? set) (list x)]
    [(< (weight x) (weight (car set))) (cons x set)]
    [else (cons (car set) (adjoin-set x (cdr set)))]))

;; Pairs is a list of list that looks like this (symbol weight), but we should have appropriate selectors.
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ([pair (car pairs)])
        (adjoin-set (make-leaf (car pair) (cadr pair)) (make-leaf-set (cdr pairs))))))
#+end_src

#+name: sample-huffman
#+begin_src racket :exports code
(define sample-tree
         (make-code-tree (make-leaf 'A 4)
                         (make-code-tree (make-leaf 'B 2)
                                         (make-code-tree
                                          (make-leaf 'D 1)
                                          (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
(decode sample-message sample-tree)
#+end_src

#+RESULTS:
: (A D A B B C A)

Yep, this looks correct.
* Exercise 2.68
** Prompt
We are now given an ~encode~ procedure, and we must implement the ~encode-symbol~ procedure. After this, test the procedure on the sample messages from the previous exercise.
** Solution
Looking at how we implemented the datastructure for the huffman tree, we need to leverage the following attributes. Are we at a leaf node? If not, we should look at the children, and check if the target is in those sets. If not a leaf and not in the children, then raise error. If in, then traverse there.
#+name: huffman-encode
#+begin_src racket :exports code
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree) (encode (cdr message) tree))))

;; This means that encode-symbol only have to make one symbol turn into a
;; collection of bits by navigating the huffman tree.
;; We need to be able to check if the symbol is in a set, therefore, we need to
;; implement a new set lookup procedure as well
(define (encode-symbol char tree)
  (define (local-lookup val subtree)
    (pair? (list-lookup val (symbols subtree) (lambda (x) x))))
  (define (encode-symbol-aux subtree)
    (let ([left (left-branch subtree)]
          [right (right-branch subtree)])
     (cond
       [(null? subtree) (error "empty subtree")]
       [(and (leaf? subtree) (eq? (symbol-leaf subtree) char)) '()]
       [(local-lookup char left)
        (cons 0 (encode-symbol-aux left))]
       [(local-lookup char right)
        (cons 1 (encode-symbol-aux right))]
       [else (error "symbol not found in tree, Symbol, Tree: " char tree)])))
  (encode-symbol-aux tree))

;; Iterative procedure that will lookup our representation of the set
;; I will say that this procedure is written in an overkill way
(define (list-lookup target-key set key-getter)
  (if (null? set)
      false
      (let ([head-val (key-getter (car set))])
        (if (equal? head-val target-key)
            set
            (list-lookup target-key (cdr set) key-getter)))))
#+end_src

#+RESULTS: huffman-encode


#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
<<huffman-encode>>
sample-message
(decode sample-message sample-tree)
(encode (decode sample-message sample-tree) sample-tree)
;; The following line fails in a failure like we expect it to.
;; (encode '(A B D B A X) sample-tree)
#+end_src

#+RESULTS:
: (0 1 1 0 0 1 0 1 0 1 1 1 0)
: (A D A B B C A)
: (0 1 1 0 0 1 0 1 0 1 1 1 0)
* Exercise 2.69
** Prompt
We are to make the infrastructure required to make a huffman tree from just the frequency list. We are given ~generate-huffman-tree~, and we have to make ~successive-merge~ that will keep merging the smallest elements of the set until there is only one element left. Most of the required procedures have been built, so this should be a relatively simple procedure.
** Solution
#+name: generate-huffman-tree
#+begin_src racket :exports code
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
#+end_src

Let's just get into the meat of building successive merge.

#+name: huffman-successive-merge
#+begin_src racket :exports code
;; Working with a set of leaves, but actually, the elements are not just leaves.
;; Here is the invariant we are working with. The set is ordered by weight, and
;; we are trying to combine the smallest weighted values together recursively
(define (successive-merge leaf-set)
  (cond
    [(null? leaf-set) (error "reached empty set")]
    [(null? (cdr leaf-set)) (car leaf-set)]
    [else
     (successive-merge (adjoin-set (make-code-tree (car leaf-set) (cadr leaf-set))
                                   (cddr leaf-set)))]))
#+end_src

#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
<<huffman-encode>>
<<generate-huffman-tree>>
<<huffman-successive-merge>>
(generate-huffman-tree '((A 4) (B 2) (C 1) (D 1)))
sample-tree
#+end_src

#+RESULTS:
: ((leaf A 4) ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4) (A B D C) 8)
: ((leaf A 4) ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4) (A B D C) 8)

Yep, and now we are done.
* Exercise 2.70
** Prompt
Run the huffman encoding on song lyric. Also describe the number of bits required to encode the song, and what the required number of bits to encode the song if we are using fixed width encoding.
** Solution
Okay.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
<<huffman-encode>>
<<generate-huffman-tree>>
<<huffman-successive-merge>>
(define song-tree (generate-huffman-tree '((A 2) (GET 2) (SHA 3) (WAH 1) (BOOM 1) (JOB 2) (NA 16) (YIP 9))))
song-tree
(define song '(GET A JOB SHA NA NA NA NA NA NA NA NA GET A JOB SHA NA NA NA NA NA NA NA NA WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP YIP SHA BOOM))
(define encoded-song (encode song song-tree) )
(display "number of symbols in the song: " ) (display (length song)) (newline)
encoded-song
(length encoded-song)
#+end_src

#+RESULTS:
: ((leaf NA 16) ((leaf YIP 9) (((leaf A 2) ((leaf BOOM 1) (leaf WAH 1) (BOOM WAH) 2) (A BOOM WAH) 4) ((leaf SHA 3) ((leaf JOB 2) (leaf GET 2) (JOB GET) 4) (SHA JOB GET) 7) (A BOOM WAH SHA JOB GET) 11) (YIP A BOOM WAH SHA JOB GET) 20) (NA YIP A BOOM WAH SHA JOB GET) 36)
: number of symbols in the song: 37
: (1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 0 1 0)
: 86

We needed 86 bits to encode the song. If we were to use fixed width encoding, for a song with 8 symbols, we would use 3 bits to encode each symbols. Knowing that there are 37 symbols in the song, we would use src_elisp{(* 3 37)} {{{results(=111=)}}} bits. So yes, huffman encoding is more efficient than fixed width encoding.
* Exercise 2.71
** Prompt
Suppose we are trying to huffman encode data with the following incrementing pattern, for n symbols, each value is 2^{n-1}. Draw out the Huffman tree for n=5 and n=10. Generalize and tell us how many bits are required to represent the most frequent and least frequent symbols.
** Solution
#+begin_src plantuml :exports results :results file :file ./images/exercise-2.71-a.svg
@startuml
circle 32
circle 15
circle 7
circle 3

rectangle A
rectangle B
rectangle C
rectangle D
rectangle E

32 --  E: 1
32 --  15: 0

15 -- 7: 0
15 -- D: 1

7 -- 3: 0
7 -- C: 1

3 -- A: 0
3 -- B: 1
@enduml
#+end_src

#+RESULTS:
[[file:./images/exercise-2.71-a.svg]]

This combination of values generates a very unbalanced tree, where other than the two least frequent elements, there will be a symbol for every number of bits. Actually, there might be more to it than that. We can discuss this after drawing the Huffman tree for n=10.

#+begin_src plantuml :exports results :results file :file ./images/exercise-2.71.svg
@startuml
circle 1023
circle 511
circle 255
circle 127
circle 63
circle 31
circle 15
circle 7
circle 3

rectangle A
rectangle B
rectangle C
rectangle D
rectangle E
rectangle F
rectangle G
rectangle H
rectangle I
rectangle J

1023 --  511: 0
1023 --  J: 1

511 -- 255: 0
511 -- I: 1

255 -- 127: 0
255 -- H: 1

127 -- 63: 0
127 -- G: 1

63 -- 31: 0
63 -- F: 1

31 -- 15: 0
31 -- E: 1

15 -- 7: 0
15 -- D: 1
7 -- 3: 0
7 -- C: 1
3 -- A: 0
3 -- B: 1
@enduml
#+end_src

#+RESULTS:
[[file:./images/exercise-2.71.svg]]

Well, we see that there is just a really long branch, and actually, the minimum number of bits is always going to be 1, and the largest number of bits will be n - 1, coming from the structure of the tree, where we see that there is a symbol that will be matched with every bit length except for the two least frequent symbols, which share the same tree nodes.

Let's check our work by using our program.

#+begin_src racket :exports both :noweb yes
#lang sicp
<<huffman-leaf>>
<<huffman-tree>>
<<huffman-tree-decode>>
<<weighted-set>>
<<sample-huffman>>
<<huffman-encode>>
<<generate-huffman-tree>>
<<huffman-successive-merge>>
(define incrementing-symbols '(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z))

(define (make-incrementing-sequence n)
  (define (iter m acc symbol-list) (if (>= m n)
                                       acc
                                       (iter (+ m 1) (cons (list (car symbol-list) (expt 2 m)) acc) (cdr symbol-list))))
  (iter 0 '() incrementing-symbols))
(make-incrementing-sequence 5)
(generate-huffman-tree (make-incrementing-sequence 5))
(make-incrementing-sequence 10)
(generate-huffman-tree (make-incrementing-sequence 10))
#+end_src

#+RESULTS:
: ((E 16) (D 8) (C 4) (B 2) (A 1))
: (((((leaf A 1) (leaf B 2) (A B) 3) (leaf C 4) (A B C) 7) (leaf D 8) (A B C D) 15) (leaf E 16) (A B C D E) 31)
: ((J 512) (I 256) (H 128) (G 64) (F 32) (E 16) (D 8) (C 4) (B 2) (A 1))
: ((((((((((leaf A 1) (leaf B 2) (A B) 3) (leaf C 4) (A B C) 7) (leaf D 8) (A B C D) 15) (leaf E 16) (A B C D E) 31) (leaf F 32) (A B C D E F) 63) (leaf G 64) (A B C D E F G) 127) (leaf H 128) (A B C D E F G H) 255) (leaf I 256) (A B C D E F G H I) 511) (leaf J 512) (A B C D E F G H I J) 1023)

Yep, this looks right.
* Exercise 2.72
** Prompt
What is the order of growth for encoding a single symbol, using the implementation from [[*Exercise 2.68][Exercise 2.68]]? Include the search step as well. Consider the special case where the relative frequency of the signal is as described in [[*Exercise 2.71][Exercise 2.71]]. Specifically, the number of steps required to encode the most and least frequent symbol. (The book does not believe that I could define this for the general case).
** Solution
Here is the implementation as a reminder.
#+begin_src racket :exports code
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree) (encode (cdr message) tree))))

;; This means that encode-symbol only have to make one symbol turn into a
;; collection of bits by navigating the huffman tree.
;; We need to be able to check if the symbol is in a set, therefore, we need to
;; implement a new set lookup procedure as well
(define (encode-symbol char tree)
  (define (local-lookup val subtree)
    (pair? (list-lookup val (symbols subtree) (lambda (x) x))))
  (define (encode-symbol-aux subtree)
    (let ([left (left-branch subtree)]
          [right (right-branch subtree)])
     (cond
       [(null? subtree) (error "empty subtree")]
       [(and (leaf? subtree) (eq? (symbol-leaf subtree) char)) '()]
       [(local-lookup char left)
        (cons 0 (encode-symbol-aux left))]
       [(local-lookup char right)
        (cons 1 (encode-symbol-aux right))]
       [else (error "symbol not found in tree, Symbol, Tree: " char tree)])))
  (encode-symbol-aux tree))

;; Iterative procedure that will lookup our representation of the set
;; I will say that this procedure is written in an overkill way
(define (list-lookup target-key set key-getter)
  (if (null? set)
      false
      (let ([head-val (key-getter (car set))])
        (if (equal? head-val target-key)
            set
            (list-lookup target-key (cdr set) key-getter)))))
#+end_src
~encode-symbol~ takes two parameters, the symbol being encoded, and the Huffman tree used to represent ~m~ symbols. We also have a few structure invariant, such as how each of the nodes will return a set for both the weight and the symbols that is under that node. The two notable things here is that the sets are represented as lists, and that they are sorted by weight (lowest to highest).

We assume that list manipulation primitives are constant time: \Theta(1). Type checking, such as ~null?~ and ~pair?~ are also constant time: \Theta(1), and also that ~define~ is a \Theta(1) operation.

To choose which branch to navigate to using the symbol in the tree, we do a set containment check, which is done on a list that is sorted by weight. This is a linear search, with the size of the search being the elements of the tree that is under it, therefore, the steps of growth for this stage of the algorithm is linear, and it scales with ~m~. Best case is that the search target is in the front of the list, which would be \Theta(1), worst case is that the symbol is either at the back of the list, or it is not present, which would cost however many symbols are under that node.

We'll continue our analysis for a symbol that will map to a sequence of ~b~ bits. If the symbol maps to ~b~ bits, then the main logic of ~encode-symbol~ would happen ~b~ times, with each layer having its own linear time set search to determine which branch to navigate to next. Another thing to note is that as the iteration continues, the size of the set being searched decreases. What we find here is that the growth of the steps for searching the tree is compounded on the set search.

What is difficult here is that the efficiency of the set search and the tree navigation is dependent on the shape of the tree. Knowing this, we will just analyze the two special case from [[*Exercise 2.71][Exercise 2.71]].

First is the most frequent case. Here, ~b~ is 1, but the most frequent symbol will appear more than the combination of the rest of the symbols. In our implementation, we do the containment check on the left branch before the right branch, and since the target symbol is not present there, we will always check all the m - 1 elements in that set, and therefore, ~m~ elements will be searched before finding the most frequent symbol (just because of the list representation of the set). This leaves us at \Theta(m) steps of growth for the most frequent symbol.

For the least frequent symbol, the searching would have to traverse the entire bit tree, but due to the set being sorted by weight, the target symbol will always show up at the front of the search, making the set lookup for the least frequent symbol a constant operation for this tree shape. Instead, the growth comes from traversing down to the lowest layer of the tree, building ~b~ bits. The value of ~b~ was solved in the previous exercise, giving us m - 1 steps. This also leaves us at \Theta(m) steps of growth for encoding the least frequent symbol in the Huffman tree of the shape defined in the previous exercise. Yes, if the set of symbol was not sorted by weight, then the searching component of the process would have been linear time, pushing this case to $\Theta(m^2)$, but we should consider the implementation details.

Here is an explanation of how we could have gotten $\Theta(m^2)$ if the symbols were not sorted by weight. Searching is most intensive at the top of the tree, but every layer down the tree, the number of elements decrease by 1. Say in the worse case scenario, we always search the entire set, by the time we get to the bottom of the tree, we'd have to do the following set search sizes to the tree.

$$\left( m - 1 \right) + \left( m - 2 \right) + \cdots + 2 + 1$$

Using the young Gauss strategy of finding recurring patterns, we see that the pattern that we just showed allows us to form pairs of $\left( m - n \right)$ and $n$, which would cancel out to $m$. When $m$ is an odd value, the upper half and lower half of the sum will cancel out perfectly, leaving the result of the sum as $\left( m^2\div 2 \right)$. If $m$ is an even value, there will be a leftover in the middle of the sum, resulting in $\left( m^2 \div 2 \right) + \left( m \div 2 \right)$. \Theta notation only cares about the value that will contribute the most, and removes the coefficient, therefore, we get $\Theta(m^2)$.

As a reminder, the Huffman tree for this special case looks like the following:

[[file:./images/exercise-2.71.svg]]

I suppose that in conclusion, encoding a symbol with a tree of this shape takes linear time: \Theta(m).
* Exercise 2.73
** Prompt
We have just covered dispatches, and now we are working on data-directed style of generic procedures. For this exercise, we will review the symbolic differentiation procedure that was designed in sicp section 2.3.2.

#+caption: Previous version of the symbolic differentiation procedure
#+name: 2.73-old-dispatch
#+begin_src racket :exports code
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [else (error "Unknown expression type: DERIV" exp)]))
#+end_src

We can convert the old version of the symbolic differentiation to the data-directed procedure by doing the following to it.

#+caption: Data-driven implementation of deriv
#+name: 2.73-data-driven
#+begin_src racket :exports code
(define (deriv exp var)
 (cond [(number? exp) 0]
       [(variable? exp) (if (same-variable? exp var) 1 0)]
       [else ((get 'deriv (operator exp)) (operand exp) var)]))

(define (operator exp) (car exp))
(define (operand exp) (cdr exp))
#+end_src

There are now a few questions that must be answered.

a. Explain what was done above, and explain why ~number?~ and ~variable?~ cannot be moved into data-driven dispatch.
b. Write the procedure for derivatives of sums and products, and the auxiliary code required to install them in the table used by the program above.
c. Choose any additional differentiation rule that you like, such as exponents, and install it into this data-directed system.
d. Right now, the type of the expression is the algebraic operator that binds the expression together. What if we index the procedure in the opposite way, such that the dispatch line in the ~deriv~ procedure look like the following. ~((get (operator exp) 'deriv') (operands exp) var)~.
** Solution
*** Part a
The data driven solution is to check for the primitives, which are numbers and variables, and if the it was found that the exp is an actual registered expression, then use the data-driven table to lookup the corresponding procedure, and then dispatch it. Lookup process is done with ~deriv~ as the operation, and the expression operator as the type being used in the lookup. Following this, selectors for the data and the operation were defined. ~number?~ and ~variable?~ cannot be moved to the data-driven dispatch because we are dispatching with algebraic expressions as the type. ~variable~ and ~nubmer~ in this representation do not have operators, therefore, lookup cannot occur.
*** Part b
Writing an implementation for the sum and product implementation of ~deriv~, we must first setup our test script. We could just reuse a testing script from the ~deriv~ exercises.


#+caption: Test for old version of the ~deriv~ procedure for regression testing.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-old-dispatch>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))

With this value here, we could get to implementing the data-driven dispatch version of the ~deriv~ procedure.

#+name: 2.73-data-driven-sum
#+begin_src racket :exports code
(define (install-data-driven-sum)
  (define (deriv-sum operand var)
    (make-sum (deriv (car operand) var)
              (deriv (cadr operand) var)))
  (put 'deriv '+ deriv-sum))
#+end_src

#+name: 2.73-data-driven-product
#+begin_src racket :exports code
(define (install-data-driven-product)
  (define (deriv-product operand var)
    (make-sum (make-product (car operand) (deriv (cadr operand) var))
              (make-product (deriv (car operand) var) (cadr operand))))
  (put 'deriv '* deriv-product))
#+end_src

Awkward thing we found here is that the racket implementation of ~sicp~ is missing the ~put~ and ~get~ procedure, therefore, we must implement this ourselves.
#+caption: With help from the stack overflow answer provided here: https://stackoverflow.com/questions/5499005/how-do-i-get-the-functions-put-and-get-in-sicp-scheme-exercise-2-78-and-on.
#+name: put-get-implementation
#+begin_src racket :exports code
(define *op-table* '())

(define (make-entry k v) (list k v))
(define (key entry) (car entry))
(define (value entry) (cadr entry))
;; Checks if the entry of the table has a matching parameter key
(define (key? k entry)
  (equal? (key entry) k))

(define (put op type item)
  (define (putter k array)
    (cond [(null? array) (list (make-entry k item))]
          [(key? k (car array)) array]
          [else (cons (car array) (putter k (cdr array)))]))
  (set! *op-table* (putter (list op type) *op-table*)))

(define (get op type)
  (define (getter k array)
    (cond [(null? array) #f]
          [(key? k (car array)) (value (car array))]
          [else (getter k (cdr array))]))
  (getter (list op type) *op-table*))

#+end_src

#+RESULTS: put-get-implementation

#+caption: Test for data-driven version of the ~deriv~ procedure
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-data-driven>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<put-get-implementation>>
<<2.73-data-driven-sum>>
<<2.73-data-driven-product>>

(install-data-driven-sum)
(install-data-driven-product)

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))

This is the expected result, but with one caveat. We had to stop using the selectors for the operands in the old implementation, as those selectors are working with the assumption that there is an operator at the front of the expression. The new interface does not have that.
*** Part c
Add the rule back in.

Using data-driven dispatch, this should be easy to do.

#+name: 2.73-data-driven-exponentiation
#+begin_src racket :exports code
(define (install-data-driven-exponentiation)
  (define (deriv-exponentiation operand var)
    (make-product (cadr operand) (make-exponentiation (car operand) (- (cadr operand) 1))))
  (put 'deriv '** deriv-exponentiation))
#+end_src

#+caption: Test for data-driven version of the ~deriv~ procedure with exponentiation.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-data-driven>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<deriv-base-exponentiation>>
<<put-get-implementation>>
<<2.73-data-driven-sum>>
<<2.73-data-driven-product>>
<<2.73-data-driven-exponentiation>>

(install-data-driven-sum)
(install-data-driven-product)
(install-data-driven-exponentiation)

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
(deriv '(+ (* x y) (** x 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))

Result came out as expected.
*** Part d
Suppose that we swapped the op and the type, so that the operation is now the operator in the expression and the type is ~'deriv~. What are the changes that are required?

Well, we are now trying to implement ~'deriv~ for the different operations that could be described in an expression. The schema of the table will change, and both the installation and the retrieval of the procedure would change, but otherwise, ~deriv~ itself stays relatively the same. What we could do here is just implement this, and test it.

#+caption: swapped data-driven implementation of deriv
#+name: 2.73-data-driven-swapped
#+begin_src racket :exports code
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [else ((get (operator exp) 'deriv) (operand exp) var)]))

(define (operator exp)
  (car exp))
(define (operand exp)
  (cdr exp))
#+end_src

#+name: 2.73-data-driven-sum-swapped
#+begin_src racket :exports code
(define (install-data-driven-sum)
  (define (deriv-sum operand var)
    (make-sum (deriv (car operand) var)
              (deriv (cadr operand) var)))
  (put '+ 'deriv deriv-sum))
#+end_src

#+name: 2.73-data-driven-product-swapped
#+begin_src racket :exports code
(define (install-data-driven-product)
  (define (deriv-product operand var)
    (make-sum (make-product (car operand) (deriv (cadr operand) var))
              (make-product (deriv (car operand) var) (cadr operand))))
  (put '* 'deriv deriv-product))
#+end_src

#+name: 2.73-data-driven-exponentiation-swapped
#+begin_src racket :exports code
(define (install-data-driven-exponentiation)
  (define (deriv-exponentiation operand var)
    (make-product (cadr operand) (make-exponentiation (car operand) (- (cadr operand) 1))))
  (put '** 'deriv deriv-exponentiation))
#+end_src

#+caption: Test for swapped operator and type for data-driven version of the ~deriv~ procedure.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-data-driven-swapped>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<deriv-base-exponentiation>>
<<put-get-implementation>>
<<2.73-data-driven-sum-swapped>>
<<2.73-data-driven-product-swapped>>
<<2.73-data-driven-exponentiation-swapped>>

(install-data-driven-sum)
(install-data-driven-product)
(install-data-driven-exponentiation)

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
(deriv '(+ (* x y) (** x 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))

And just like that, we are done the exercise.
* Exercise 2.74
** Prompt
We are larping as a software engineer for a company that used to have multiple distributed independent divisions, all having software infrastructure that was not standardized. We are responsible for making an interface that would allow a access to those different systems without changing those systems.
a. Implement for headquarters a ~get-record~ procedure that retrieves a specified employee's record from a specified personnel file. The procedure should be applicable to any division's file. Explain how the individual divisions' file should be structured. In particular, what type information must be supplied?
b. Implement for headquarters a ~get-salary~ procedure that returns the salary information from a given employee's record from any division's personnel file. How should the record be structured in order to make this operation work?
c. Implement for HQ a ~find-employee-record~ procedure. This should search all division files for the record of a given employee and return the record. Assume that this procedure takes as arguments an employee's name and a list of all the divisions' file.
d. When Insatiable takes over a new company, what changes must be made in order to incorporate the new personnel information into the central system?
** Solution
Let's talk a little about our requirements. Firstly, we are trying to integrate multiple systems that tries to do the same thing. Firstly, each of these systems should have selectors and constructors. Reading the requirements, the central system is mostly trying to read the content of each of the systems. There are also some similarities in how the data is stored. We know that the entries are stored as a record of records, meaning that for most of the exercise, we are trying to select and check for containment generically.
*** Part a
Parameters for this procedure are the name of the employee, and a record file. Here is what we will do to make this work.
1. We are injecting the datastructure, and this is the thing that is different between the teams
2. We assume that each of the teams have built their own querying system

We could use data-driven dispatch to be able to generically operate on the different record types that are used by the different teams.

Since we don't really have data to test with, nor do I really want to put the time to do that, we'll just pretend that the code I am writing has some underlying representation written up by someone else. The generic procedure is provided below.

#+begin_src racket :exports code
(define (attach-type type value)
  (cons type value))
(define (type-tag item)
  (car item))
(define (contents item)
  (cdr item))
#+end_src

#+name: generic-apply
#+begin_src racket :exports code
(define (generic-apply op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (error "could not find the item for the following op and type" (list op type-tag))))))
#+end_src

#+begin_src racket :exports code
(define (get-record record-store name)
  (generic-apply 'get-record record-store name))
#+end_src

Each of the team just has to make an install procedure that contains the implementation of retrieving the record with the parameterized name. For the sake of correctness, this procedure should also return ~#f~ as the option value for when the search failed. If the search does not fail, then the returned record should be tagged by the implementer of the type.

Finally, the record file should specify what team format it uses, so that we could use data-driven dispatch to find the correct procedure.
*** Part b
Implementing the ~get-salary~ procedure that takes the employee record as parameter.

#+begin_src racket :exports code
;; This procedure is using data-driven dispatch to find the correct selector
;; procedure
(define (get-salary emp-record)
  (generic-apply 'get-salary emp-record))
#+end_src

So basically, we have written another generic procedure. What really matters here is that the employee record being passed into the procedure is tagged with a type, (the team that the record format belongs to). Finally, the selector procedure that is installed should tag the return salary information.
*** Part c
Making a list of record looking actually does not involve making the teams implement a new selector. Instead, we could leverage the procedure that was designed in part a.

Luckily for us, we made the interface for the ~get-record~ method return ~#f~ if the name could not be found in the record, so now, we just make the procedure traverse all the records, and do a data-driven dispatch for the ~get-record~ operation. If the record returns a negative, we continue looking. If there are no more records, we return ~#f~ as the sentinel value, and if we find the record, we return the record.

#+begin_src racket :exports code
(define (find-employee-record name . records)
  (if (null? records)
      #f
      (let ([curr-record (car records)])
        (let ([res (get-record curr-record name)])
          (if (not res)
              (apply find-employee-record (cons name (cdr records)))
              res)))))
#+end_src
*** Part d
Once a new company is being purchased, and we must integrate their system into the central system, we have to do the following changes on their side.

The new company must implement the ~get-record~ procedure, and the ~get-salary~ procedure, following the interface that we have defined, which includes the ~#f~ return and tagging the record value that was returned from ~get-record~. They must pick a unique type name for their team, and then tag their record data with this name. Then, they must make an install script that will register their version of ~get-record~ and ~get-salary~ into the data-driven table.

This should be enough to integrate a new team into the central system.
* Exercise 2.75
** Prompt
We are exploring message passing in this part of the chapter. This looks to be the basis to object oriented programming. The task at hand is to make the message passing representation for ~make-from-mag-angle~ complex number object.
** Solution

We are basically defining some methods for the representation. Since I professionally write Python, here is the solution.
#+begin_src racket :exports code
(define (make-from-mag-angle m a)
  (define (dispatch op)
    (cond [(eq? op 'real-part) (* m (cos a))]
          [(eq? op 'imag-part) (* m (sin a))]
          [(eq? op 'magnitude) m]
          [(eq? op 'angle) a]
          [else (error "unrecognized operation found: MAKE-FROM-MAG-ANGLE" op)]))
  dispatch)
#+end_src
* Exercise 2.76
** Prompt
As a large system with generic operations evolves, new types of data objects or new operations may be needed. For each of the three strategies: generic operations with explicit dispatch, data-directed style, and message passing, describe the changes that must be made to a system in order to add new types or new operations. Which organization would be most appropriate for a system in which new types must often be added? Which would be most appropriate for a system in which new operations must often be added?
** Solution
This is a good question, it's making us think about the tradeoff of each of the design decisions.

*** Explicit Dispatch
Explicit dispatch is the most expensive method to extend with new types and new operations. Adding a new type in explicit dispatching entails that a new branch in the dispatch conditional logic must be added for the new type. This must be done for all the explicit dispatch operations that are supported. Added a new operation for explicit dispatching means that a new procedure must be written that has a dispatch handling for all the supported types.

*** Data-driven Dispatch
This strategy requires that each of the types are stored in packages that are installed when used. Operations are stored in a lookup table that takes the type tag and operation as the index parameter, and return the correct procedure that could correctly act on the data. A big benefit of this strategy is that the data being passed around only needs to hold the type tag, and not the actual behaviors of the object. Therefore, I argue that this strategy gives us cheaper representations.
**** Adding a new type
In data-driven dispatch, to add a new type, a package for that type must be built that defines the procedure that will enact the different operations on the new type, along with the definition of the representation of the new type. To use the new type representation, these procedures must be installed in an operation and type lookup table, allowing the generic apply procedure to find the correct procedure for a given type and operation. Note that this strategy requires the additional process of installing a type into the system.

**** Adding a new operation
To define a new operation, a new generic procedure must be defined in the module for the type. The real main benefit here is that these operations can be implemented independently, and that the implementation that was shown up until now gives this strategy the ability for the stored procedure to take multiple arguments. The types must still implement their version of this new operation for it to participate.

*** Message Passing
Representations hold behavior in this implementation. This makes it really easy to apply an operation on a type, but it is more expensive to instantiate an object, as it is holding the procedures that would operate on it. The different types in this strategy encapsulates the behaviors that it supports.

**** Adding a new type
In message passing, the new type is also holding the implementation of the operation. When making a new type, we are actually returning a dispatch method, so all implementation of the supported operation must be added with the new type. A major note here is that registering this new type does not require type tag, and procedure table registration.
**** Adding a new operation
Adding a new operation requires two things. Adding a new generic procedure wrapper that will submit the new operation to its arguments, and implementing the operation in the type itself. In this strategy, there isn't a need to pass around a type tag, since the types actually just control the dispatch themselves.

*** Appropriate strategies
**** Adding a new type
In terms of ease of adding a new type with the least amount of resistance, message passing seems to be the most appropriate strategy, since there is minimal changes required to the system when adding a new type.
**** Adding a new operation
Both message passing and data-driven dispatch would require that the type implement the operation, causing around the same amount of code changes (data-driven also requires registration, adding slightly more word to be done on the data-driven implementation). The major tradeoff we should look is how memory scale in each strategies. When adding more operations, the message passing strategy would cause all the type representation to become more expensive, as they would have to store the new dispatch handling for that type, for every instance of the type. The data-driven dispatch method would scale better, as only one instance of the operation handler for all the types would need to be stored in the lookup table.
* Exercise 2.77
** Prompt
We are working with an object that is shaped like the following:

#+name: 2.77-object
#+begin_src racket :exports code
('complex ('rectangular (3 . 4)))
#+end_src

Which is really just to say that we are working on two layers of tagged typing, one for the different number representation for generic arithmetic, and the other for different representation of complex values.

Louis Reasoner, the fictional character, wanted to evaluate src_racket{(magnitude z)} where z is the complex object we just described in [[2.77-object]]. The src_racket{apply-generic} method threw an error saying that there is no method for the operation src_racket{magnitude} on the type ~(complex)~. Alyssa P. Hacker solved this problem by saying that the src_racket{magnitude} selector was not defined for the ~complex~ type yet, only for the types in the complex arithmetic implementation, which includes ~rectangular~ and ~polar~. She gave the following fix and told Louis to put it into the complex arithmetic package.

#+begin_src racket :exports code
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
#+end_src

Describe the detail of why this works, and trace through all the procedures called in evaluating the expression of src_racket{(magnitude z)}. Also state how many times that ~apply-generic~ is invoked, along with what procedure is dispatched.
** Solution
*** Why does this work
The problem that was there before was that by bringing the different number systems together into a generic arithmetic library, another layer of type tagging was applied. The initial implementation of this additional type tag only registered the basic operations of adding, subtracting, multiplying, and dividing. It does not add the special selectors that are present in the other implementations. To make those selectors available again in this level of abstraction, we simply have to register handling on the data after it has been dispatched by the data-driven dispatcher, that is, once the system has detected the higher level type that points to the number representation, call the correct generic selector again. This is very much like what we could do with single dispatch on python, when handling a list by mapping on the elements of the list with the same function.
*** Trace through the procedure called on (magnitude z)
The following code snippet is the trace of the evaluation of src_racket{(magnitude z)} after registering the complex value implementation to the data-driven dispatch.
#+begin_src racket :exports code
('complex ('rectangular (3 . 4)))
(magnitude ('complex ('rectangular (3 . 4))))
(apply-generic 'magnitude ('complex ('rectangular (3 . 4))))
(apply (get op '(complex)) (('rectangular (3 . 4))))
(apply-generic 'magnitude ('rectangular (3 . 4)))
(apply (get op '(rectangular)) ((3 . 4)))
(sqrt (+ (square (real-part (3 . 4)))
         (square (imag-part (3 . 4)))))
(sqrt (+ (square 3)
         (square 4)))
5
#+end_src

We see that ~apply-generic~ is invoked twice, the first time calling itself on the content of the ~'complex~ type, which is the ~'retangular~ type from the complex arithmetic library. The second time, it finds the implementation for the ~'retangular~ type, ~magnitude~, which does the square root calculations.
* Exercise 2.78
** Prompt
~scheme-number~ package is using the built in scheme numerical procedure. This is already generic to scheme number, but it was breaking before because we are adding tags to the scheme number type. What is interesting is that all the lisp implementations already do have a type system working internally, and the primitive predicates determine if the data is of a certain type internally. The goal of this exercise is to refactor ~type-tag~, ~contents~, and ~attach-tag~ so that everything remain the same except for scheme numbers, which should no longer need to have a type tag attached to it.
** Solution
First, we are going to port the old version of the code and make a quick little test bench.

#+name: 2.78-tag-system-orig
#+begin_src racket :exports code
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: CONTENTS" datum)))
#+end_src

#+name: 2.78-apply-generic
#+begin_src racket :exports code
(define (apply-generic op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (error "No method for these types: APPLY-GENERIC" (list op type-tags))))))
#+end_src

#+name: 2.78-complex-implementation
#+begin_src racket :exports code
(define (square x) (* x x))

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z)
    (car z))
  (define (imag-part z)
    (cdr z))
  (define (make-from-real-imag x y)
    (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z)) (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z)
    (car z))
  (define (angle z)
    (cdr z))
  (define (make-from-mag-ang r a)
    (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y))) (atan y x)))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z)
    (attach-tag 'complex z))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
#+end_src

#+RESULTS: 2.78-complex-implementation

#+name: 2.78-rational-implementation
#+begin_src racket :exports code
(define (install-rational-package)
  ;; internal procedures
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
#+end_src

#+name: 2.78-scheme-implementation-old
#+begin_src racket :exports code
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
#+end_src

#+name: 2.78-generic-arithmetic
#+begin_src racket :exports code
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
#+end_src

#+caption: Test for tagged version of the scheme numbers
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.78-scheme-implementation-old>>
<<put-get-implementation>>
<<2.78-tag-system-orig>>
<<2.78-apply-generic>>
<<2.78-complex-implementation>>
<<2.78-rational-implementation>>
<<2.78-generic-arithmetic>>

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)


(add (make-scheme-number 3) (make-scheme-number 4))
(sub (make-scheme-number 6) (make-scheme-number 4))
(mul (make-scheme-number 6) (make-scheme-number 4))
(div (make-scheme-number 6) (make-scheme-number 4))
(add (make-complex-from-real-imag 2 2) (make-complex-from-real-imag 3 4))
;; (add 3 3)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
(scheme-number . 7)
(scheme-number . 2)
(scheme-number . 24)
(scheme-number . 3/2)
(complex rectangular 5 . 6)
#+end_example

Right, that was a lot of porting for a little bit of testing. I think this is because sicp has built up a rather large amount of infrastructures to facilitate the number system. Now we just make a change in one location to allow the removal of the scheme number tag.

#+name: 2.78-tag-system
#+begin_src racket :exports code
(define (attach-tag type-tag contents)
  (if (eq? type-tag 'scheme-number)
      contents
      (cons type-tag contents)))
(define (type-tag datum)
  (cond
    [(pair? datum) (car datum)]
    [(number? datum) 'scheme-number]
    [else (error "Bad tagged datum: TYPE-TAG" datum)]))
(define (contents datum)
  (cond
    [(pair? datum) (cdr datum)]
    [(number? datum) datum]
    [else (error "Bad tagged datum: CONTENTS" datum)]))
#+end_src

#+caption: Test for untagged version of the scheme numbers
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.78-scheme-implementation-old>>
<<put-get-implementation>>
<<2.78-tag-system>>
<<2.78-apply-generic>>
<<2.78-complex-implementation>>
<<2.78-rational-implementation>>
<<2.78-generic-arithmetic>>

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)

(add 3 4)
(sub 6 4)
(mul 6 4)
(div 6 4)
(add (make-complex-from-real-imag 2 2) (make-complex-from-real-imag 3 4))
(add 3 3)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
7
2
24
3/2
(complex rectangular 5 . 6)
6
#+end_example

Okay, so we have now completed the type tag modification, but you know, I think we just ended up doing a little manual dispatching. Huh.
* Exercise 2.79
** Prompt
Define a generic equality predicate ~equ?~ that tests the equality of two numbers, and install it in the generic arithmetic package. This operation should work for ordinary numbers.
** Solution
Just going to duplicate the previous question's system so that we could properly add to it.
#+name: 2.79-tag-system-orig
#+begin_src racket :exports code
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: CONTENTS" datum)))
#+end_src

#+name: 2.79-apply-generic
#+begin_src racket :exports code
(define (apply-generic op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (error "No method for these types: APPLY-GENERIC" (list op type-tags))))))
#+end_src

#+name: 2.79-complex-implementation
#+begin_src racket :exports code
(define (square x)
  (* x x))

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z)
    (car z))
  (define (imag-part z)
    (cdr z))
  (define (make-from-real-imag x y)
    (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z)) (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z)
    (car z))
  (define (angle z)
    (cdr z))
  (define (make-from-mag-ang r a)
    (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y))) (atan y x)))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2))))
  (define (equ? z1 z2)
    (and (= (real-part z1) (real-part z2)) (= (imag-part z1) (imag-part z2))))
  ;; interface to rest of the system
  (define (tag z)
    (attach-tag 'complex z))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'equ? '(complex complex) equ?)
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
#+end_src

#+RESULTS: 2.79-complex-implementation

#+name: 2.79-rational-implementation
#+begin_src racket :exports code
(define (install-rational-package)
  ;; internal procedures
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  (define (equ? x y)
    (and (= (numer x) (numer y)) (= (denom x) (denom y))))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put 'equ? '(rational rational) equ?)
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
#+end_src

#+name: 2.79-scheme-implementation-old
#+begin_src racket :exports code
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) (lambda (x y) (= x y)))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
#+end_src

#+name: 2.79-generic-arithmetic
#+begin_src racket :exports code
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (equ? x y) (apply-generic 'equ? x y))
#+end_src


#+name: 2.79-tag-system
#+begin_src racket :exports code
(define (attach-tag type-tag contents)
  (if (eq? type-tag 'scheme-number)
      contents
      (cons type-tag contents)))
(define (type-tag datum)
  (cond
    [(pair? datum) (car datum)]
    [(number? datum) 'scheme-number]
    [else (error "Bad tagged datum: TYPE-TAG" datum)]))
(define (contents datum)
  (cond
    [(pair? datum) (cdr datum)]
    [(number? datum) datum]
    [else (error "Bad tagged datum: CONTENTS" datum)]))
#+end_src

#+caption: Test for untagged version of the scheme numbers
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.79-scheme-implementation-old>>
<<put-get-implementation>>
<<2.79-tag-system>>
<<2.79-apply-generic>>
<<2.79-complex-implementation>>
<<2.79-rational-implementation>>
<<2.79-generic-arithmetic>>

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)

(equ? 3 3)
(equ? (make-rational 6 4) (make-rational 3 2))
(equ? (make-complex-from-real-imag 1 0) (make-complex-from-mag-ang 3 2))
(equ? (make-complex-from-real-imag 1 0) (make-complex-from-mag-ang 1 0))
#+end_src

#+RESULTS:
: done
: done
: done
: done
: done
: #t
: #t
: #f
: #t

This is now implemented. The main lesson we had was that all it took for us to add this predicate was adding three procedure to the different package, and exposing the generic procedure that will call the correct procedures.
* Exercise 2.80
** Prompt
Define the generic predicate ~=zero?~, which will return true if the value of the number is zero. This predicate should work for all three number types that were implemented for in the previous question.
** Solution
#+name: 2.80-tag-system-orig
#+begin_src racket :exports code
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: CONTENTS" datum)))
#+end_src

#+name: 2.80-apply-generic
#+begin_src racket :exports code
(define (apply-generic op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (error "No method for these types: APPLY-GENERIC" (list op type-tags))))))
#+end_src

#+name: 2.80-complex-implementation
#+begin_src racket :exports code
(define (square x)
  (* x x))

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z)
    (car z))
  (define (imag-part z)
    (cdr z))
  (define (make-from-real-imag x y)
    (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z)) (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z)
    (car z))
  (define (angle z)
    (cdr z))
  (define (make-from-mag-ang r a)
    (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y))) (atan y x)))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2))))
  (define (equ? z1 z2)
    (and (= (real-part z1) (real-part z2)) (= (imag-part z1) (imag-part z2))))
  (define (=zero? z)
    (= (magnitude z) 0))
  ;; interface to rest of the system
  (define (tag z)
    (attach-tag 'complex z))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'equ? '(complex complex) equ?)
  (put '=zero? '(complex) =zero?)
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
#+end_src

#+RESULTS: 2.80-complex-implementation

#+name: 2.80-rational-implementation
#+begin_src racket :exports code
(define (install-rational-package)
  ;; internal procedures
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  (define (equ? x y)
    (and (= (numer x) (numer y)) (= (denom x) (denom y))))
  (define (=zero? x)
    (= (numer x) 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put '=zero? '(rational) =zero?)
  (put 'equ? '(rational rational) equ?)
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
#+end_src

#+name: 2.80-scheme-implementation-old
#+begin_src racket :exports code
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) (lambda (x y) (= x y)))
  (put '=zero? '(scheme-number) (lambda (x) (= x 0)))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
#+end_src

#+name: 2.80-generic-arithmetic
#+begin_src racket :exports code
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (equ? x y) (apply-generic 'equ? x y))
(define (=zero? x) (apply-generic '=zero? x))
#+end_src


#+name: 2.80-tag-system
#+begin_src racket :exports code
(define (attach-tag type-tag contents)
  (if (eq? type-tag 'scheme-number)
      contents
      (cons type-tag contents)))
(define (type-tag datum)
  (cond
    [(pair? datum) (car datum)]
    [(number? datum) 'scheme-number]
    [else (error "Bad tagged datum: TYPE-TAG" datum)]))
(define (contents datum)
  (cond
    [(pair? datum) (cdr datum)]
    [(number? datum) datum]
    [else (error "Bad tagged datum: CONTENTS" datum)]))
#+end_src

#+caption: Test for untagged version of the scheme numbers
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.80-scheme-implementation-old>>
<<put-get-implementation>>
<<2.80-tag-system>>
<<2.80-apply-generic>>
<<2.80-complex-implementation>>
<<2.80-rational-implementation>>
<<2.80-generic-arithmetic>>

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)

(=zero? 5)
(=zero? 0)
(=zero? (make-rational 0 2))
(=zero? (make-rational 2 2))
(=zero? (make-complex-from-real-imag 2 2))
(=zero? (make-complex-from-real-imag 0 0))
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
#f
#t
#t
#f
#f
#t
#+end_example

Another exercise done, this time because we just needed to add four procedures in total, with pretty minimal bindings to make it generic.
* Exercise 2.81
** Prompt
Louis Reasoner has found that the latest implementation of ~apply-generic~ would try to coerce a type into its own type if there are two arguments of different types. This guy reaons that we should therefore put procedures that does identity coercion into the coercion table. He would do the following:
#+begin_src racket :exports code
(define (scheme-number->scheme-number n)
  n)
(define (complex->complex z)
  z)
(put-coercion 'scheme-number 'scheme-number scheme-number->scheme-number)
(put-coercion 'complex 'complex complex->complex)
#+end_src

For reference, the new ~apply-generic~ looks like this:

#+begin_src racket :exports code
(define (apply-generic op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args)) ; This line happens when
          ; there is a registered type operation
          (if (= (length args) 2) ; This is where we
              ; try to coerce. It is a fallback
              (let ([type1 (car type-tags)]
                    [type2 (cadr type-tags)]
                    [a1 (car args)]
                    [a2 (cadr args)])
                ;; The next steps here is to make the coercion occur on a list
                ;; of arbitrary length
                (let ([t1->t2 (get-coercion type1 type2)]
                      [t2->t1 (get-coercion type2 type1)])
                  (cond ; This is using the semantic that everything but false
                        ; is truthy
                    [t1->t2 (apply-generic op (t1->t2 a1) a2)]
                    [t2->t1 (apply-generic op a1 (t2->t1 a2))]
                    [else (error "No method for these types" (list op type-tags))])))
              (error "No method for these types" (list op type-tags)))))))
#+end_src

Answer the following:

a. With Louiss coercion procedures installed, what happens if apply-generic is called with two arguments of type scheme-number or two arguments of type complex for an operation that is not found in the table for those types? For example, assume that weve defined a generic exponentiation operation:
   #+begin_src racket :exports code
(define (exp x y) (apply-generic 'exp x y))
   #+end_src
   and have put a procedure for exponentiation in the
   Scheme-number package but not in any other package:
   #+begin_src racket :exports code
;; following added to Scheme-number package
(put 'exp '(scheme-number scheme-number)
(lambda (x y) (tag (expt x y))))
; using primitive expt
   #+end_src
   What happens if we call exp with two complex numbers as arguments?
b. Is Louis correct that something had to be done about
   coercion with arguments of the same type, or does
   apply-generic work correctly as is?
c. Modify apply-generic so that it doesnt try coercion
   if the two arguments have the same type.
** Solution
*** Part a
**** High level
Due to the nature of the implementation, if we give an identity coercion, we would lose the base case that would end the apply-generic recursive call to the coerced type. This would cause infinite recursion, hanging the program.
**** Step by step
#+begin_src racket :exports code
(exp a b)
(apply-generic 'exp a b)
(apply-generic 'exp (t1->t2 a) b)
(apply-generic 'exp (t1->t2 (t1->t2 a)) b)
(apply-generic 'exp (t1->t2 (t1->t2 (t1->t2 a))) b)
...
#+end_src

Since we would always be finding an identity coercion, the current implementation of the ~apply-generic~ procedure will always call itself with the same parameters, therefore causing infinite recursion, halting the program.
*** Part b
Louis was not correct that something had to be done about the coercion with arguments of the same type. This version of ~apply-generic~ is all about type conversion, and for the branch where the type conversion attempt was occurring, we could reason about that the required procedure is missing, and that we do not have the facility to search for more potential procedures (without having type raises). Maybe a more fail-safe way to write the ~apply-generic~ in a way that would stop attempts to coerce the types if they are already the same type.
*** Part c
#+name: updated-coerced-apply-generic
#+begin_src racket :exports code
(define (apply-generic op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ([type1 (car type-tags)]
                    [type2 (cadr type-tags)]
                    [a1 (car args)]
                    [a2 (cadr args)])
                (let ([t1->t2 (get-coercion type1 type2)]
                      [t2->t1 (get-coercion type2 type1)])
                  (cond
                    [(and t1->t2 (get op (list type2 type2))) (apply-generic op (t1->t2 a1) a2)]
                    [(and t2->t1 (get op (list type1 type1))) (apply-generic op a1 (t2->t1 a2))]
                    [else (error "No method for these types" (list op type-tags))])))
              (error "No method for these types" (list op type-tags)))))))
#+end_src

We needed the next conditional to be tested if there is no operation with one type coercion, therefore, the conditional check has to now include an attempt to see if the coercion would even result in a viable operation.

#+name: 2.81-rational-implementation
#+begin_src racket :exports code
(define (install-rational-package)
  ;; internal procedures
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  (define (equ? x y)
    (and (= (numer x) (numer y)) (= (denom x) (denom y))))
  (define (=zero? x)
    (= (numer x) 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put '=zero? '(rational) =zero?)
  (put 'equ? '(rational rational) equ?)
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
#+end_src

#+name: coercion-put-get-implementation
#+begin_src racket :exports code
(define *coercion-table* '())

(define (make-coercion-entry k v)
  (list k v))
(define (coercion-key entry)
  (car entry))
(define (coercion-value entry)
  (cadr entry))
;; Checks if the entry of the table has a matching parameter key
(define (coercion-key? k entry)
  (equal? (coercion-key entry) k))

(define (put-coercion t1 t2 item)
  (define (putter k array)
    (cond
      [(null? array) (list (make-coercion-entry k item))]
      [(coercion-key? k (car array)) array]
      [else (cons (car array) (putter k (cdr array)))]))
  (set! *coercion-table* (putter (list t1 t2) *coercion-table*)))

(define (get-coercion t1 t2)
  (define (getter k array)
    (cond
      [(null? array) #f]
      [(coercion-key? k (car array)) (coercion-value (car array))]
      [else (getter k (cdr array))]))
  (getter (list t1 t2) *coercion-table*))
#+end_src

#+name: 2.81-generic-arithmetic
#+begin_src racket :exports code
(define (add x y)
  (apply-generic 'add x y))
(define (sub x y)
  (apply-generic 'sub x y))
(define (mul x y)
  (apply-generic 'mul x y))
(define (div x y)
  (apply-generic 'div x y))
(define (equ? x y)
  (apply-generic 'equ? x y))
(define (exp x y)
  (apply-generic 'exp x y))
(define (=zero? x)
  (apply-generic '=zero? x))
#+end_src

#+name: basic-coercions-package
#+begin_src racket :exports code
(define (install-base-coercion)
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (define (scheme-number->rational n)
    (make-rational (contents n) 1))

  (put-coercion 'scheme-number 'complex scheme-number->complex)
  (put-coercion 'scheme-number 'rational scheme-number->rational))

#+end_src

#+name: 2.81-scheme-implementation
#+begin_src racket :exports code
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'exp '(scheme-number scheme-number) (lambda (x y) (tag (expt x y))))
  (put 'equ? '(scheme-number scheme-number) (lambda (x y) (= x y)))
  (put '=zero? '(scheme-number) (lambda (x) (= x 0)))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
#+end_src

#+caption: Testing that the exp and coercion is working as expected
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.81-scheme-implementation>>
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<updated-coerced-apply-generic>>
<<2.80-complex-implementation>>
<<2.80-rational-implementation>>
<<2.81-generic-arithmetic>>
<<basic-coercions-package>>

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-base-coercion)

(exp 2 3)
(add 2 3)
(add (make-complex-from-real-imag 4 4) 3)
(add 3 (make-complex-from-real-imag 4 4))
(exp (make-complex-from-real-imag 2 0) 4)
#+end_src

#+RESULTS:
: done
: done
: done
: done
: done
: 8
: 5
: (complex rectangular 7 . 4)
: (complex rectangular 7 . 4)

** Exercise 2.82
*** Prompt
Show how to generalize apply-generic to
handle coercion in the general case of multiple arguments.
One strategy is to attempt to coerce all the arguments to
the type of the first argument, then to the type of the second argument, and so on. Give an example of a situation
where this strategy (and likewise the two-argument version given above) is not sufficiently general. (Hint: Consider the case where there are some suitable mixed-type
operations present in the table that will not be tried.)
*** Solution
So here is what needs to happen. We need to know when two things fail: looking up the procedure with those types, and coercing to that type. We could make a procedure that tries to convert all the arguments passed to it to the type and either return that converted list, or false as a sentinel value. Then, we need to make a predicate that checks if a procedure with an arbitrary type tag exists. Actually, one more helper, we need to make a procedure that duplicates a listed type tag to a certain length list.

#+name: 2.82-coerced-apply-generic
#+begin_src racket :exports code
(define (apply-generic op . args)
  ;; returns #f if not all the types could be coerced to the target, else it is
  ;; all the targets, but coerced into the type t
  (define (coerce-to-type t targets)
    (define (reverse items)
      (define (inner acc res)
        (if (null? res)
            acc
            (inner (cons (car res) acc) (cdr res))))
      (if items
          (inner '() items)
          #f))
    (define (iter acc tail)
      (if (null? tail)
          acc
          (let ([curr (car tail)]
                [curr-type (type-tag (car tail))])
            (if (eq? curr-type t)
                (iter (cons curr acc) (cdr tail))
                (let ([coer-proc (get-coercion curr-type t)])
                  (if coer-proc
                      (iter (cons (coer-proc curr) acc) (cdr tail))
                      #f))))))
    (reverse (iter '() targets)))
  ;; This procedure will go through all the arguments and try to convert the
  ;; entire list of arguments into one type, starting with the first type, else
  ;; return #f
  (define (attempt-mass-coercion-for-op op args)
    (define (inner tail)
      (if (null? tail)
          #f
          (let ([head (car tail)])
            (let ([coer (coerce-to-type (type-tag head) args)])
              (if coer
                  (let ([found-op (get op (map type-tag coer))])
                    (if found-op
                        coer
                        (inner (cdr tail))))
                  (inner (cdr tail)))))))
    (inner args))
  ;; Actual implementation
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (let ([coerced (attempt-mass-coercion-for-op op args)])
            (if coerced
                (apply (get op (map type-tag coerced)) (map contents coerced))
                (error "no method found for following args" (list op args))))))))
#+end_src

The idea here is that without some sort of a test, you don't know if your implementation is working or not. Since it's an exercise, we are not going to use real automated testing.

#+caption: Testing that the generic coercion implementation is working.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.81-scheme-implementation>>
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.82-coerced-apply-generic>>
<<2.80-complex-implementation>>
<<2.80-rational-implementation>>
<<2.81-generic-arithmetic>>
<<basic-coercions-package>>

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-base-coercion)

(exp 2 3)
(add 2 3)
(add (make-complex-from-real-imag 4 4) 3)
(add 3 (make-complex-from-real-imag 4 4))
(sub 5 (make-complex-from-mag-ang 9 1.5))
(exp (make-complex-from-real-imag 2 0) 4)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
8
5
(complex rectangular 7 . 4)
(complex rectangular 7 . 4)
(complex rectangular 4.363365184990673 . -8.97745487943649)
#+end_example

This is working as we expect it to. Now to the discussions of the weakness of the method we have implemented. There are cases where there are legal, or even preferred mixed type operations. A notable one is exponentiation. Say we implement exponentiation for base as a rational number, and the exponent as a ~scheme-number~. In the instance that we call the exponentiation procedure with the base as a rational number, but the exponent as a complex number that is convertable to a scheme number, the specific operation of not converting the rational number, but attempting to convert the exponent argument to a scheme number will never occur.

** Exercise 2.83
*** Prompt
Suppose you are designing a generic arithmetic system for dealing with the tower of types shown in the previous chapter, where the types are integer, rational, real, complex. For each type except complex, design a procedure that raises objects of that type one level in the tower. Show how to install a generic ~raise~ operation that will work for each type (except complex). Also, and an added challenge, keep the scheme numbers in the system.
*** Solution
:LOGBOOK:
CLOCK: [2025-02-16 Sun 16:16]--[2025-02-16 Sun 17:06] =>  0:50
:END:
#+name: raise-tower-of-types
#+begin_src racket :exports code
;; Making raise an operation, and then installing it into a generic application
(define (install-raise)
  (define (real->complex n)
    (make-complex-from-real-imag n 0))
  (define (rational->real n)
    (make-real (/ (numer n) (denom n))))
  (define (integer->rational n)
    (make-rational n 1))
  (define (scheme-number->real n)
    (make-real n))
  (put-coercion 'real 'complex real->complex)
  (put-coercion 'scheme-number 'complex real->complex)
  (put-coercion 'rational 'real rational->real)
  (put-coercion 'integer 'rational integer->rational)
  (put-coercion 'scheme-number 'real scheme-number->real)
  'done)

(define default-ranks '(integer rational real complex))

(define (lowest-rank)
  0)
(define (highest-rank)
  (define (iter acc tail)
    (if (null? tail)
        (- acc 1) ;; the highest rank was the prev element
        (iter (+ acc 1) (cdr tail))))
  (iter 0 default-ranks))

;; currently operates on types and rank
(define (lowest-rank? n)
  (cond
    [(number? n) (= n (lowest-rank))]
    [else (= (lowest-rank) (rank-of-type n))]))

;; currently operates on types and rank
(define (highest-rank? n)
  (cond
    [(number? n) (>= n (highest-rank))]
    [else (>= (rank-of-type n) (highest-rank))]))

;; where n is the rank as a number. If the value provided does not fall into the
;; available rank, then return false. This procedure returns the default rank
(define (type-of-rank n)
  (define (iter acc tail)
    (cond
      [(null? tail) false]
      [(= acc n) (car tail)]
      [else (iter (+ acc 1) (cdr tail))]))
  (iter 0 default-ranks))

(define (rank-of-type n)
  (cond
    [(eq? n 'integer) 0]
    [(eq? n 'rational) 1]
    [(eq? n 'real) 2]
    [(eq? n 'scheme-number) 2]
    [(eq? n 'complex) 3]
    [else false]))

;; checks if the input type is participating in ranks
(define (ranked? n)
  (if (not rank-of-type) false true))

(define (rank-of-datum n)
  (rank-of-type (type-tag n)))

;; get the default type for a given type
(define (default-type-of-type t)
  (type-of-rank (rank-of-type t)))

;; coerce an actual datum to their default type
(define (to-default-type datum)
  (let ([curr-type (type-tag datum)])
    (let ([target-type (default-type-of-type curr-type)])
      (if (eq? curr-type target-type)
          datum
          (let ([coer-proc (get-coercion curr-type target-type)])
            (if (not coer-proc)
                (error "missing coercion procedure for the following type"
                       (list curr-type target-type datum))
                (coer-proc (contents datum))))))))

;; The idea behind this one is that we are trying to look for the correct type
;; to coerce to that is of a higher rank. If we are already at the highest rank
;; then we cannot raise, and we will return the same type
;;
;; Highest rank -> return itself
;; if not the highest rank, and also not the default type of the rank, ->
;; convert to the default type of rank
;; failed to get coercion procedure -> raise error
;; else -> return coerced value
(define (raise n)
  (let ([para-type (type-tag n)])
    (let ([para-rank (rank-of-type para-type)])
      (if (or (not para-rank) (highest-rank? para-rank))
          n
          (let ([safe-curr-datum (if (eq? (default-type-of-type para-type) para-type)
                                     n
                                     (to-default-type n))]
                [next-type (type-of-rank (+ para-rank 1))])
            (let ([coer-proc (get-coercion (type-tag safe-curr-datum) next-type)])
              (if (not coer-proc)
                  (error "could not find coercion procedure for the following type"
                         (list (type-tag safe-curr-datum) next-type safe-curr-datum n))
                  (coer-proc (contents safe-curr-datum)))))))))
#+end_src


For the sake of reusing our rational number type, and making our own number typing system, we will implement integer and reals, and add scheme-numbers as the same type ranking as real numbers. Really, we could have gone through this in many ways, such as not even making our own integer and reals, and using the built in scheme types, since they are able to identify if the value is an integer, rational number or real number.

#+name: 2.83-integer-type-package
#+begin_src racket :exports code
(define (install-integer-package)
  ;; internal procedures
  (define (make-int n)
    (cond [(integer? n) n]
          [(number? n) (floor n)]
          [else (error "bad argument: MAKE-INT" n)]))
  (define (add-int x y)
    (make-int (+ x y)))
  (define (sub-int x y)
    (make-int (- x y)))
  (define (mul-int x y)
    (make-int (* x y)))
  (define (div-int x y)
    (make-int (* x y)))
  (define (equ? x y)
    (= x y))
  (define (=zero? x)
    (= x 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'integer x))
  (put 'add '(integer integer) (lambda (x y) (tag (add-int x y))))
  (put 'sub '(integer integer) (lambda (x y) (tag (sub-int x y))))
  (put 'mul '(integer integer) (lambda (x y) (tag (mul-int x y))))
  (put 'div '(integer integer) (lambda (x y) (tag (div-int x y))))
  (put '=zero? '(integer) =zero?)
  (put 'equ? '(integer integer) equ?)
  (put 'make 'integer (lambda (n) (tag (make-int n))))
  'done)
(define (make-integer n)
  ((get 'make 'integer) n))
#+end_src

We are going to make the real numbers just a scheme number in this representation, just so that we could focus on the type tower.
#+name: 2.83-real-type-package
#+begin_src racket :exports code
(define (install-real-package)
  ;; internal procedures
  (define (make-real n)
    (cond [(number? n) n]
          [else (error "bad argument: MAKE-REAL" n)]))
  (define (add-real x y)
    (make-real (+ x y)))
  (define (sub-real x y)
    (make-real (- x y)))
  (define (mul-real x y)
    (make-real (* x y)))
  (define (div-real x y)
    (make-real (* x y)))
  (define (equ? x y)
    (= x y))
  (define (=zero? x)
    (= x 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'real x))
  (put 'add '(real real) (lambda (x y) (tag (add-real x y))))
  (put 'sub '(real real) (lambda (x y) (tag (sub-real x y))))
  (put 'mul '(real real) (lambda (x y) (tag (mul-real x y))))
  (put 'div '(real real) (lambda (x y) (tag (div-real x y))))
  (put '=zero? '(real) =zero?)
  (put 'equ? '(real real) equ?)
  (put 'make 'real (lambda (n) (tag (make-real n))))
  'done)
(define (make-real n)
  ((get 'make 'real) n))
#+end_src

#+name: 2.83-rational-implementation
#+begin_src racket :exports code
(define (install-rational-package)
  ;; internal procedures
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  (define (equ? x y)
    (and (= (numer x) (numer y)) (= (denom x) (denom y))))
  (define (=zero? x)
    (= (numer x) 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put '=zero? '(rational) =zero?)
  (put 'equ? '(rational rational) equ?)
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  (put 'numer 'rational (lambda (n) (numer n))) ;; numerator and denominator
  (put 'denom 'rational (lambda (n) (denom n)))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (numer x)
  ((get 'numer 'rational) x))
(define (denom x)
  ((get 'denom 'rational) x))
#+end_src

#+caption: Testing that the type raising system is working as intended.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.82-coerced-apply-generic>>
<<2.80-complex-implementation>>
<<2.83-rational-implementation>>
<<2.81-generic-arithmetic>>
<<2.83-integer-type-package>>
<<2.83-real-type-package>>
<<2.83-type-rank>>
<<basic-coercions-package>>
<<raise-tower-of-types>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-base-coercion)
(install-raise)

(define (double-up proc)
  (lambda (x) (proc (proc x))))
(define quad-up (double-up double-up))

(highest-rank)

(raise (make-integer 3))
((double-up raise) (make-integer 3))
(raise ((double-up raise) (make-integer 3)))
((quad-up raise) (make-integer 3))
(raise 3)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
3
(rational 3 . 1)
(real . 3)
(complex rectangular 3 . 0)
(complex rectangular 3 . 0)
(complex rectangular 3 . 0)
#+end_example


** Exercise 2.84
*** Prompt
Using the ~raise~ operation from the previous exercise, modify the ~apply-generic~ procedure so that it coerces its arguments to have the same type by the method of successive raising, as discussed in this section. You will need to devise a way to test which of two types is higher in the tower. Do this in a manner that is "compatible" with the rest of the system and will not lead to problems in adding new levels to the tower.

*** Solution
:LOGBOOK:
CLOCK: [2025-02-16 Sun 15:16]--[2025-02-16 Sun 16:06] =>  0:50
CLOCK: [2025-02-16 Sun 13:42]--[2025-02-16 Sun 14:32] =>  0:50
CLOCK: [2025-02-16 Sun 12:49]--[2025-02-16 Sun 13:14] =>  0:25
CLOCK: [2025-02-16 Sun 12:09]--[2025-02-16 Sun 12:34] =>  0:25
:END:

Right, we are thinking about making the type tower system easy to add to. Luckily for us, we already did that. We needed a way of checking which type is higher in the tower, so we have to implement that here. The specifics of the implementation is our decision, but here are the things I would like to be able to check from this comparison procedure. We need to know if the left type is lower, higher or equal. There are three states that could be checked, and we could make one function that returns the three state, but actually, we will choose to go with a few set of predicates.

#+name: 2.84-type-comparison
#+begin_src racket :exports code
;; the higher-type predicate could now find out if higher type by looking at the
;; type-rank
(define (higher-rank? left right)
  (let ([left-t-rank (rank-of-type left)]
        [right-t-rank (rank-of-type right)])
    (cond
      [(not left-t-rank)
       (error "left type is not registered in the type rank system" (list left right))]
      [(not right-t-rank)
       (error "right type rank is not registered in the type rank system" (list left right))]
      [else (> left-t-rank right-t-rank)])))

;; This procedure will raise a datum to the specified type. Returns false if
;; this operation fails
(define (consecutive-raise datum target-type)
  (define (raise-to-rank acc rank)
    (let ([curr-rank (rank-of-datum acc)])
      (cond
        [(not curr-rank) (error "datum parameter not participating in ranks" (list datum target-type))]
        [(> rank curr-rank) (raise-to-rank (raise acc) rank)]
        [(= rank curr-rank) (to-default-type acc)]
        [else false])))
  (let ([target-rank (rank-of-type target-type)])
    (if (> target-rank (highest-rank))
        (error "rank of the target type is too high, malformed system"
               (list target-rank target-type datum))
        (raise-to-rank datum target-rank))))
#+end_src


Time to change apply generic. In this change, we are now coupling the implementation of apply generic with the tower of type system that we built. What does this mean? It means that we are now detecting the highest type in the group of arguments, and then we are doing consecutive raising until we brought the content to the desired type.

#+name: 2.84-raise-apply-generic
#+begin_src racket :exports code
(define (apply-generic op . args)
  ;; accumulation procedure to find the highest type in the input args.
  ;; Takes in datum args and not just the type args
  (define (highest-rank args)
    (left-fold (lambda (acc ele) (if (> ele acc) ele acc)) (lowest-rank) (map rank-of-datum args)))
  ;; This brings all the input args to a target type
  (define (raise-args-to-type target-type args)
    (map (lambda (x) (consecutive-raise x target-type)) args))
  (define (validate args)
    (define (iter left)
      (cond
        [(null? left) args]
        [(not (car left)) false]
        [else (iter (cdr left))]))
    (iter args))
  ;; procedure that attempts to raise the input datum args to the
  ;; highest type. If this fails, then return false
  (define (raise-args-to-highest args)
    (validate (raise-args-to-type (type-of-rank (highest-rank args)) args)))
  ;; Actual implementation
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (let ([coerced (raise-args-to-highest args)])
            (if (not coerced)
                (error "unable to coerce all args to highest type" (list op args type-tags))
                (let ([coerced-proc (get op (map type-tag coerced))])
                  (if (not coerced-proc)
                      (error "unable to find method for arguments" (list op coerced))
                      (apply coerced-proc (map contents coerced))))))))))
#+end_src

We stopped using the testing frameworks since we keep on building many throwaway code, which don't really regress, since we are just making new ones.
#+caption: Testing that the type raising system is working as intended.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.84-raise-apply-generic>>
<<2.80-complex-implementation>>
<<2.83-rational-implementation>>
<<2.81-generic-arithmetic>>
<<2.83-integer-type-package>>
<<2.83-real-type-package>>
<<basic-coercions-package>>
<<2.81-scheme-implementation>>
<<raise-tower-of-types>>
<<2.83-default-rank-type>>
<<2.83-type-rank>>
<<2.84-type-comparison>>
<<functional-interface>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-raise)
(install-scheme-number-package)

;; testing if we could consecutively raise the type
(consecutive-raise (make-real 2) 'complex)
(consecutive-raise (make-integer 2) 'rational)
(consecutive-raise (make-rational 3 5) 'real)
(consecutive-raise (make-real 3.4) 'complex)
(consecutive-raise 3.4 'complex)

(newline)
(display "testing apply generic now")
(newline)
(newline)
(add (make-real 2.5) (make-real 6.4))
(add (make-complex-from-real-imag 4 4) 3)
(add (make-rational 4 4) 3)
(add (make-complex-from-real-imag 4 4) (make-integer 3))
(add (make-rational 8 3) (make-integer 2))
(add (make-rational 7 3) (make-complex-from-real-imag 4 4))
(add (make-complex-from-real-imag 4 4) (make-rational 7 3))
(add (make-complex-from-real-imag 4 4) (make-real 3.7))
(add (make-integer 3) (make-complex-from-real-imag 4 4))
(add (make-real 3.7) (make-complex-from-real-imag 4 4))
(add (make-rational 8 1) (make-complex-from-real-imag 4 4))
(sub (make-complex-from-real-imag 4 4) (make-real 4.7))
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
(complex rectangular 2 . 0)
(rational 2 . 1)
(real . 3/5)
(complex rectangular 3.4 . 0)
(complex rectangular 3.4 . 0)

testing apply generic now

(real . 8.9)
(complex rectangular 7 . 4)
(real . 4)
(complex rectangular 7 . 4)
(rational 14 . 3)
(complex rectangular 19/3 . 4)
(complex rectangular 19/3 . 4)
(complex rectangular 7.7 . 4)
(complex rectangular 7 . 4)
(complex rectangular 7.7 . 4)
(complex rectangular 12 . 4)
(complex rectangular -0.7000000000000002 . 4)
#+end_example

From this result, we show that we are able to consecutively raise the types of the different parameters to those of the highest type in the arguments. Now, we can move to the next exercise.
** Exercise 2.85
*** Prompt
This section mentioned a method for "simplifying" a data object by lowering it in the tower of types as far as possible. Design a procedure ~drop~ that accomplishes this for the tower we have been working on. The key is to decide, in some general way, whether an object can be lowered. For example, the complex number 1.5 + 0i can be lowered as far as ~real~, the complex number 1 + 0i can be lowered as far as ~integer~, and the complex number 2 + 3i cannot be lowered at all. Here is a plan for determining whether an object can be lowered: Begin by defining a generic operation ~project~ that "pushes" an object down in the tower. For example, projecting a complex number would involve throwing away the imaginary part. then a number can be dropped if, when we ~project~ it and ~raise~ the result back to the type we started with, we end up with something equal to what we started with (making sure it is not lossless). Show how to implement this idea in detail, by writing a ~drop~ procedure that drops an object as far as possible. You will need to design the various projection operations and install ~project~ as a generic operation in the system. You will also need to make use of a generic equality predicate, such as described in Exercise 2.79. Finally, use ~drop~ to rewrite ~apply-generic~ from Exercise 2.84 so it "simplifies" its answers.
*** Solution
:LOGBOOK:
CLOCK: [2025-02-16 Sun 19:13]--[2025-02-16 Sun 20:03] =>  0:50
:END:

We can design ~drop~, but we would have to define all the one step conversion downwards. Using the architecture defined by the book, we could define the conversion method in a lossy way, as there will be a generic procedure that handles the case that we lost information in the conversion.

#+name: 2.85-drop
#+begin_src racket :exports code
(define (install-project)
  (define (complex->real n)
    (make-real (real-part n)))
  (define (real->rational n)
    (make-rational (* n 10) 10))
  (define (rational->integer n)
    (make-integer (/ (numer n) (denom n))))

  (put-coercion 'complex 'real complex->real)
  (put-coercion 'real 'rational real->rational)
  (put-coercion 'rational 'integer rational->integer)
  'done)

;; Project allows for lossy downward coercion of the type. Project will return
;; the same item if we are at the bottom of the type tower. If the type is not
;; participating in type ranking, then return itself
(define (project n)
  (let ([curr-type-rank (rank-of-datum n)])
    (cond
      [(not curr-type-rank) n]
      [(= curr-type-rank (lowest-rank)) n]
      [(< curr-type-rank (lowest-rank))
       (error "type rank of parameter lower than lowest rank registered"
              (list curr-type-rank (lowest-rank) n))]
      [else
       (let ([cleaned-arg (to-default-type n)]
             [next-type (type-of-rank (- curr-type-rank 1))])
         (let ([coer-proc (get-coercion (type-tag cleaned-arg) next-type)])
           (if (not coer-proc)
               (error "missing coercion procedure for the following types"
                      (list (type-tag cleaned-arg next-type n)))
               (coer-proc (contents cleaned-arg)))))])))

;; Checks if the value v is a droppable type
(define (droppable? v)
  (cond
    [(not (pair? v)) false]
    [(contain? (type-tag v) default-ranks) true]
    [else false]))

;; Drop will prevent lossy dropping of the value, but it will also drop it as far as possible
(define (drop n)
  (define (iter prev)
    (let ([projected (project prev)])
      (if (or (= (rank-of-datum projected) (rank-of-datum prev)) (not (equ? (raise projected) prev)))
          prev
          (iter projected))))
  (iter (to-default-type n)))
#+end_src


#+name: 2.85-raise-drop-apply-generic
#+begin_src racket :exports code
(define (apply-generic op . args)
  ;; accumulation procedure to find the highest type in the input args.
  ;; Takes in datum args and not just the type args. If there are datums that
  ;; are not participating in the rank system, this procedure will return
  ;; false
  (define (highest-rank args)
    (left-fold (lambda (acc ele)
                 (cond
                   [(or (not (number? acc)) (not (number? ele))) false]
                   [(> acc ele) acc]
                   [else ele]))
               (lowest-rank)
               (map rank-of-datum args)))
  ;; This brings all the input args to a target type
  (define (raise-args-to-type target-type args)
    (map (lambda (x) (consecutive-raise x target-type)) args))
  (define (validate args)
    (define (iter left)
      (cond
        [(null? left) args]
        [(not (car left)) false]
        [else (iter (cdr left))]))
    (iter args))
  ;; procedure that attempts to raise the input datum args to the
  ;; highest type. If this fails, then return false
  (define (raise-args-to-highest args)
    (let ([local-largest-rank (highest-rank args)])
      (if (not local-largest-rank)
          false
          (validate (raise-args-to-type (type-of-rank local-largest-rank) args)))))

  (define (handle-output v)
    (if (droppable? v)
        (drop v)
        v))
  ;; Actual implementation
  (define (apply-generic-aux)
    ;; (display "apply-generic ") (display (list op args)) (newline)
    (let ([type-tags (map type-tag args)])
      (let ([proc (get op type-tags)])
        ;; (display "apply-generic-aux ") (display (list type-tags proc)) (newline)
        (if proc
            (apply proc (map contents args))
            (let ([coerced (raise-args-to-highest args)])
              (if (not coerced)
                  (error "unable to find method for argument, and coercion failed:" op type-tags args)
                  (let ([coerced-proc (get op (map type-tag coerced))])
                    (if (not coerced-proc)
                        (error "unable to find method for arguments:" op coerced)
                        (apply coerced-proc (map contents coerced))))))))))
  (handle-output (apply-generic-aux)))
#+end_src


To test our implementation, we can use the set of tests from the previous exercise with updated imports.
#+caption: Testing that the type dropping system is working as intended.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.85-raise-drop-apply-generic>>
<<2.80-complex-implementation>>
<<2.83-rational-implementation>>
<<2.81-generic-arithmetic>>
<<2.83-integer-type-package>>
<<2.83-real-type-package>>
<<basic-coercions-package>>
<<raise-tower-of-types>>
<<2.84-type-comparison>>
<<functional-interface>>
<<2.81-scheme-implementation>>
<<2.85-drop>>
<<2.83-type-rank>>
<<2.83-default-rank-type>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-raise)
(install-project)
(install-scheme-number-package)

(newline)
(display "testing project")
(newline)

(project (make-complex-from-real-imag 8 0))
(project (project (make-complex-from-real-imag 8 0)))
(project (project (project (make-complex-from-real-imag 8 0))))

(newline)
(display "testing drop, and its limits")
(newline)

(drop (make-complex-from-real-imag 8 0))
(drop 64)
(drop (drop (make-complex-from-real-imag 8 0)))
(drop (drop (drop (make-complex-from-real-imag 8 0))))

(drop (make-complex-from-real-imag 8.5 0))
(drop (drop (make-complex-from-real-imag 8.5 0)))
(drop (drop (drop (make-complex-from-real-imag 8.5 0)))) ;; This should still be stuck at rational

(newline)
(display "testing apply generic now")
(newline)
(newline)
(add 2.5 6.4)
(add (make-complex-from-real-imag 4 4) 3)
(add (make-complex-from-real-imag 4 0) (make-complex-from-real-imag 7.4314 0))
(add (make-complex-from-real-imag 4 0) (make-complex-from-real-imag 7 0))
(add (make-rational 8 3) 2)
(add (make-rational 7 3) (make-complex-from-real-imag 4 0))
(add (make-complex-from-real-imag 4 4) (make-rational 7 3))
(add (make-complex-from-real-imag 4 4) 3.7)
(add 3 (make-complex-from-real-imag 4 0))
(add 3.7 (make-complex-from-real-imag 4 4))
(add (make-rational 8 1) (make-complex-from-real-imag 4 4))
(sub (make-complex-from-real-imag 4 0) 4.7)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done

testing project
(real . 8)
(rational 8 . 1)
(integer . 8)

testing drop, and its limits
(integer . 8)
(integer . 64)
(integer . 8)
(integer . 8)
(rational 17.0 . 2.0)
(rational 17.0 . 2.0)
(rational 17.0 . 2.0)

testing apply generic now

8.9
(complex rectangular 7 . 4)
(rational 4022066310962741.0 . 351843720888320.0)
(integer . 11)
(rational 14 . 3)
(rational 19 . 3)
(complex rectangular 19/3 . 4)
(complex rectangular 7.7 . 4)
(integer . 7)
(complex rectangular 7.7 . 4)
(complex rectangular 12 . 4)
(rational -788129934789837.0 . 1125899906842624.0)
#+end_example

Yep, we were able to satisfy the requirements set by the exercise. Types are getting dropped as expected now (with the exception of make-rational being a little funny, but that is not the spirit of the exercise.)
** Exercise 2.86
*** Prompt
Suppose we want to handle complex numbers whose real parts, imaginary parts, magnitudes, and angles can be either ordinary numbers, rational numbers, or
other numbers we might wish to add to the system. Describe and implement the changes to the system needed to
accommodate this. You will have to define operations such
as sine and cosine that are generic over ordinary numbers
and rational numbers.
*** Solution
Target change site is the complex number construction. What does this mean? It means that we have to change the construction for the complex package. Reading the prompt, we are really just making it so that the complex number implementation can use other numbers as the component.

For this to work, internally, the complex package must now use the generic arithmetic operations, so that the operations would work on the scheme numbers and the ones created for this exercise. Those operation includes the trigonometry operations, therefore, some basic operations must be implemented for all the arithmetic packages that we have built so far. ~atan~ is required as well, but that could be composed out of generic procedures. The ~equ?~ and ~=zero?~ procedure also had to have their internal names changed in the complex package, as to not collide with the generic version. Finally, due to how we built the type system, with the concept of rank, we will run into an issue with real and imaginary components that are lower rank than the target of the ~project~ procedure. We can fix this by bringing the real component of the complex number to the ~'real~ type, and then converting that into a scheme number for the ~make-real~ procedure. Otherwise, this is practically all the changes required.

Also, we needed a generic ~sqrt~ procedure, so we also implemented it on all the number types we are responsible for.

#+name: 2.86-generic-arithmetic
#+begin_src racket :exports code
(define (add x y)
  (apply-generic 'add x y))
(define (sub x y)
  (apply-generic 'sub x y))
(define (mul x y)
  (apply-generic 'mul x y))
(define (div x y)
  (apply-generic 'div x y))
(define (equ? x y)
  (apply-generic 'equ? x y))
(define (exp x y)
  (apply-generic 'exp x y))
(define (squrt x)
  (apply-generic 'squrt x))
(define (cosine x)
  (apply-generic 'cosine x))
(define (sine x)
  (apply-generic 'sine x))
(define (arctan x)
  (div (cosine x) (sine x)))
(define (square x)
  (mul x x))
(define (=zero? x)
  (apply-generic '=zero? x))
#+end_src

Because we designed the system in such a way, we can just implement all the new required operations in the real type.
#+name: 2.86-real-type-package
#+begin_src racket :exports code
(define (install-real-package)
  ;; internal procedures
  (define (make-real n)
    (cond
      [(number? n) n]
      [else (error "bad argument: MAKE-REAL" n)]))
  (define (add-real x y)
    (make-real (+ x y)))
  (define (sub-real x y)
    (make-real (- x y)))
  (define (mul-real x y)
    (make-real (* x y)))
  (define (div-real x y)
    (make-real (* x y)))
  (define (squrt-real x)
    (make-real (sqrt x)))
  (define (cosine-real x)
    (make-real (cos x)))
  (define (sine-real x)
    (make-real (sin x)))
  (define (equ? x y)
    (= x y))
  (define (=zero? x)
    (= x 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'real x))
  (put 'add '(real real) (lambda (x y) (tag (add-real x y))))
  (put 'sub '(real real) (lambda (x y) (tag (sub-real x y))))
  (put 'mul '(real real) (lambda (x y) (tag (mul-real x y))))
  (put 'div '(real real) (lambda (x y) (tag (div-real x y))))
  (put '=zero? '(real) =zero?)
  (put 'equ? '(real real) equ?)
  (put 'squrt '(real) (lambda (x) (tag (squrt-real x))))
  (put 'cosine '(real) (lambda (x) (tag (cosine-real x))))
  (put 'sine '(real) (lambda (x) (tag (sine-real x))))
  (put 'make 'real (lambda (n) (tag (make-real n))))
  'done)
(define (make-real n)
  ((get 'make 'real) n))
#+end_src

#+name: 2.86-rational-implementation
#+begin_src racket :exports code
(define (install-rational-package)
  ;; internal procedures
  (define (to-scheme-number x)
    (/ (numer x) (denom x)))
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  (define (squrt-rat x)
    (make-rat (sqrt (numer x)) (sqrt (denom x))))
  (define (cosine-rat x)
    (make-rat (cos (to-scheme-number x)) 1))
  (define (sine-rat x)
    (make-rat (sin (to-scheme-number x)) 1))
  (define (equ? x y)
    (and (= (numer x) (numer y)) (= (denom x) (denom y))))
  (define (=zero? x)
    (= (numer x) 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put '=zero? '(rational) =zero?)
  (put 'equ? '(rational rational) equ?)
  (put 'squrt '(rational) (lambda (x) (tag (squrt-rat x))))
  (put 'cosine '(rational) (lambda (x) (tag (cosine-rat x))))
  (put 'sine '(rational) (lambda (x) (tag (sine-rat x))))
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  (put 'numer 'rational (lambda (n) (numer n))) ;; numerator and denominator
  (put 'denom 'rational (lambda (n) (denom n)))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (numer x)
  ((get 'numer 'rational) x))
(define (denom x)
  ((get 'denom 'rational) x))
#+end_src

#+name: 2.86-integer-type-package
#+begin_src racket :exports code
(define (install-integer-package)
  ;; internal procedures
  (define (make-int n)
    (cond [(integer? n) n]
          [(number? n) (floor n)]
          [else (error "bad argument: MAKE-INT" n)]))
  (define (add-int x y)
    (make-int (+ x y)))
  (define (sub-int x y)
    (make-int (- x y)))
  (define (mul-int x y)
    (make-int (* x y)))
  (define (div-int x y)
    (make-int (* x y)))
  (define (equ? x y)
    (= x y))
  (define (=zero? x)
    (= x 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'integer x))
  (put 'add '(integer integer) (lambda (x y) (tag (add-int x y))))
  (put 'sub '(integer integer) (lambda (x y) (tag (sub-int x y))))
  (put 'mul '(integer integer) (lambda (x y) (tag (mul-int x y))))
  (put 'div '(integer integer) (lambda (x y) (tag (div-int x y))))
  (put '=zero? '(integer) =zero?)
  (put 'equ? '(integer integer) equ?)
  (put 'make 'integer (lambda (n) (tag (make-int n))))
  'done)
(define (make-integer n)
  ((get 'make 'integer) n))
#+end_src

#+name: 2.86-scheme-implementation
#+begin_src racket :exports code
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'exp '(scheme-number scheme-number) (lambda (x y) (tag (expt x y))))
  (put 'equ? '(scheme-number scheme-number) (lambda (x y) (= x y)))
  (put 'squrt '(scheme-number) (lambda (x) (tag (sqrt x))))
  (put 'cosine '(scheme-number) (lambda (x) (tag (cos x))))
  (put 'sine '(scheme-number) (lambda (x) (tag (sin x))))
  (put '=zero? '(scheme-number) (lambda (x) (= x 0)))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
#+end_src

#+name: 2.86-complex-implementation
#+begin_src racket :exports code

(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z)
    (car z))
  (define (imag-part z)
    (cdr z))
  (define (make-from-real-imag x y)
    (cons x y))
  (define (magnitude z)
    (sqrt (add (square (real-part z)) (square (imag-part z)))))
  (define (angle z)
    (arctan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (mul r (cosine a)) (mul r (sine a))))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z)
    (car z))
  (define (angle z)
    (cdr z))
  (define (make-from-mag-ang r a)
    (cons r a))
  (define (real-part z)
    (mul (magnitude z) (cosine (angle z))))
  (define (imag-part z)
    (mul (magnitude z) (sine (angle z))))
  (define (make-from-real-imag x y)
    (cons (squrt (add (square x) (square y))) (arctan y x)))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2)) (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2)) (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2)) (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2)) (sub (angle z1) (angle z2))))
  (define (equ?-complex z1 z2)
    (and (equ? (real-part z1) (real-part z2)) (equ? (imag-part z1) (imag-part z2))))
  (define (=zero?-complex z)
    (equ? (magnitude z) 0))
  ;; interface to rest of the system
  (define (tag z)
    (attach-tag 'complex z))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'equ? '(complex complex) equ?-complex)
  (put '=zero? '(complex) =zero?-complex)
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
#+end_src

#+name: 2.86-drop
#+begin_src racket :exports code
(define (install-project)
  ;; This has to now account for the type of the real part of the of the complex
  ;; value. We could make a quick hack, which involves bringing the real
  ;; component to real, and then converting it to a scheme number
  (define (complex->real n)
    (make-real (contents (consecutive-raise (real-part n) 'real))))
  (define (real->rational n)
    (make-rational (* n 10) 10))
  (define (rational->integer n)
    (make-integer (/ (numer n) (denom n))))

  (put-coercion 'complex 'real complex->real)
  (put-coercion 'real 'rational real->rational)
  (put-coercion 'rational 'integer rational->integer)
  'done)

;; Project allows for lossy downward coercion of the type. Project will return
;; the same item if we are at the bottom of the type tower.
(define (project n)
  (let ([curr-type-rank (rank-of-datum n)])
    (cond
      [(not curr-type-rank) n]
      [(= curr-type-rank (lowest-rank)) n]
      [(< curr-type-rank (lowest-rank))
       (error "type rank of parameter lower than lowest rank registered"
              (list curr-type-rank (lowest-rank) n))]
      [else
       (let ([cleaned-arg (to-default-type n)]
             [next-type (type-of-rank (- curr-type-rank 1))])
         (let ([coer-proc (get-coercion (type-tag cleaned-arg) next-type)])
           (if (not coer-proc)
               (error "missing coercion procedure for the following types"
                      (list (type-tag cleaned-arg next-type n)))
               (coer-proc (contents cleaned-arg)))))])))

;; Checks if the value v is a droppable type. Droppables have to participate
;; in the rank system.
(define (droppable? v)
  (cond
    [(not (pair? v)) false]
    [(contain? (type-tag v) default-ranks) true]
    [else false]))

;; Drop will prevent lossy dropping of the value, but it will also drop it as far as possible
(define (drop n)
  (define (iter prev)
    (let ([projected (project prev)])
      (if (or (= (rank-of-datum projected) (rank-of-datum prev)) (not (equ? (raise projected) prev)))
          prev
          (iter projected))))
  (if (droppable? n)
      (iter (to-default-type n))
      n))
#+end_src

#+RESULTS: 2.86-drop

#+caption: Testing that composible complex type is working.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.85-raise-drop-apply-generic>>
<<2.86-complex-implementation>>
<<2.86-rational-implementation>>
<<2.86-generic-arithmetic>>
<<2.86-integer-type-package>>
<<2.86-real-type-package>>
<<basic-coercions-package>>
<<raise-tower-of-types>>
<<2.84-type-comparison>>
<<functional-interface>>
<<2.86-scheme-implementation>>
<<2.86-drop>>
<<2.83-type-rank>>
<<2.83-default-rank-type>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-raise)
(install-project)
(install-scheme-number-package)

(newline)
(display "testing project")
(newline)

(project (make-complex-from-real-imag 8 0))
;; Oh my god, project is now failing with the new type, since we could now be
;; working with a real component that is of a lower rank than the rank right
;; below complex numbers. Really, we could just handle this on the coercion
;; procedure.
(project (make-complex-from-real-imag (make-integer 8) (make-integer 0 )))
(project (project (make-complex-from-real-imag 8 0)))
(project (project (project (make-complex-from-real-imag 8 0))))

(newline)
(display "testing drop, and its limits")
(newline)

(equ? (make-complex-from-real-imag 8 0) (make-complex-from-real-imag 4.2 0))
(equ? (make-complex-from-real-imag 8 0) (make-complex-from-real-imag 8 0))

;; Now we just start testing equ? with different number representation in the make-complex-from-real-imag
(equ? (make-complex-from-real-imag (make-integer 8) (make-integer 0)) (make-complex-from-real-imag (make-real 8) (make-real 0)))

(real-part '(rectangular 8 0))
(drop (make-complex-from-real-imag 8 0))
(drop 64)
(drop (drop (make-complex-from-real-imag 8 0)))
(drop (drop (drop (make-complex-from-real-imag 8 0))))

(drop (make-complex-from-real-imag 8.5 0))
(drop (drop (make-complex-from-real-imag 8.5 0)))
(drop (drop (drop (make-complex-from-real-imag 8.5 0)))) ;; This should still be stuck at rational

(newline)
(display "testing apply generic now")
(newline)
(newline)
(add 2.5 6.4)
(add (make-complex-from-real-imag (make-real 4 ) 4) 3)
(add (make-complex-from-real-imag (make-real 4 ) (make-integer 0 )) (make-complex-from-real-imag (make-rational 7.4314 1) (make-real 0 )))
(add (make-complex-from-real-imag (make-real 4 ) (make-integer 0 )) (make-complex-from-real-imag (make-rational 7.4314 1) (make-real 2.74 )))
(add (make-complex-from-real-imag 4 0) (make-complex-from-real-imag 7 0))
(add (make-rational 8 3) 2)
(add (make-rational 7 3) (make-complex-from-real-imag 4 0))
(add (make-complex-from-real-imag 4 4) (make-rational 7 3))
(add (make-complex-from-real-imag 4 4) 3.7)
(add 3 (make-complex-from-real-imag 4 0))
(add 3.7 (make-complex-from-real-imag 4 4))
(add (make-rational 8 1) (make-complex-from-real-imag 4 4))
(sub (make-complex-from-real-imag 4 0) 4.7)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done

testing project
(real . 8)
(real . 8)
(rational 8 . 1)
(integer . 8)

testing drop, and its limits
#f
#t
#t
8
(integer . 8)
64
(integer . 8)
(integer . 8)
(rational 17.0 . 2.0)
(rational 17.0 . 2.0)
(rational 17.0 . 2.0)

testing apply generic now

8.9
(complex rectangular (integer . 7) . 4)
(rational 4022066310962741.0 . 351843720888320.0)
(complex rectangular (rational 3217653048770193.0 . 281474976710656.0) rational 1542482872374395.0 . 562949953421312.0)
(integer . 11)
(rational 14 . 3)
(rational 19 . 3)
(complex rectangular 19/3 . 4)
(complex rectangular 7.7 . 4)
(integer . 7)
(complex rectangular 7.7 . 4)
(complex rectangular 12 . 4)
(rational -788129934789837.0 . 1125899906842624.0)
#+end_example

Tada! Working as expected.
** Exercise 2.87
*** Prompt
Yeah, SICP decided to add a polynomial data type, and we are now supposed to install the ~=zero?~ dispatch for polynomials. Okay, we can try that.
*** Solution
Firstly, we are going to have to import the polynomial type into our org document so that we could test the implementation.

#+name: 2.87-poly-package
#+begin_src racket :exports code
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p)
    (car p))
  (define (term-list p)
    (cdr p))
  (define (variable? p)
    (symbol? p))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  ;; representation of terms and term lists
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist)
    '())
  (define (first-term term-list)
    (car term-list))
  (define (rest-terms term-list)
    (cdr term-list))
  (define (empty-termlist? term-list)
    (null? term-list))
  (define (make-term order coeff)
    (list order coeff))
  (define (order term)
    (car term))
  (define (coeff term)
    (cadr term))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1) (add-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var: ADD-POLY" (list p1 p2))))
  (define (add-terms L1 L2)
    (cond
      [(empty-termlist? L1) L2]
      [(empty-termlist? L2) L1]
      [else
       (let ([t1 (first-term L1)]
             [t2 (first-term L2)])
         (cond
           [(> (order t1) (order t2)) (adjoin-term t1 (add-terms (rest-terms L1) L2))]
           [(< (order t1) (order t2)) (adjoin-term t2 (add-terms L1 (rest-terms L2)))]
           [else
            (adjoin-term (make-term (order t1) (add (coeff t1) (coeff t2)))
                         (add-terms (rest-terms L1) (rest-terms L2)))]))]))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1) (mul-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var: MUL-POLY" (list p1 p2))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2) (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ([t2 (first-term L)])
          (adjoin-term (make-term (+ (order t1) (order t2)) (mul (coeff t1) (coeff t2)))
                       (mul-term-by-all-terms t1 (rest-terms L))))))
  ;; Might have to do a little modification to do a linear check on empty term-list
  (define (=zero?-poly p) (empty-termlist? (term-list p)))
  ;; interface to rest of the system
  (define (tag p)
    (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial) (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial) (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put '=zero? '(polynomial) =zero?-poly)
  (put 'make 'polynomial (lambda (var terms) (tag (make-poly var terms))))
  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
#+end_src

#+RESULTS: 2.87-poly-package

#+caption: Testing basic polynomial operations.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.85-raise-drop-apply-generic>>
<<2.86-complex-implementation>>
<<2.86-rational-implementation>>
<<2.86-generic-arithmetic>>
<<2.86-integer-type-package>>
<<2.86-real-type-package>>
<<basic-coercions-package>>
<<raise-tower-of-types>>
<<2.84-type-comparison>>
<<functional-interface>>
<<2.86-scheme-implementation>>
<<2.86-drop>>
<<2.83-type-rank>>
<<2.83-default-rank-type>>
<<2.87-poly-package>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-raise)
(install-project)
(install-scheme-number-package)
(install-polynomial-package)

(display "testing polynomial construction")
(newline)
(define test-poly1 (make-polynomial 'x '((3 4) (2 1) (1 4) (0 6))) )
(define test-poly2 (make-polynomial 'x '((3 2) (1 2) (0 8))) )
test-poly1
test-poly2
(define test-poly3 (make-polynomial 'y (list (list 2 test-poly1) (list 1 test-poly2))))
(define test-poly4 (make-polynomial 'y (list (list 2 test-poly2) (list 0 test-poly1))))
(contain? 'polynomial default-ranks)
(add test-poly1 test-poly2)
(mul test-poly1 test-poly2)
(add test-poly3 test-poly4)
(mul test-poly3 test-poly4)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done
done
testing polynomial construction
(polynomial x (3 4) (2 1) (1 4) (0 6))
(polynomial x (3 2) (1 2) (0 8))
#f
(polynomial x (3 6) (2 1) (1 6) (0 14))
(polynomial x (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))
(polynomial y (2 (polynomial x (3 6) (2 1) (1 6) (0 14))) (1 (polynomial x (3 2) (1 2) (0 8))) (0 (polynomial x (3 4) (2 1) (1 4) (0 6))))
(polynomial y (4 (polynomial x (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))) (3 (polynomial x (6 4) (4 8) (3 32) (2 4) (1 32) (0 64))) (2 (polynomial x (6 16) (5 8) (4 33) (3 56) (2 28) (1 48) (0 36))) (1 (polynomial x (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))))
#+end_example

Yep, this is real and working. Only current downside is that it is unergonomic to construct the term-list objects that are required for constructing a polynomial.
** Exercise 2.88
*** Prompt
Extend the polynomial system so that we could subtract. Prompt is also suggesting that a generic negate procedure might be helpful.
*** Solution
:LOGBOOK:
CLOCK: [2025-02-23 Sun 09:19]--[2025-02-23 Sun 10:09] =>  0:50
:END:
We can start with the negation. We are really at the stage where we are considering making a dedicated file for each of the exercises, as there are so much code modification. Now we are adding negation to our system

#+caption: Adding a generic negation procedure
#+name: 2.88-generic-arithmetic
#+begin_src racket :exports code
(define (add x y)
  (apply-generic 'add x y))
(define (sub x y)
  (apply-generic 'sub x y))
(define (mul x y)
  (apply-generic 'mul x y))
(define (div x y)
  (apply-generic 'div x y))
(define (neg x)
  (apply-generic 'neg x))
(define (equ? x y)
  (apply-generic 'equ? x y))
(define (exp x y)
  (apply-generic 'exp x y))
(define (squrt x)
  (apply-generic 'squrt x))
(define (cosine x)
  (apply-generic 'cosine x))
(define (sine x)
  (apply-generic 'sine x))
(define (arctan x)
  (div (cosine x) (sine x)))
(define (square x)
  (mul x x))
(define (=zero? x)
  (apply-generic '=zero? x))
#+end_src

#+name: 2.88-real-type-package
#+begin_src racket :exports code
(define (install-real-package)
  ;; internal procedures
  (define (make-real n)
    (cond
      [(number? n) n]
      [else (error "bad argument: MAKE-REAL" n)]))
  (define (add-real x y)
    (make-real (+ x y)))
  (define (sub-real x y)
    (make-real (- x y)))
  (define (mul-real x y)
    (make-real (* x y)))
  (define (div-real x y)
    (make-real (* x y)))
  (define (squrt-real x)
    (make-real (sqrt x)))
  (define (cosine-real x)
    (make-real (cos x)))
  (define (sine-real x)
    (make-real (sin x)))
  (define (neg-real x)
    (make-real (- 0 x)))
  (define (equ? x y)
    (= x y))
  (define (=zero? x)
    (= x 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'real x))
  (put 'add '(real real) (lambda (x y) (tag (add-real x y))))
  (put 'sub '(real real) (lambda (x y) (tag (sub-real x y))))
  (put 'mul '(real real) (lambda (x y) (tag (mul-real x y))))
  (put 'div '(real real) (lambda (x y) (tag (div-real x y))))
  (put '=zero? '(real) =zero?)
  (put 'neg '(real) (lambda (x) (tag (neg-real x))))
  (put 'equ? '(real real) equ?)
  (put 'squrt '(real) (lambda (x) (tag (squrt-real x))))
  (put 'cosine '(real) (lambda (x) (tag (cosine-real x))))
  (put 'sine '(real) (lambda (x) (tag (sine-real x))))
  (put 'make 'real (lambda (n) (tag (make-real n))))
  'done)
(define (make-real n)
  ((get 'make 'real) n))
#+end_src

#+name: 2.88-rational-implementation
#+begin_src racket :exports code
(define (install-rational-package)
  ;; internal procedures
  (define (to-scheme-number x)
    (/ (numer x) (denom x)))
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  (define (neg-rat x)
    (make-rat (- 0 (numer x)) (denom x)))
  (define (squrt-rat x)
    (make-rat (sqrt (numer x)) (sqrt (denom x))))
  (define (cosine-rat x)
    (make-rat (cos (to-scheme-number x)) 1))
  (define (sine-rat x)
    (make-rat (sin (to-scheme-number x)) 1))
  (define (equ? x y)
    (and (= (numer x) (numer y)) (= (denom x) (denom y))))
  (define (=zero? x)
    (= (numer x) 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put '=zero? '(rational) =zero?)
  (put 'neg '(rational) (lambda (x) (tag (neg-rat x))))
  (put 'equ? '(rational rational) equ?)
  (put 'squrt '(rational) (lambda (x) (tag (squrt-rat x))))
  (put 'cosine '(rational) (lambda (x) (tag (cosine-rat x))))
  (put 'sine '(rational) (lambda (x) (tag (sine-rat x))))
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  (put 'numer 'rational (lambda (n) (numer n))) ;; numerator and denominator
  (put 'denom 'rational (lambda (n) (denom n)))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (numer x)
  ((get 'numer 'rational) x))
(define (denom x)
  ((get 'denom 'rational) x))
#+end_src

#+name: 2.88-integer-type-package
#+begin_src racket :exports code
(define (install-integer-package)
  ;; internal procedures
  (define (make-int n)
    (cond
      [(integer? n) n]
      [(number? n) (floor n)]
      [else (error "bad argument: MAKE-INT" n)]))
  (define (add-int x y)
    (make-int (+ x y)))
  (define (sub-int x y)
    (make-int (- x y)))
  (define (mul-int x y)
    (make-int (* x y)))
  (define (div-int x y)
    (make-int (* x y)))
  (define (neg-int x)
    (make-int (- 0 x)))
  (define (equ? x y)
    (= x y))
  (define (=zero? x)
    (= x 0))
  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'integer x))
  (put 'add '(integer integer) (lambda (x y) (tag (add-int x y))))
  (put 'sub '(integer integer) (lambda (x y) (tag (sub-int x y))))
  (put 'mul '(integer integer) (lambda (x y) (tag (mul-int x y))))
  (put 'div '(integer integer) (lambda (x y) (tag (div-int x y))))
  (put '=zero? '(integer) =zero?)
  (put 'neg '(integer) (lambda (x) (tag (neg-int x))))
  (put 'equ? '(integer integer) equ?)
  (put 'make 'integer (lambda (n) (tag (make-int n))))
  'done)
(define (make-integer n)
  ((get 'make 'integer) n))
#+end_src

#+name: 2.88-scheme-implementation
#+begin_src racket :exports code
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'exp '(scheme-number scheme-number) (lambda (x y) (tag (expt x y))))
  (put 'equ? '(scheme-number scheme-number) (lambda (x y) (= x y)))
  (put 'squrt '(scheme-number) (lambda (x) (tag (sqrt x))))
  (put 'cosine '(scheme-number) (lambda (x) (tag (cos x))))
  (put 'sine '(scheme-number) (lambda (x) (tag (sin x))))
  (put '=zero? '(scheme-number) (lambda (x) (= x 0)))
  (put 'neg '(scheme-number) (lambda (x) (tag (- 0 x))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
#+end_src

#+name: 2.88-complex-implementation
#+begin_src racket :exports code
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z)
    (car z))
  (define (imag-part z)
    (cdr z))
  (define (make-from-real-imag x y)
    (cons x y))
  (define (magnitude z)
    (squrt (add (square (real-part z)) (square (imag-part z)))))
  (define (angle z)
    (arctan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (mul r (cosine a)) (mul r (sine a))))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z)
    (car z))
  (define (angle z)
    (cdr z))
  (define (make-from-mag-ang r a)
    (cons r a))
  (define (real-part z)
    (mul (magnitude z) (cosine (angle z))))
  (define (imag-part z)
    (mul (magnitude z) (sine (angle z))))
  (define (make-from-real-imag x y)
    (cons (squrt (add (square x) (square y))) (arctan y x)))
  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2)) (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2)) (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2)) (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2)) (sub (angle z1) (angle z2))))
  (define (equ?-complex z1 z2)
    (and (equ? (real-part z1) (real-part z2)) (equ? (imag-part z1) (imag-part z2))))
  (define (=zero?-complex z)
    (equ? (magnitude z) 0))
  (define (neg-complex z)
    (make-from-real-imag (neg (real-part z)) (neg (imag-part z))))
  ;; interface to rest of the system
  (define (tag z)
    (attach-tag 'complex z))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'equ? '(complex complex) equ?-complex)
  (put '=zero? '(complex) =zero?-complex)
  (put 'neg '(complex) (lambda (z) (tag (neg-complex) z)))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
#+end_src

Only thing that we had to do here was define a concrete negate procedure, and then we were able to use a combination of addtion and negation to achieve subtraction, meaning that we do not currently need to have a termlist type implementation for subtraction. This is the power of data abstraction.
#+name: 2.88-poly-package
#+begin_src racket :exports code
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p)
    (car p))
  (define (term-list p)
    (cdr p))
  (define (variable? p)
    (symbol? p))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  ;; representation of terms and term lists
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist)
    '())
  (define (first-term term-list)
    (car term-list))
  (define (rest-terms term-list)
    (cdr term-list))
  (define (empty-termlist? term-list)
    (null? term-list))
  (define (make-term order coeff)
    (list order coeff))
  (define (order term)
    (car term))
  (define (coeff term)
    (cadr term))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1) (add-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var: ADD-POLY" (list p1 p2))))
  (define (add-terms L1 L2)
    (cond
      [(empty-termlist? L1) L2]
      [(empty-termlist? L2) L1]
      [else
       (let ([t1 (first-term L1)]
             [t2 (first-term L2)])
         (cond
           [(> (order t1) (order t2)) (adjoin-term t1 (add-terms (rest-terms L1) L2))]
           [(< (order t1) (order t2)) (adjoin-term t2 (add-terms L1 (rest-terms L2)))]
           [else
            (adjoin-term (make-term (order t1) (add (coeff t1) (coeff t2)))
                         (add-terms (rest-terms L1) (rest-terms L2)))]))]))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1) (mul-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var: MUL-POLY" (list p1 p2))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2) (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ([t2 (first-term L)])
          (adjoin-term (make-term (+ (order t1) (order t2)) (mul (coeff t1) (coeff t2)))
                       (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (sub-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (add-poly p1 (neg-poly p2))
        (error "Polys not in same var: SUB-POLY" (list p1 p2))))
  (define (neg-poly p)
    (make-poly (variable p) (neg-terms (term-list p))))
  (define (neg-terms term-list)
    (if (empty-termlist? term-list)
        (the-empty-termlist)
        (adjoin-term (neg-term (first-term term-list)) (neg-terms (rest-terms term-list)))))
  ;; negates term unit
  (define (neg-term term)
    (make-term (order term) (neg (coeff term))))
  ;; Might have to do a little modification to do a linear check on empty term-list
  (define (=zero?-poly p) (empty-termlist? (term-list p)))
  ;; interface to rest of the system
  (define (tag p)
    (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial) (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial) (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'sub '(polynomial polynomial) (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'neg '(polynomial) (lambda (p) (tag (neg-poly p))))
  (put '=zero? '(polynomial) =zero?-poly)
  (put 'make 'polynomial (lambda (var terms) (tag (make-poly var terms))))
  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
#+end_src

#+caption: Testing the we could subtract polynomials
#+begin_src racket :exports both :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.85-raise-drop-apply-generic>>
<<2.88-complex-implementation>>
<<2.88-rational-implementation>>
<<2.88-generic-arithmetic>>
<<2.88-integer-type-package>>
<<2.88-real-type-package>>
<<basic-coercions-package>>
<<raise-tower-of-types>>
<<2.84-type-comparison>>
<<functional-interface>>
<<2.88-scheme-implementation>>
<<2.86-drop>>
<<2.83-type-rank>>
<<2.83-default-rank-type>>
<<2.88-poly-package>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-raise)
(install-project)
(install-scheme-number-package)
(install-polynomial-package)

(display "testing polynomial construction")
(newline)
(define test-poly1 (make-polynomial 'x '((3 4) (2 1) (1 4) (0 6))) )
(define test-poly2 (make-polynomial 'x '((3 2) (1 2) (0 8))) )
test-poly1
test-poly2
(define test-poly3 (make-polynomial 'y (list (list 2 test-poly1) (list 1 test-poly2))))
(define test-poly4 (make-polynomial 'y (list (list 2 test-poly2) (list 0 test-poly1))))
test-poly3
test-poly4
(contain? 'polynomial default-ranks)
(newline)
(display "testing polynomial combinations")
(newline)
(add test-poly1 test-poly2)
(mul test-poly1 test-poly2)
(sub test-poly1 test-poly2)
(add test-poly3 test-poly4)
(mul test-poly3 test-poly4)
(sub test-poly3 test-poly4)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done
done
testing polynomial construction
(polynomial x (3 4) (2 1) (1 4) (0 6))
(polynomial x (3 2) (1 2) (0 8))
(polynomial y (2 (polynomial x (3 4) (2 1) (1 4) (0 6))) (1 (polynomial x (3 2) (1 2) (0 8))))
(polynomial y (2 (polynomial x (3 2) (1 2) (0 8))) (0 (polynomial x (3 4) (2 1) (1 4) (0 6))))
#f

testing polynomial combinations
(polynomial x (3 6) (2 1) (1 6) (0 14))
(polynomial x (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))
(polynomial x (3 2) (2 1) (1 2) (0 -2))
(polynomial y (2 (polynomial x (3 6) (2 1) (1 6) (0 14))) (1 (polynomial x (3 2) (1 2) (0 8))) (0 (polynomial x (3 4) (2 1) (1 4) (0 6))))
(polynomial y (4 (polynomial x (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))) (3 (polynomial x (6 4) (4 8) (3 32) (2 4) (1 32) (0 64))) (2 (polynomial x (6 16) (5 8) (4 33) (3 56) (2 28) (1 48) (0 36))) (1 (polynomial x (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))))
(polynomial y (2 (polynomial x (3 2) (2 1) (1 2) (0 -2))) (1 (polynomial x (3 2) (1 2) (0 8))) (0 (polynomial x (3 -4) (2 -1) (1 -4) (0 -6))))
#+end_example

Alright, this is neat. We are now able to subtract polynomials from each other.
** Exercise 2.89
*** Prompt
Define the termlist type implementation that is best for dense polynomials.
*** Solution
We are building a different term list concrete implementation that would be more
efficient for dense polynomials. How can we do this? As stated in SICP, it is
just ordering the coefficient by their power. The inefficiency that stopped us
from making the default implementation is that we have to also fill in terms
that are 0 with a 0 in the list representation.

Since I looked a little ahead, I noticed that it would be helpful if we designed the
dense version of the term list as a package.

One of the problem that we are running into is that ~apply-generic~ is stripping off
the type as it is applying the procedure on the argument. By doing this, it actually
makes it so that the coeff procedure and the order procedure break. This is rather
challenging. The current hack we could do is make it so that for those two procedures,
we check if there is a type tag. If not, then treat the input as the type.

#+name: 2.89-term-list
#+begin_src racket :exports code
(define (install-dense-termlist-package)
  (define (the-empty-termlist-dense)
    '())
  (define (place-dense value rest-zeros term-list)
    (cond
      [(= rest-zeros 0) (cons value term-list)]
      [(< rest-zeros 0)
       (error "malformed system, trying to place a value in the middle of term-list: PLACE-DENSE"
              (list value rest-zeros term-list))]
      [else (place-dense value (- rest-zeros 1) (cons 0 term-list))]))
  (define (adjoin-term-dense term term-list)
    (let ([term-coeff (coeff term)])
      (if (=zero? term-coeff)
          term-list
          (place-dense term-coeff (- (order term) (length term-list)) term-list))))
  ;; Private procedure that removes the leading zeros
  (define (remove-leading-zeros term-list)
    (cond
      [(null? term-list) term-list]
      [(=zero? (car term-list)) (remove-leading-zeros (cdr term-list))]
      [else term-list]))
  ;; Additional requirement here is that we don't want to return a term that is
  ;; zero, therefore, we should keep looking for the next one.
  (define (first-term-dense term-list)
    (let ([cleaned-term-list (remove-leading-zeros term-list)])
      (make-term (- (length term-list) 1) (car cleaned-term-list))))
  ;; This method must also discard leading zeros
  (define (rest-terms-dense term-list)
    (let ([cleaned-term-list (remove-leading-zeros term-list)])
      (remove-leading-zeros (cdr cleaned-term-list))))
  ;; We should discard the leading zero terms
  (define (empty-termlist?-dense term-list)
    (null? (remove-leading-zeros term-list)))
  (define (make-from-coeffs coeffs)
    coeffs)
  (define (make-from-terms terms)
    (if (null? terms)
        (the-empty-termlist 'dense-termlist)
        (adjoin-term-dense (car terms) (make-from-terms (cdr terms)))))
  ;; negation function for the dense representation, taking advantage of the
  ;; number representation of the type.
  (define (neg-terms-dense term-list)
    (if (empty-termlist?-dense term-list)
        (the-empty-termlist 'dense-termlist)
        (cons (neg (car term-list)) (neg-terms-dense (rest-terms-dense term-list)))))
  (define (tag x)
    (attach-tag 'dense-termlist x))
  (put 'adjoin-term '(term dense-termlist) (lambda (x y) (tag (adjoin-term-dense x y))))
  (put 'first-term '(dense-termlist) first-term-dense)
  (put 'rest-terms '(dense-termlist) (lambda (x) (tag (rest-terms-dense x))))
  (put 'empty-termlist? '(dense-termlist) empty-termlist?-dense)
  (put 'the-empty-termlist 'dense-termlist (lambda () (tag (the-empty-termlist-dense))))
  (put 'make-from-coeffs 'dense-termlist (lambda (x) (tag (make-from-coeffs x))))
  (put 'make-from-terms 'dense-termlist (lambda (x) (tag (make-from-terms x))))
  (put 'neg '(dense-termlist) (lambda (x) (tag (neg-terms-dense))))
  'done)

;; Forcing the user to pass in a parameter for the type being constructed
(define (the-empty-termlist x)
  (cond
    [(eq? x 'dense-termlist) ((get 'the-empty-termlist 'dense-termlist))]))

(define (install-term-package)
  (define (make-term-aux order coeff)
    (list order coeff))
  (define (order-term term)
    (car term))
  (define (coeff-term term)
    (cadr term))
  ;; negates term unit
  (define (neg-term term)
    (make-term (order-term term) (neg (coeff-term term))))
  (define (tag x)
    (attach-tag 'term x))
  (put 'make 'term (lambda (order coeff) (tag (make-term-aux order coeff))))
  (put 'neg '(term) (lambda (x) (tag (neg-term x))))
  (put 'order '(term) order-term)
  (put 'coeff '(term) coeff-term)
  'done)
(define (make-term order coeff)
  ((get 'make 'term) order coeff))
(define (order term)
  (let ([curr-type (type-tag term)])
    (if (symbol? curr-type)
        (apply-generic 'order term)
        ((get 'order '(term)) term))))
(define (coeff term)
  (let ([curr-type (type-tag term)])
    (if (symbol? curr-type)
        (apply-generic 'coeff term)
        ((get 'coeff '(term)) term))))

;; Need to include add, neg, and mul
(define (install-termlist-package)
  (define (empty-termlist?-termlist term-list)
    (apply-generic 'empty-termlist? term-list))
  (define (make-from-coeffs x)
    ((get 'make-from-coeffs 'dense-termlist) x))
  (define (first-term-termlist term-list)
    (apply-generic 'first-term term-list))
  (define (rest-terms-termlist term-list)
    (apply-generic 'rest-terms term-list))
  (define (adjoin-term term term-list)
    (apply-generic 'adjoin-term term term-list))
  (define (add-terms L1 L2)
    (cond
      [(empty-termlist? L1) L2]
      [(empty-termlist? L2) L1]
      [else
       (let ([t1 (first-term L1)]
             [t2 (first-term L2)])
         (let ([t1-order (order t1)]
               [t2-order (order t2)])
           (cond
             [(> t1-order t2-order) (adjoin-term t1 (add-terms (rest-terms L1) L2))]
             [(< t1-order t2-order) (adjoin-term t2 (add-terms L1 (rest-terms L2)))]
             [else
              (adjoin-term (make-term t1-order (add (coeff t1) (coeff t2)))
                           (add-terms (rest-terms L1) (rest-terms L2)))])))]))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist 'dense-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2) (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist 'dense-termlist)
        (let ([t2 (first-term L)])
          (adjoin-term (make-term (+ (order t1) (order t2)) (mul (coeff t1) (coeff t2)))
                       (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (neg-terms term-list)
    (if (empty-termlist? term-list)
        (the-empty-termlist 'dense-termlist)
        (adjoin-term (neg (first-term term-list)) (neg-terms (rest-terms term-list)))))
  (define (tag x)
    (attach-tag 'termlist x))
  (put 'make-from-coeffs 'termlist (lambda (x) (tag (make-from-coeffs x))))
  (put 'empty-termlist? '(termlist) empty-termlist?-termlist)
  (put 'first-term '(termlist) first-term-termlist)
  (put 'rest-terms '(termlist) (lambda (term-list) (tag (rest-terms-termlist term-list))))
  (put 'add '(termlist termlist) (lambda (t1 t2) (tag (add-terms t1 t2))))
  (put 'mul '(termlist termlist) (lambda (t1 t2) (tag (mul-terms t1 t2))))
  (put 'neg '(termlist) (lambda (x) (tag (neg-terms x))))
  'done)
(define (make-termlist-from-coeffs x)
  ((get 'make-from-coeffs 'termlist) x))
(define (empty-termlist? term-list)
  (apply-generic 'empty-termlist? term-list))
(define (first-term term-list)
  (apply-generic 'first-term term-list))
(define (rest-terms term-list)
  (apply-generic 'rest-terms term-list))
#+end_src

#+name: 2.89-poly-package
#+begin_src racket :exports code
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p)
    (car p))
  (define (term-list p)
    (cdr p))
  (define (variable? p)
    (symbol? p))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1) (add (term-list p1) (term-list p2)))
        (error "Polys not in same var: ADD-POLY" (list p1 p2))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1) (mul (term-list p1) (term-list p2)))
        (error "Polys not in same var: MUL-POLY" (list p1 p2))))
  (define (sub-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (add-poly p1 (neg-poly p2))
        (error "Polys not in same var: SUB-POLY" (list p1 p2))))
  (define (neg-poly p)
    (make-poly (variable p) (neg (term-list p))))
  ;; negates term unit
  (define (neg-term term)
    (make-term (order term) (neg (coeff term))))
  ;; Might have to do a little modification to do a linear check on empty term-list
  (define (=zero?-poly p) (empty-termlist? (term-list p)))
  ;; interface to rest of the system
  (define (tag p)
    (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial) (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial) (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'sub '(polynomial polynomial) (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'neg '(polynomial) (lambda (p) (tag (neg-poly p))))
  (put '=zero? '(polynomial) =zero?-poly)
  (put 'make 'polynomial (lambda (var terms) (tag (make-poly var terms))))
  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
#+end_src

#+name: 2.89-imports
#+begin_src racket :exports code :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.85-raise-drop-apply-generic>>
<<2.88-complex-implementation>>
<<2.88-rational-implementation>>
<<2.88-generic-arithmetic>>
<<2.88-integer-type-package>>
<<2.88-real-type-package>>
<<basic-coercions-package>>
<<raise-tower-of-types>>
<<2.84-type-comparison>>
<<functional-interface>>
<<2.88-scheme-implementation>>
<<2.86-drop>>
<<2.83-type-rank>>
<<2.83-default-rank-type>>
<<2.89-poly-package>>
<<2.89-term-list>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-raise)
(install-project)
(install-scheme-number-package)
(install-polynomial-package)
(install-termlist-package)
(install-term-package)
(install-dense-termlist-package)
#+end_src


#+caption: Testing the termlist interface.
#+begin_src racket :exports both :noweb yes
<<2.89-imports>>

(display "testing dense construction")
(newline)

(define dense-termlist1 (make-termlist-from-coeffs (list 1 2 3)) )
(define dense-termlist2 (make-termlist-from-coeffs (list 4 5 6 7)) )
(define dense-termlist3 (make-termlist-from-coeffs (list 4 0 6 7)) )
(define dense-termlist4 (make-termlist-from-coeffs (list 0 6 7)) )
(define empty-dense-termlist1 (make-termlist-from-coeffs '()))
(define empty-dense-termlist2 (make-termlist-from-coeffs (list 0)))
dense-termlist1
dense-termlist2
dense-termlist2
(empty-termlist? empty-dense-termlist1)
(empty-termlist? empty-dense-termlist2)
(empty-termlist? dense-termlist1)
(neg dense-termlist1)
(neg dense-termlist2)
(first-term dense-termlist1)
(first-term (rest-terms dense-termlist1))
(first-term dense-termlist2)
(first-term dense-termlist4)

(newline)
(display "testing termlist combinations")
(newline)
(add dense-termlist1 dense-termlist2)
(add dense-termlist1 dense-termlist3)
(add dense-termlist1 empty-dense-termlist2)
(mul dense-termlist1 dense-termlist2)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done
done
done
done
done
testing dense construction
(termlist dense-termlist 1 2 3)
(termlist dense-termlist 4 5 6 7)
(termlist dense-termlist 4 5 6 7)
#t
#t
#f
(termlist dense-termlist -1 -2 -3)
(termlist dense-termlist -4 -5 -6 -7)
(term 2 1)
(term 1 2)
(term 3 4)
(term 2 6)

testing termlist combinations
(termlist dense-termlist 4 6 8 10)
(termlist dense-termlist 4 1 8 10)
(termlist dense-termlist 1 2 3)
(termlist dense-termlist 4 13 28 34 32 21)
#+end_example

The result of the test shows that we were able to satisfy the required
termlist implementation that will facilitate our polynomial operations.

#+caption: Testing the we could do the standard operations of a polynomial on the new datatype.
#+begin_src racket :exports both :noweb yes
<<2.89-imports>>

(display "testing dense construction")
(newline)

(make-termlist-from-coeffs (list 1 2 3))

(display "testing polynomial construction")
(newline)
(define test-poly1 (make-polynomial 'x (make-termlist-from-coeffs (list 4 1 4 6))))
(define test-poly2 (make-polynomial 'x (make-termlist-from-coeffs (list 2 0 2 8))))
test-poly1
test-poly2
(define test-poly3 (make-polynomial 'y (make-termlist-from-coeffs (list test-poly1 test-poly2 0))))
(define test-poly4 (make-polynomial 'y (make-termlist-from-coeffs (list test-poly2 0 test-poly1))))
test-poly3
test-poly4
(contain? 'polynomial default-ranks)
(newline)
(display "testing polynomial combinations")
(newline)
(add test-poly1 test-poly2)
(mul test-poly1 test-poly2)
(sub test-poly1 test-poly2)

(newline)
(display "testing polynomial with polynomial coefficient combination")
(newline)
(add test-poly3 test-poly4)
(mul test-poly3 test-poly4)
(sub test-poly3 test-poly4)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done
done
done
done
done
testing dense construction
(termlist dense-termlist 1 2 3)
testing polynomial construction
(polynomial x termlist dense-termlist 4 1 4 6)
(polynomial x termlist dense-termlist 2 0 2 8)
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist 4 1 4 6) (polynomial x termlist dense-termlist 2 0 2 8) 0)
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist 2 0 2 8) 0 (polynomial x termlist dense-termlist 4 1 4 6))
#f

testing polynomial combinations
(polynomial x termlist dense-termlist 6 1 6 14)
(polynomial x termlist dense-termlist 8 2 16 46 16 44 48)
(polynomial x termlist dense-termlist 2 1 2 -2)

testing polynomial with polynomial coefficient combination
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist 6 1 6 14) (polynomial x termlist dense-termlist 2 0 2 8) (polynomial x termlist dense-termlist 4 1 4 6))
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist 8 2 16 46 16 44 48) (polynomial x termlist dense-termlist 4 0 8 32 4 32 64) (polynomial x termlist dense-termlist 16 8 33 56 28 48 36) (polynomial x termlist dense-termlist 8 2 16 46 16 44 48) 0)
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist 2 1 2 -2) (polynomial x termlist dense-termlist 2 0 2 8) (polynomial x termlist dense-termlist -4 -1 -4 -6))
#+end_example

Well, we build a set of relatively basic tests (that does not even do asserts!), and we saw that we were able to do all the previous set of operations from exercise 2.88 on this new package. We put the extra effort in making the dense termlist a package that uses generic procedures. This will come in handy in the next exercise.
** Exercise 2.90
*** Prompt
Suppose we want to have a polynomial system that is efficient for both sparse and dense polynomials. One way to do this is to allow both kinds of term-list representations in our system. The situation is analogous to the complex-number example of Section 2.4, where we allowed both rectangular and polar representations. To do this we must distinguish different types of term lists and make the operations on term lists generic. Redesign the polynomial system to implement this generalization. This is a major effort, not a local change.
*** Solution
:LOGBOOK:
CLOCK: [2025-03-02 Sun 08:17]--[2025-03-02 Sun 08:23] =>  0:06
:END:
We were slightly ahead of this exercise in that we already refactored the system into packages. Now lets modify what we had so that it satisfies the requirements set by this exercise.

All we have to do in this section is to build another termlist package that uses the old termlist representation instead of the dense one.

There are a lot of things to do here, so let's make a checklist of tasks:
- [X] Test both construction methods of the sparse implementation
- [X] Test the three supported operations
- [X] Test combination using different termlist representations
- [X] Test the construction of polynomials
- [X] Test the operations on the polynomials
  - [X] Sub is failing, we need to debug why
- [X] Test combination of different polynomials with different internal representations
#+name: 2.90-term-list-concrete
#+begin_src racket :exports code
(define (install-dense-termlist-package)
  (define (the-empty-termlist-dense)
    '())
  (define (place-dense value rest-zeros term-list)
    (cond
      [(= rest-zeros 0) (cons value term-list)]
      [(< rest-zeros 0)
       (error "malformed system, trying to place a value in the middle of term-list: PLACE-DENSE"
              (list value rest-zeros term-list))]
      [else (place-dense value (- rest-zeros 1) (cons 0 term-list))]))
  (define (adjoin-term-dense term term-list)
    (let ([term-coeff (coeff term)])
      (if (=zero? term-coeff)
          term-list
          (place-dense term-coeff (- (order term) (length term-list)) term-list))))
  ;; Private procedure that removes the leading zeros
  (define (remove-leading-zeros term-list)
    (cond
      [(null? term-list) term-list]
      [(=zero? (car term-list)) (remove-leading-zeros (cdr term-list))]
      [else term-list]))
  ;; Additional requirement here is that we don't want to return a term that is
  ;; zero, therefore, we should keep looking for the next one.
  (define (first-term-dense term-list)
    (let ([cleaned-term-list (remove-leading-zeros term-list)])
      (make-term (- (length term-list) 1) (car cleaned-term-list))))
  ;; This method must also discard leading zeros
  (define (rest-terms-dense term-list)
    (let ([cleaned-term-list (remove-leading-zeros term-list)])
      (remove-leading-zeros (cdr cleaned-term-list))))
  ;; We should discard the leading zero terms
  (define (empty-termlist?-dense term-list)
    (null? (remove-leading-zeros term-list)))
  (define (make-from-coeffs coeffs)
    coeffs)
  (define (make-from-terms terms)
    (if (null? terms)
        (the-empty-termlist 'dense-termlist)
        (adjoin-term-dense (car terms) (make-from-terms (cdr terms)))))
  ;; negation function for the dense representation, taking advantage of the
  ;; number representation of the type.
  (define (neg-terms-dense term-list)
    (if (null? term-list)
        (the-empty-termlist-dense)
        (cons (neg (car term-list)) (neg-terms-dense (cdr term-list)))))
  (define (tag x)
    (attach-tag 'dense-termlist x))
  (put 'adjoin-term '(term dense-termlist) (lambda (x y) (tag (adjoin-term-dense x y))))
  (put 'first-term '(dense-termlist) first-term-dense)
  (put 'rest-terms '(dense-termlist) (lambda (x) (tag (rest-terms-dense x))))
  (put 'empty-termlist? '(dense-termlist) empty-termlist?-dense)
  (put 'the-empty-termlist 'dense-termlist (lambda () (tag (the-empty-termlist-dense))))
  (put 'make-from-coeffs 'dense-termlist (lambda (x) (tag (make-from-coeffs x))))
  (put 'make-from-terms 'dense-termlist (lambda (x) (tag (make-from-terms x))))
  (put 'neg '(dense-termlist) (lambda (x) (tag (neg-terms-dense x))))
  'done)

(define (install-sparse-termlist-package)
  (define (make-internal-term order coeff)
    (list order coeff))
  (define (internal-order internal-term)
    (car internal-term))
  (define (internal-coeff internal-term)
    (cadr internal-term))
  (define (the-empty-termlist-sparse)
    '())
  ;; This procedure is registered as a generic procedure, therefore, it acts
  ;; upon the parameters as if they do not have a type tag.
  (define (adjoin-term-sparse term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  ;; want to tag this as a term again
  (define (first-term-sparse term-list)
    (let ([front-term (car term-list)]) (make-term (internal-order front-term) (internal-coeff front-term))))
  ;; This method must also discard leading zeros
  (define (rest-terms-sparse term-list)
    (cdr term-list))
  ;; We should discard the leading zero terms
  (define (empty-termlist?-sparse term-list)
    (null? term-list))
  (define (make-from-coeffs coeffs)
    (let ([res (right-fold (lambda (acc ele)
                             (let ([curr-power (car acc)]
                                   [built-acc (cdr acc)])
                               (cons (+ curr-power 1)
                                     (adjoin-term-sparse (make-internal-term curr-power ele) built-acc))))
                           (cons 0 (the-empty-termlist-sparse))
                           coeffs)])
      (cdr res)))
  (define (make-from-terms terms)
    (map contents (filter (lambda (x) (not (=zero? x))) terms)))
  ;; Internal procedure that acts is not aware of type tags
  (define (head-sparse term-list)
    (car term-list))
  ;; negation function for the dense representation, taking advantage of the
  ;; number representation of the type.
  (define (neg-terms-sparse term-list)
    (if (empty-termlist?-sparse term-list)
        (the-empty-termlist-sparse)
        (let ([curr-term (first-term-sparse term-list)])
          (adjoin-term-sparse (contents (neg curr-term)) (neg-terms-sparse (rest-terms-sparse term-list))))))
  (define (tag x)
    (attach-tag 'sparse-termlist x))
  (put 'adjoin-term '(term sparse-termlist) (lambda (x y) (tag (adjoin-term-sparse x y))))
  (put 'first-term '(sparse-termlist) first-term-sparse)
  (put 'rest-terms '(sparse-termlist) (lambda (x) (tag (rest-terms-sparse x))))
  (put 'empty-termlist? '(sparse-termlist) empty-termlist?-sparse)
  (put 'the-empty-termlist 'sparse-termlist (lambda () (tag (the-empty-termlist-sparse))))
  (put 'make-from-coeffs 'sparse-termlist (lambda (x) (tag (make-from-coeffs x))))
  (put 'make-from-terms 'sparse-termlist (lambda (x) (tag (make-from-terms x))))
  (put 'neg '(sparse-termlist) (lambda (x) (tag (neg-terms-sparse x))))
  'done)
#+end_src

#+name: 2.90-term
#+begin_src racket :exports code
(define (install-term-package)
  (define (make-term-aux order coeff)
    (list order coeff))
  (define (order-term term)
    (car term))
  (define (coeff-term term)
    (cadr term))
  ;; negates term unit
  (define (neg-term term)
    (make-term-aux (order-term term) (neg (coeff-term term))))
  (define (tag x)
    (attach-tag 'term x))
  (define (=zero?-term x)
    (=zero? (coeff-term x)))
  (put 'make 'term (lambda (order coeff) (tag (make-term-aux order coeff))))
  (put 'neg '(term) (lambda (x) (tag (neg-term x))))
  (put 'order '(term) order-term)
  (put 'coeff '(term) coeff-term)
  (put '=zero? '(term) =zero?-term)
  'done)
(define (make-term order coeff)
  ((get 'make 'term) order coeff))
(define (order term)
  (let ([curr-type (type-tag term)])
    (if (symbol? curr-type)
        (apply-generic 'order term)
        ((get 'order '(term)) term))))
(define (coeff term)
  (let ([curr-type (type-tag term)])
    (if (symbol? curr-type)
        (apply-generic 'coeff term)
        ((get 'coeff '(term)) term))))

#+end_src


#+name: 2.90-term-list
#+begin_src racket :exports code
;; Need to include add, neg, and mul
;; This is the higher level of abstraction for the data type, responsible for
;; combinations
(define (install-termlist-package)
  (define (empty-termlist?-termlist term-list)
    (apply-generic 'empty-termlist? term-list))
  (define (make-from-coeffs x)
    ((get 'make-from-coeffs 'dense-termlist) x))
  (define (make-from-terms x)
    ((get 'make-from-terms 'sparse-termlist) x))
  (define (first-term-termlist term-list)
    (apply-generic 'first-term term-list))
  (define (rest-terms-termlist term-list)
    (apply-generic 'rest-terms term-list))
  (define (adjoin-term term term-list)
    (apply-generic 'adjoin-term term term-list))
  (define (add-terms L1 L2)
    (cond
      [(empty-termlist? L1) L2]
      [(empty-termlist? L2) L1]
      [else
       (let ([t1 (first-term L1)]
             [t2 (first-term L2)])
         (let ([t1-order (order t1)]
               [t2-order (order t2)])
           (cond
             [(> t1-order t2-order) (adjoin-term t1 (add-terms (rest-terms L1) L2))]
             [(< t1-order t2-order) (adjoin-term t2 (add-terms L1 (rest-terms L2)))]
             [else
              (adjoin-term (make-term t1-order (add (coeff t1) (coeff t2)))
                           (add-terms (rest-terms L1) (rest-terms L2)))])))]))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist 'sparse-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2) (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist 'sparse-termlist)
        (let ([t2 (first-term L)])
          (adjoin-term (make-term (+ (order t1) (order t2)) (mul (coeff t1) (coeff t2)))
                       (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (neg-terms term-list)
    (neg term-list))
  (define (tag x)
    (attach-tag 'termlist x))
  (put 'make-from-coeffs 'termlist (lambda (x) (tag (make-from-coeffs x))))
  (put 'make-from-terms 'termlist (lambda (x) (tag (make-from-terms x))))
  (put 'empty-termlist? '(termlist) empty-termlist?-termlist)
  (put 'first-term '(termlist) first-term-termlist)
  (put 'rest-terms '(termlist) (lambda (term-list) (tag (rest-terms-termlist term-list))))
  (put 'add '(termlist termlist) (lambda (t1 t2) (tag (add-terms t1 t2))))
  (put 'mul '(termlist termlist) (lambda (t1 t2) (tag (mul-terms t1 t2))))
  (put 'neg '(termlist) (lambda (x) (tag (neg-terms x))))
  'done)

;; Forcing the user to pass in a parameter for the type being constructed
(define (the-empty-termlist x)
  ((get 'the-empty-termlist x)))

;; constructor that operates on a list of integers, where the position in the
;; gives order information, and the elements of the list are the coefficients.
(define (make-termlist-from-coeffs x)
  ((get 'make-from-coeffs 'termlist) x))
;; Constructor that operates on list of term objects.
(define (make-termlist-from-terms x)
  ((get 'make-from-terms 'termlist) x))
(define (empty-termlist? term-list)
  (apply-generic 'empty-termlist? term-list))
(define (first-term term-list)
  (apply-generic 'first-term term-list))
(define (rest-terms term-list)
  (apply-generic 'rest-terms term-list))
#+end_src


#+name: 2.90-imports
#+begin_src racket :exports code :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.85-raise-drop-apply-generic>>
<<2.88-complex-implementation>>
<<2.88-rational-implementation>>
<<2.88-generic-arithmetic>>
<<2.88-integer-type-package>>
<<2.88-real-type-package>>
<<basic-coercions-package>>
<<raise-tower-of-types>>
<<2.84-type-comparison>>
<<functional-interface>>
<<2.88-scheme-implementation>>
<<2.86-drop>>
<<2.83-type-rank>>
<<2.83-default-rank-type>>
<<2.89-poly-package>>
<<2.90-term-list>>
<<2.90-term-list-concrete>>
<<2.90-term>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-raise)
(install-project)
(install-scheme-number-package)
(install-polynomial-package)
(install-termlist-package)
(install-term-package)
(install-dense-termlist-package)
(install-sparse-termlist-package)

(define (display-hline-=)
  (display "=========================================")
  (newline))
(define (display-hline--)
  (display "-----------------------------------------")
  (newline))
#+end_src


#+caption: Testing the termlist interface.
#+begin_src racket :exports both :noweb yes
<<2.90-imports>>

(newline)
(display "testing dense construction")
(newline)
(display-hline-=)

(define dense-termlist1 (make-termlist-from-coeffs (list 1 2 3)))
(define dense-termlist2 (make-termlist-from-coeffs (list 4 5 6 7)))
(define dense-termlist3 (make-termlist-from-coeffs (list 4 0 6 7)))
(define dense-termlist4 (make-termlist-from-coeffs (list 0 6 7)))
(define empty-dense-termlist1 (make-termlist-from-coeffs '()))
(define empty-dense-termlist2 (make-termlist-from-coeffs (list 0)))
(display "dense termlist 1-4")
(newline)
(display-hline--)
dense-termlist1
dense-termlist2
dense-termlist3
dense-termlist4
empty-dense-termlist1
empty-dense-termlist2

(newline)
(display "testing misc procedures on dense termlists")
(newline)
(display-hline-=)
(empty-termlist? empty-dense-termlist1)
(empty-termlist? empty-dense-termlist2)
(empty-termlist? dense-termlist1)
(display "testing dense negation")
(newline)
(display-hline--)
(neg dense-termlist1)
(neg dense-termlist2)
(neg dense-termlist3)
(neg dense-termlist4)
(first-term dense-termlist1)
(first-term (rest-terms dense-termlist1))
(first-term dense-termlist2)
(first-term dense-termlist4)

(newline)
(display "testing dense termlist combinations")
(newline)
(display-hline-=)
(add dense-termlist1 dense-termlist2)
(add dense-termlist1 dense-termlist3)
(add dense-termlist1 empty-dense-termlist2)
(mul dense-termlist1 dense-termlist2)

(newline)
(display "testing sparse construction")
(newline)
(display-hline-=)

(define sparse-termlist1
  (make-termlist-from-terms (list (make-term 2 1) (make-term 1 2) (make-term 0 3))))
(define sparse-termlist2
  (make-termlist-from-terms (list (make-term 3 4) (make-term 2 5) (make-term 1 6) (make-term 0 7))))
(define sparse-termlist3
  (make-termlist-from-terms (list (make-term 3 4) (make-term 1 6) (make-term 0 7))))
(define sparse-termlist4
  (make-termlist-from-terms (list (make-term 2 0) (make-term 1 6) (make-term 0 7))))
(define empty-sparse-termlist1 (make-termlist-from-terms '()))
(define empty-sparse-termlist2 (make-termlist-from-terms (list (make-term 0 0))))
(display "sparse termlist 1-4")
(newline)
(display-hline--)
sparse-termlist1
sparse-termlist2
sparse-termlist3
sparse-termlist4
empty-sparse-termlist1
empty-sparse-termlist2

(newline)
(display "testing misc procedures on sparse termlists")
(newline)
(display-hline-=)
(empty-termlist? empty-sparse-termlist1)
(display "The following should be true: ")
(newline)
(empty-termlist? empty-sparse-termlist2)
(display "The following should be false: ")
(newline)
(empty-termlist? sparse-termlist1)
(display "testing sparse negation")
(newline)
(display-hline--)
(neg sparse-termlist1)
(neg sparse-termlist2)
(display "testing sparse first term")
(newline)
(first-term sparse-termlist1)
(first-term (rest-terms sparse-termlist1))
(first-term sparse-termlist2)
(first-term sparse-termlist4)

(newline)
(display "testing sparse termlist combinations")
(newline)
(display-hline-=)
(add sparse-termlist1 sparse-termlist2)
(add sparse-termlist1 sparse-termlist3)
(add sparse-termlist1 empty-sparse-termlist2)
(mul sparse-termlist1 sparse-termlist2)

(newline)
(display "testing sparse and dense combinations")
(newline)
(display-hline-=)
(add dense-termlist1 sparse-termlist2)
(add sparse-termlist1 dense-termlist3)
(add sparse-termlist1 empty-dense-termlist2)
(add dense-termlist1 empty-sparse-termlist2)
(mul sparse-termlist1 dense-termlist2)
(mul dense-termlist1 sparse-termlist2)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done
done
done
done
done
done

testing dense construction
=========================================
dense termlist 1-4
-----------------------------------------
(termlist dense-termlist 1 2 3)
(termlist dense-termlist 4 5 6 7)
(termlist dense-termlist 4 0 6 7)
(termlist dense-termlist 0 6 7)
(termlist dense-termlist)
(termlist dense-termlist 0)

testing misc procedures on dense termlists
=========================================
#t
#t
#f
testing dense negation
-----------------------------------------
(termlist dense-termlist -1 -2 -3)
(termlist dense-termlist -4 -5 -6 -7)
(termlist dense-termlist -4 0 -6 -7)
(termlist dense-termlist 0 -6 -7)
(term 2 1)
(term 1 2)
(term 3 4)
(term 2 6)

testing dense termlist combinations
=========================================
(termlist dense-termlist 4 6 8 10)
(termlist dense-termlist 4 1 8 10)
(termlist dense-termlist 1 2 3)
(termlist sparse-termlist (5 4) (4 13) (3 28) (2 34) (1 32) (0 21))

testing sparse construction
=========================================
sparse termlist 1-4
-----------------------------------------
(termlist sparse-termlist (2 1) (1 2) (0 3))
(termlist sparse-termlist (3 4) (2 5) (1 6) (0 7))
(termlist sparse-termlist (3 4) (1 6) (0 7))
(termlist sparse-termlist (1 6) (0 7))
(termlist sparse-termlist)
(termlist sparse-termlist)

testing misc procedures on sparse termlists
=========================================
#t
The following should be true:
#t
The following should be false:
#f
testing sparse negation
-----------------------------------------
(termlist sparse-termlist (2 -1) (1 -2) (0 -3))
(termlist sparse-termlist (3 -4) (2 -5) (1 -6) (0 -7))
testing sparse first term
(term 2 1)
(term 1 2)
(term 3 4)
(term 1 6)

testing sparse termlist combinations
=========================================
(termlist sparse-termlist (3 4) (2 6) (1 8) (0 10))
(termlist sparse-termlist (3 4) (2 1) (1 8) (0 10))
(termlist sparse-termlist (2 1) (1 2) (0 3))
(termlist sparse-termlist (5 4) (4 13) (3 28) (2 34) (1 32) (0 21))

testing sparse and dense combinations
=========================================
(termlist sparse-termlist (3 4) (2 6) (1 8) (0 10))
(termlist dense-termlist 4 1 8 10)
(termlist sparse-termlist (2 1) (1 2) (0 3))
(termlist dense-termlist 1 2 3)
(termlist sparse-termlist (5 4) (4 13) (3 28) (2 34) (1 32) (0 21))
(termlist sparse-termlist (5 4) (4 13) (3 28) (2 34) (1 32) (0 21))
#+end_example

#+caption: Testing the we could do the standard operations of a polynomial on the new datatype.
#+begin_src racket :exports both :noweb yes
<<2.90-imports>>

(display "testing dense construction")
(newline)
(display "===========================================")
(newline)

(make-termlist-from-coeffs (list 1 2 3))

(newline)
(display "testing polynomial construction")
(newline)
(display "===========================================")
(newline)
(define test-poly1 (make-polynomial 'x (make-termlist-from-coeffs (list 4 1 4 6))))
(define test-poly2 (make-polynomial 'x (make-termlist-from-terms (list (make-term 3 2) (make-term 1 2) (make-term 0 8)))))
test-poly1
test-poly2
(define test-poly3 (make-polynomial 'y (make-termlist-from-coeffs (list test-poly1 test-poly2 0))))
(define test-poly4 (make-polynomial 'y (make-termlist-from-coeffs (list test-poly2 0 test-poly1))))
test-poly3
test-poly4
(contain? 'polynomial default-ranks)
(newline)
(display "testing polynomial combinations")
(newline)
(display "===========================================")
(newline)
(add test-poly1 test-poly2)
(add test-poly2 test-poly1)
(mul test-poly1 test-poly2)
(mul test-poly2 test-poly1)
(sub test-poly1 test-poly2)
(sub test-poly2 test-poly1)

(newline)
(display "testing polynomial with polynomial coefficient combination")
(newline)
(add test-poly3 test-poly4)
(mul test-poly3 test-poly4)
(display "subtraction")
(newline)
(display-hline--)
(sub test-poly3 test-poly4)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done
done
done
done
done
done
testing dense construction
===========================================
(termlist dense-termlist 1 2 3)

testing polynomial construction
===========================================
(polynomial x termlist dense-termlist 4 1 4 6)
(polynomial x termlist sparse-termlist (3 2) (1 2) (0 8))
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist 4 1 4 6) (polynomial x termlist sparse-termlist (3 2) (1 2) (0 8)) 0)
(polynomial y termlist dense-termlist (polynomial x termlist sparse-termlist (3 2) (1 2) (0 8)) 0 (polynomial x termlist dense-termlist 4 1 4 6))
#f

testing polynomial combinations
===========================================
(polynomial x termlist sparse-termlist (3 6) (2 1) (1 6) (0 14))
(polynomial x termlist dense-termlist 6 1 6 14)
(polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))
(polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))
(polynomial x termlist sparse-termlist (3 2) (2 1) (1 2) (0 -2))
(polynomial x termlist dense-termlist -2 -1 -2 2)

testing polynomial with polynomial coefficient combination
(polynomial y termlist dense-termlist (polynomial x termlist sparse-termlist (3 6) (2 1) (1 6) (0 14)) (polynomial x termlist sparse-termlist (3 2) (1 2) (0 8)) (polynomial x termlist dense-termlist 4 1 4 6))
(polynomial y termlist sparse-termlist (4 (polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))) (3 (polynomial x termlist sparse-termlist (6 4) (4 8) (3 32) (2 4) (1 32) (0 64))) (2 (polynomial x termlist sparse-termlist (6 16) (5 8) (4 33) (3 56) (2 28) (1 48) (0 36))) (1 (polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))))
subtraction
-----------------------------------------
(polynomial y termlist dense-termlist (polynomial x termlist sparse-termlist (3 2) (2 1) (1 2) (0 -2)) (polynomial x termlist sparse-termlist (3 2) (1 2) (0 8)) (polynomial x termlist dense-termlist -4 -1 -4 -6))
#+end_example

And with these ad hoc testing, have reasonable certainty that our system is now working as designed. There were further optimizations that could have been applied, such as making a termlist specific implementation for both addition and multiplication, but for the sake of timeline, those additional implementations were not done.
** Exercise 2.91
*** Prompt
:LOGBOOK:
CLOCK: [2025-03-02 Sun 09:24]--[2025-03-02 Sun 10:14] =>  0:50
:END:
A univariate polynomial can be divided by another one to produce a polynomial quotient and a polynomial remainder. for example,

$\frac{x^5 - 1}{x^2 - 1} = x^3 + x,~ \text{remainder}~x - 1$

Division can be done through long division. That is, divide the highest-order term of the dividend by the highest-order term of the divisor. The result of the first term of the quotient. Next, multiply the result by the divisor, subtract that from the dividend, and produce the rest of the answer by recursively dividing the difference by the divisor. Stop when the order of the divisor exceeds the order of the dividend and declare the dividend to be the remainder. Also, if the dividend ever becomes zero, return zero as both quotient and remainder.

We can design a ~div-poly~ procedure on the model of ~add-poly~ and ~mul-poly~. The procedure checks to see if the two polys have the same variable. If so, ~div-poly~ strips off the variable and passes the problem to ~div-terms~, which performs the division operation on term lists. ~div-poly~ finally reattaches the variable to the result supplied by ~div-terms~. It is convenient to design ~div-terms~ to compute both the quotient and the remainder of a division. ~div-terms~ can take two term lists as arguments and return a list of the quotient term list and the remainder termlist.

Complete the following definition of ~div-terms~ by filling in the missing expressions. Use this to implement ~div-poly~, which takes two polys as arguments and returns a list of the quotient and remainder polys.

#+begin_src racket :exports code
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ([t1 (first-term L1)]
            [t2 (first-term L2)])
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ([new-c (div (coeff t1) (coeff t2))]
                  [new-o (- (order t1) (order t2))])
              (let ([rest-of-result
                     ;;compute rest of result recursively
                     ])
                ;;form complete result
                ))))))
#+end_src
*** Solution
We first need to import the relevant previous code that needs to be modified. This is specifically the termlist package (not the concrete implementation) and the tests for regression checking.

We are going to implement the termlist division component first.
#+name: 2.91-term-list
#+begin_src racket :exports code
;; Need to include add, neg, and mul
;; This is the higher level of abstraction for the data type, responsible for
;; combinations
(define (install-termlist-package)
  (define (empty-termlist?-termlist term-list)
    (apply-generic 'empty-termlist? term-list))
  (define (make-from-coeffs x)
    ((get 'make-from-coeffs 'dense-termlist) x))
  (define (make-from-terms x)
    ((get 'make-from-terms 'sparse-termlist) x))
  (define (first-term-termlist term-list)
    (first-term term-list))
  (define (rest-terms-termlist term-list)
    (rest-terms term-list))
  (define (adjoin-term-termlist term term-list)
    (let ([term-list-type (type-tag term-list)])
      ((get 'adjoin-term (list 'term term-list-type)) term term-list)))
  (define (add-terms L1 L2)
    (cond
      [(empty-termlist? L1) L2]
      [(empty-termlist? L2) L1]
      [else
       (let ([t1 (first-term L1)]
             [t2 (first-term L2)])
         (let ([t1-order (order t1)]
               [t2-order (order t2)])
           (cond
             [(> t1-order t2-order) (adjoin-term t1 (add-terms (rest-terms L1) L2))]
             [(< t1-order t2-order) (adjoin-term t2 (add-terms L1 (rest-terms L2)))]
             [else
              (adjoin-term (make-term t1-order (add (coeff t1) (coeff t2)))
                           (add-terms (rest-terms L1) (rest-terms L2)))])))]))
  (define (sub-terms L1 L2)
    (add-terms L1 (neg-terms L2)))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist 'sparse-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2) (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist 'sparse-termlist)
        (let ([t2 (first-term L)])
          (adjoin-term (make-term (+ (order t1) (order t2)) (mul (coeff t1) (coeff t2)))
                       (mul-term-by-all-terms t1 (rest-terms L))))))
  ;; Where L1 is the divident, and L2 is the divisor. The first element is the
  ;; quotient, and the second return element is the remainder.
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist 'sparse-termlist) (the-empty-termlist 'sparse-termlist))
        (let ([t1 (first-term L1)]
              [t2 (first-term L2)])
          (if (> (order t2) (order t1))
              (list (the-empty-termlist 'sparse-termlist) L1)
              (let ([new-c (div (coeff t1) (coeff t2))]
                    [new-o (- (order t1) (order t2))])
                (let ([rest-of-result
                       (div-terms
                        (sub-terms L1 (mul-terms L2 (make-from-terms (list (make-term new-o new-c)))))
                        L2)])
                  (list (adjoin-term (make-term new-o new-c) (car rest-of-result))
                        (cadr rest-of-result))))))))
  (define (neg-terms term-list)
    (neg term-list))
  (define (tag x)
    (attach-tag 'termlist x))
  (put 'make-from-coeffs 'termlist (lambda (x) (tag (make-from-coeffs x))))
  (put 'make-from-terms 'termlist (lambda (x) (tag (make-from-terms x))))
  (put 'empty-termlist? '(termlist) empty-termlist?-termlist)
  (put 'first-term '(termlist) first-term-termlist)
  (put 'rest-terms '(termlist) (lambda (term-list) (tag (rest-terms-termlist term-list))))
  (put 'add '(termlist termlist) (lambda (t1 t2) (tag (add-terms t1 t2))))
  (put 'sub '(termlist termlist) (lambda (t1 t2) (tag (sub-terms t1 t2))))
  (put 'mul '(termlist termlist) (lambda (t1 t2) (tag (mul-terms t1 t2))))
  (put 'div
       '(termlist termlist)
       (lambda (t1 t2)
         (let ([div-res (div-terms t1 t2)]) (list (tag (car div-res)) (tag (cadr div-res))))))
  (put 'neg '(termlist) (lambda (x) (tag (neg-terms x))))
  (put 'adjoin-term '(term termlist) (lambda (t tl) (tag (adjoin-term-termlist t tl))))
  'done)

;; Forcing the user to pass in a parameter for the type being constructed
(define (the-empty-termlist x)
  ((get 'the-empty-termlist x)))

;; constructor that operates on a list of integers, where the position in the
;; gives order information, and the elements of the list are the coefficients.
(define (make-termlist-from-coeffs x)
  ((get 'make-from-coeffs 'termlist) x))
;; Constructor that operates on list of term objects.
(define (make-termlist-from-terms x)
  ((get 'make-from-terms 'termlist) x))
(define (empty-termlist? term-list)
  (apply-generic 'empty-termlist? term-list))
(define (first-term term-list)
  (apply-generic 'first-term term-list))
(define (rest-terms term-list)
  (apply-generic 'rest-terms term-list))
(define (adjoin-term term term-list)
  (apply-generic 'adjoin-term term term-list))
#+end_src


In the poly package, our main task is to add the variable check, and if they are the same variable, then apply the termlist level division procedure on it. Following this, we also need to ensure that we properly convert the termlist into a polynomial.
#+name: 2.91-poly-package
#+begin_src racket :exports code
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p)
    (car p))
  (define (term-list p)
    (cdr p))
  (define (variable? p)
    (symbol? p))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (univariant-application proc error-msg p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (proc)
        (error error-msg (list p1 p2))))
  (define (add-poly p1 p2)
    (univariant-application (lambda () (make-poly (variable p1) (add (term-list p1) (term-list p2))))
                            "Polys does not have same var: ADD-POLY"
                            p1
                            p2))
  (define (mul-poly p1 p2)
    (univariant-application (lambda () (make-poly (variable p1) (mul (term-list p1) (term-list p2))))
                            "Polys not in same var: MUL-POLY"
                            p1
                            p2))
  (define (sub-poly p1 p2)
    (univariant-application (lambda () (make-poly (variable p1) (sub (term-list p1) (term-list p2))))
                            "Polys not in same var: SUB-POLY"
                            p1
                            p2))
  ;; Need to unwrap and properly convert the termlist into polynomials
  (define (div-poly p1 p2)
    (univariant-application (lambda ()
                              (let ([div-res (div (term-list p1) (term-list p2))]
                                    [poly-var (variable p1)])
                                (list (make-poly poly-var (car div-res))
                                      (make-poly poly-var (cadr div-res)))))
                            "Polys not in same var: DIV-POLY"
                            p1
                            p2))
  (define (neg-poly p)
    (make-poly (variable p) (neg (term-list p))))
  ;; Might have to do a little modification to do a linear check on empty term-list
  (define (=zero?-poly p)
    (empty-termlist? (term-list p)))
  ;; interface to rest of the system
  (define (tag p)
    (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial) (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial) (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'sub '(polynomial polynomial) (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'div
       '(polynomial polynomial)
       (lambda (p1 p2)
         (let ([div-res (div-poly p1 p2)]) (list (tag (car div-res)) (tag (cadr div-res))))))
  (put 'neg '(polynomial) (lambda (p) (tag (neg-poly p))))
  (put '=zero? '(polynomial) =zero?-poly)
  (put 'make 'polynomial (lambda (var terms) (tag (make-poly var terms))))
  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
#+end_src


#+name: 2.91-imports
#+begin_src racket :exports code :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.85-raise-drop-apply-generic>>
<<2.88-complex-implementation>>
<<2.88-rational-implementation>>
<<2.88-generic-arithmetic>>
<<2.88-integer-type-package>>
<<2.88-real-type-package>>
<<basic-coercions-package>>
<<raise-tower-of-types>>
<<2.84-type-comparison>>
<<functional-interface>>
<<2.88-scheme-implementation>>
<<2.86-drop>>
<<2.83-type-rank>>
<<2.83-default-rank-type>>
<<2.91-poly-package>>
<<2.91-term-list>>
<<2.90-term-list-concrete>>
<<2.90-term>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-raise)
(install-project)
(install-scheme-number-package)
(install-polynomial-package)
(install-termlist-package)
(install-term-package)
(install-dense-termlist-package)
(install-sparse-termlist-package)

(define (display-hline-=)
  (display "=========================================")
  (newline))
(define (display-hline--)
  (display "-----------------------------------------")
  (newline))
#+end_src


#+caption: Testing division on termlists.
#+begin_src racket :exports both :noweb yes
<<2.91-imports>>

(newline)
(display "testing dense construction")
(newline)
(display-hline-=)

(define dense-termlist1 (make-termlist-from-coeffs (list 1 2 3)))
(define dense-termlist2 (make-termlist-from-coeffs (list 4 5 6 7)))
(define dense-termlist3 (make-termlist-from-coeffs (list 4 0 6 7)))
(define dense-termlist4 (make-termlist-from-coeffs (list 0 6 7)))
(define empty-dense-termlist1 (make-termlist-from-coeffs '()))
(define empty-dense-termlist2 (make-termlist-from-coeffs (list 0)))
(display "dense termlist 1-4") (newline) (display-hline--)
dense-termlist1
dense-termlist2
dense-termlist3
dense-termlist4
(display "empty dense termlist 1-2") (newline) (display-hline--)
empty-dense-termlist1
empty-dense-termlist2

(newline)
(display "testing misc procedures on dense termlists")
(newline)
(display-hline-=)
(empty-termlist? empty-dense-termlist1)
(empty-termlist? empty-dense-termlist2)
(empty-termlist? dense-termlist1)
(display "testing dense negation")
(newline)
(display-hline--)
(neg dense-termlist1)
(neg dense-termlist2)
(neg dense-termlist3)
(neg dense-termlist4)
(display "testing dense first term")
(newline)
(display-hline--)
(first-term dense-termlist1)
(first-term (rest-terms dense-termlist1))
(first-term dense-termlist2)
(first-term dense-termlist4)

(newline)
(display "testing dense termlist combinations")
(newline)
(display-hline-=)
(display "testing dense addition")
(newline)
(display-hline--)
(add dense-termlist1 dense-termlist2)
(add dense-termlist1 dense-termlist3)
(add dense-termlist1 empty-dense-termlist2)
(display "testing dense subtraction")
(newline)
(display-hline--)
(sub dense-termlist1 dense-termlist2)
(sub dense-termlist1 dense-termlist3)
(sub dense-termlist1 empty-dense-termlist2)
(display "testing dense multiplication") (newline) (display-hline--)
(mul dense-termlist1 dense-termlist2)
(display "testing dense division") (newline) (display-hline--)
(div dense-termlist1 dense-termlist2)
(div dense-termlist1 dense-termlist3)
(div dense-termlist2 dense-termlist1)
(div dense-termlist3 dense-termlist1)

(newline)
(display "testing sparse construction")
(newline)
(display-hline-=)

(define sparse-termlist1
  (make-termlist-from-terms (list (make-term 2 1) (make-term 1 2) (make-term 0 3))))
(define sparse-termlist2
  (make-termlist-from-terms (list (make-term 3 4) (make-term 2 5) (make-term 1 6) (make-term 0 7))))
(define sparse-termlist3
  (make-termlist-from-terms (list (make-term 3 4) (make-term 1 6) (make-term 0 7))))
(define sparse-termlist4
  (make-termlist-from-terms (list (make-term 2 0) (make-term 1 6) (make-term 0 7))))
(define empty-sparse-termlist1 (make-termlist-from-terms '()))
(define empty-sparse-termlist2 (make-termlist-from-terms (list (make-term 0 0))))
(display "sparse termlist 1-4") (newline) (display-hline--)
sparse-termlist1
sparse-termlist2
sparse-termlist3
sparse-termlist4
(display "empty sparse termlist 1-2") (newline) (display-hline--)
empty-sparse-termlist1
empty-sparse-termlist2

(newline)
(display "testing misc procedures on sparse termlists")
(newline)
(display-hline-=)
(empty-termlist? empty-sparse-termlist1)
(display "The following should be true: ")
(newline)
(empty-termlist? empty-sparse-termlist2)
(display "The following should be false: ")
(newline)
(empty-termlist? sparse-termlist1)
(display "testing sparse negation")
(newline)
(display-hline--)
(neg sparse-termlist1)
(neg sparse-termlist2)
(display "testing sparse first term")
(newline)
(first-term sparse-termlist1)
(first-term (rest-terms sparse-termlist1))
(first-term sparse-termlist2)
(first-term sparse-termlist4)

(newline)
(display "testing sparse termlist combinations")
(newline)
(display-hline-=)
(display "testing sparse addition") (newline) (display-hline--)
(add sparse-termlist1 sparse-termlist2)
(add sparse-termlist1 sparse-termlist3)
(add sparse-termlist1 empty-sparse-termlist2)
(display "testing sparse subtraction") (newline) (display-hline--)
(sub sparse-termlist1 sparse-termlist2)
(sub sparse-termlist1 sparse-termlist3)
(sub sparse-termlist1 empty-sparse-termlist2)
(display "testing sparse multiplication") (newline) (display-hline--)
(mul sparse-termlist1 sparse-termlist2)
(display "testing sparse division") (newline) (display-hline--)
(div sparse-termlist1 sparse-termlist2)
(div sparse-termlist1 sparse-termlist3)
(div sparse-termlist2 sparse-termlist1)
(div sparse-termlist3 sparse-termlist1)

(newline)
(display "testing sparse and dense combinations")
(newline)
(display-hline-=)
(display "testing addition") (newline) (display-hline--)
(add dense-termlist1 sparse-termlist2)
(add sparse-termlist1 dense-termlist3)
(add sparse-termlist1 empty-dense-termlist2)
(add dense-termlist1 empty-sparse-termlist2)
(display "testing multiplication") (newline) (display-hline--)
(mul sparse-termlist1 dense-termlist2)
(mul dense-termlist1 sparse-termlist2)
(display "testing division") (newline) (display-hline--)
(div sparse-termlist2 dense-termlist1)
(div dense-termlist3 sparse-termlist1)
#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done
done
done
done
done
done

testing dense construction
=========================================
dense termlist 1-4
-----------------------------------------
(termlist dense-termlist 1 2 3)
(termlist dense-termlist 4 5 6 7)
(termlist dense-termlist 4 0 6 7)
(termlist dense-termlist 0 6 7)
empty dense termlist 1-2
-----------------------------------------
(termlist dense-termlist)
(termlist dense-termlist 0)

testing misc procedures on dense termlists
=========================================
#t
#t
#f
testing dense negation
-----------------------------------------
(termlist dense-termlist -1 -2 -3)
(termlist dense-termlist -4 -5 -6 -7)
(termlist dense-termlist -4 0 -6 -7)
(termlist dense-termlist 0 -6 -7)
testing dense first term
-----------------------------------------
(term 2 1)
(term 1 2)
(term 3 4)
(term 2 6)

testing dense termlist combinations
=========================================
testing dense addition
-----------------------------------------
(termlist dense-termlist 4 6 8 10)
(termlist dense-termlist 4 1 8 10)
(termlist dense-termlist 1 2 3)
testing dense subtraction
-----------------------------------------
(termlist dense-termlist -4 -4 -4 -4)
(termlist dense-termlist -4 1 -4 -4)
(termlist dense-termlist 1 2 3)
testing dense multiplication
-----------------------------------------
(termlist sparse-termlist (5 4) (4 13) (3 28) (2 34) (1 32) (0 21))
testing dense division
-----------------------------------------
((termlist sparse-termlist) (termlist dense-termlist 1 2 3))
((termlist sparse-termlist) (termlist dense-termlist 1 2 3))
((termlist sparse-termlist (1 4) (0 -3)) (termlist sparse-termlist (0 16)))
((termlist sparse-termlist (1 4) (0 -8)) (termlist sparse-termlist (1 10) (0 31)))

testing sparse construction
=========================================
sparse termlist 1-4
-----------------------------------------
(termlist sparse-termlist (2 1) (1 2) (0 3))
(termlist sparse-termlist (3 4) (2 5) (1 6) (0 7))
(termlist sparse-termlist (3 4) (1 6) (0 7))
(termlist sparse-termlist (1 6) (0 7))
empty sparse termlist 1-2
-----------------------------------------
(termlist sparse-termlist)
(termlist sparse-termlist)

testing misc procedures on sparse termlists
=========================================
#t
The following should be true:
#t
The following should be false:
#f
testing sparse negation
-----------------------------------------
(termlist sparse-termlist (2 -1) (1 -2) (0 -3))
(termlist sparse-termlist (3 -4) (2 -5) (1 -6) (0 -7))
testing sparse first term
(term 2 1)
(term 1 2)
(term 3 4)
(term 1 6)

testing sparse termlist combinations
=========================================
testing sparse addition
-----------------------------------------
(termlist sparse-termlist (3 4) (2 6) (1 8) (0 10))
(termlist sparse-termlist (3 4) (2 1) (1 8) (0 10))
(termlist sparse-termlist (2 1) (1 2) (0 3))
testing sparse subtraction
-----------------------------------------
(termlist sparse-termlist (3 -4) (2 -4) (1 -4) (0 -4))
(termlist sparse-termlist (3 -4) (2 1) (1 -4) (0 -4))
(termlist sparse-termlist (2 1) (1 2) (0 3))
testing sparse multiplication
-----------------------------------------
(termlist sparse-termlist (5 4) (4 13) (3 28) (2 34) (1 32) (0 21))
testing sparse division
-----------------------------------------
((termlist sparse-termlist) (termlist sparse-termlist (2 1) (1 2) (0 3)))
((termlist sparse-termlist) (termlist sparse-termlist (2 1) (1 2) (0 3)))
((termlist sparse-termlist (1 4) (0 -3)) (termlist sparse-termlist (0 16)))
((termlist sparse-termlist (1 4) (0 -8)) (termlist sparse-termlist (1 10) (0 31)))

testing sparse and dense combinations
=========================================
testing addition
-----------------------------------------
(termlist sparse-termlist (3 4) (2 6) (1 8) (0 10))
(termlist dense-termlist 4 1 8 10)
(termlist sparse-termlist (2 1) (1 2) (0 3))
(termlist dense-termlist 1 2 3)
testing multiplication
-----------------------------------------
(termlist sparse-termlist (5 4) (4 13) (3 28) (2 34) (1 32) (0 21))
(termlist sparse-termlist (5 4) (4 13) (3 28) (2 34) (1 32) (0 21))
testing division
-----------------------------------------
((termlist sparse-termlist (1 4) (0 -3)) (termlist sparse-termlist (0 16)))
((termlist sparse-termlist (1 4) (0 -8)) (termlist sparse-termlist (1 10) (0 31)))
#+end_example

#+caption: Testing the we could do univariant division on polynomials.
#+begin_src racket :exports both :noweb yes
<<2.91-imports>>
(newline)
(display "testing polynomial construction")
(newline)
(display-hline-=)
(display "Basic polynomials") (newline)
(display-hline--)
(define test-poly1 (make-polynomial 'x (make-termlist-from-coeffs (list 4 1 4 6))))
(define test-poly2 (make-polynomial 'x (make-termlist-from-terms (list (make-term 3 2) (make-term 1 2) (make-term 0 8)))))
test-poly1
test-poly2
(define test-poly3 (make-polynomial 'y (make-termlist-from-coeffs (list test-poly1 test-poly2 0))))
(define test-poly4 (make-polynomial 'y (make-termlist-from-coeffs (list test-poly2 0 test-poly1))))
test-poly3
test-poly4
(contain? 'polynomial default-ranks)
(newline)
(display "testing polynomial combinations")
(newline)
(display-hline-=)
(add test-poly1 test-poly2)
(add test-poly2 test-poly1)
(mul test-poly1 test-poly2)
(mul test-poly2 test-poly1)
(sub test-poly1 test-poly2)
(sub test-poly2 test-poly1)
(display "testing polynomial division")
(newline)
(display-hline--)
(div test-poly1 test-poly2)
(div test-poly2 test-poly1)

(newline)
(display "testing polynomial with polynomial coefficient combination")
(newline)
(display-hline-=)
(add test-poly3 test-poly4)
(mul test-poly3 test-poly4)
(sub test-poly3 test-poly4)
(add test-poly4 test-poly3)
(mul test-poly4 test-poly3)
(sub test-poly4 test-poly3)
(add test-poly3 test-poly3)
(mul test-poly3 test-poly3)
(sub test-poly3 test-poly3)
(add test-poly4 test-poly4)
(mul test-poly4 test-poly4)
(sub test-poly4 test-poly4)

#+end_src

#+RESULTS:
#+begin_example
done
done
done
done
done
done
done
done
done
done
done
done
done
done

testing polynomial construction
=========================================
Basic polynomials
-----------------------------------------
(polynomial x termlist dense-termlist 4 1 4 6)
(polynomial x termlist sparse-termlist (3 2) (1 2) (0 8))
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist 4 1 4 6) (polynomial x termlist sparse-termlist (3 2) (1 2) (0 8)) 0)
(polynomial y termlist dense-termlist (polynomial x termlist sparse-termlist (3 2) (1 2) (0 8)) 0 (polynomial x termlist dense-termlist 4 1 4 6))
#f

testing polynomial combinations
=========================================
(polynomial x termlist sparse-termlist (3 6) (2 1) (1 6) (0 14))
(polynomial x termlist dense-termlist 6 1 6 14)
(polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))
(polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))
(polynomial x termlist sparse-termlist (3 2) (2 1) (1 2) (0 -2))
(polynomial x termlist dense-termlist -2 -1 -2 2)
testing polynomial division
-----------------------------------------
((polynomial x termlist sparse-termlist (0 2)) (polynomial x termlist sparse-termlist (2 1) (0 -10)))
((polynomial x termlist sparse-termlist (0 1/2)) (polynomial x termlist sparse-termlist (2 -1/2) (0 5)))

testing polynomial with polynomial coefficient combination
=========================================
(polynomial y termlist dense-termlist (polynomial x termlist sparse-termlist (3 6) (2 1) (1 6) (0 14)) (polynomial x termlist sparse-termlist (3 2) (1 2) (0 8)) (polynomial x termlist dense-termlist 4 1 4 6))
(polynomial y termlist sparse-termlist (4 (polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))) (3 (polynomial x termlist sparse-termlist (6 4) (4 8) (3 32) (2 4) (1 32) (0 64))) (2 (polynomial x termlist sparse-termlist (6 16) (5 8) (4 33) (3 56) (2 28) (1 48) (0 36))) (1 (polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))))
(polynomial y termlist dense-termlist (polynomial x termlist sparse-termlist (3 2) (2 1) (1 2) (0 -2)) (polynomial x termlist sparse-termlist (3 2) (1 2) (0 8)) (polynomial x termlist dense-termlist -4 -1 -4 -6))
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist 6 1 6 14) (polynomial x termlist sparse-termlist (3 2) (1 2) (0 8)) (polynomial x termlist dense-termlist 4 1 4 6))
(polynomial y termlist sparse-termlist (4 (polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))) (3 (polynomial x termlist sparse-termlist (6 4) (4 8) (3 32) (2 4) (1 32) (0 64))) (2 (polynomial x termlist sparse-termlist (6 16) (5 8) (4 33) (3 56) (2 28) (1 48) (0 36))) (1 (polynomial x termlist sparse-termlist (6 8) (5 2) (4 16) (3 46) (2 16) (1 44) (0 48))))
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist -2 -1 -2 2) (polynomial x termlist sparse-termlist (3 -2) (1 -2) (0 -8)) (polynomial x termlist dense-termlist 4 1 4 6))
(polynomial y termlist dense-termlist (polynomial x termlist dense-termlist 8 2 8 12) (polynomial x termlist sparse-termlist (3 4) (1 4) (0 16)) 0)
(polynomial y termlist sparse-termlist (4 (polynomial x termlist sparse-termlist (6 16) (5 8) (4 33) (3 56) (2 28) (1 48) (0 36))) (3 (polynomial x termlist sparse-termlist (6 16) (5 4) (4 32) (3 92) (2 32) (1 88) (0 96))) (2 (polynomial x termlist sparse-termlist (6 4) (4 8) (3 32) (2 4) (1 32) (0 64))))
(polynomial y termlist dense-termlist)
(polynomial y termlist dense-termlist (polynomial x termlist sparse-termlist (3 4) (1 4) (0 16)) 0 (polynomial x termlist dense-termlist 8 2 8 12))
(polynomial y termlist sparse-termlist (4 (polynomial x termlist sparse-termlist (6 4) (4 8) (3 32) (2 4) (1 32) (0 64))) (2 (polynomial x termlist sparse-termlist (6 16) (5 4) (4 32) (3 92) (2 32) (1 88) (0 96))) (0 (polynomial x termlist sparse-termlist (6 16) (5 8) (4 33) (3 56) (2 28) (1 48) (0 36))))
(polynomial y termlist dense-termlist)
#+end_example
** Exercise 2.92
*** Prompt
By imposing an ordering on variables, extend the polynomial package so that addition and multiplication of polynomials work for polynomials in different variables. (This is not easy!)
*** Solution
Since this is not easy, it is necessary that I complete the exercise. Due to implementation time consideration, we are going to be coercing the hierarchy of polynomials into their correct ordering eagerly, instead of lazily, due to ease of implementation. For this task, we are going to have to achieve the following.
**** Tasks
- [ ] hash the variables, so that a variable ranking could be generated without the need actually store the tower somewhere. Seems trivial, but vital.
- [ ] find how to do a second order polynomial flip (convert the coefficient polynomials into the principal polynomial)
- [ ] find how to do that recursively
- [ ] make the policy for more malformed compound polynomials (polynomial with variable z only on some terms of a principal polynomial)
**** Design Details
***** Swapping principal variable on second order multivariant polynomial
We should really think about what we will do before we do it, so here is a step by step, so that we could factor this out. We are going to start with a basic example of swapping the principal variable from y to x.

$\left( x - 1 \right) y ^2 + \left( 2x^2 + x \right) y + x^3$

For the polynomial coefficient of each term, we must multiply them by the term to bring the secondary variable to the principal. This could be done on our system by creating a one term polynomial with the order of 0, and the coefficient that is just the term being applied. From here, the previously implemented algorithm for polynomial multiplication would produce the correct output.

$\left( y^2 x - y^2 \right) + \left( 2 y x^2 + y x \right) + x^3$

From here, we now have 3 polynomials that have the same principal variable, and summing them together would generate the final polynomial representation with flipped variables. We simply need to use the implemented algorithm for polynomial addition to produce to final swapped value.

$x^3 + 2y x^2 + \left( y^2 + y \right) x - y^2$

Before continuing, let's describe this algorithm in a more generic way.

To swap the principal of a multivariant polynomial of n terms, we convert each of those terms into a multivariant polynomial of the secondary variable, with the original principal variable as the secondary variable. From here a summation of the n polynomials will result in a swap of the principal variable in the multivariant polynomial.

Now the challenge is extending this to all higher order multivariant polynomials
***** COMMENT Ordering multivariant polynomials
In the previous section, we have shown how to do a single swap of the principal and the secondary variable in a multivariant polynomial. Now, we have to lab the behavior of the polynomial if there are further nested variables. We are going to start with a test multivariant polynomial, which we will describe below.
We are designing this with the assumption that the polynomials are already organized such that every instance of the polynomials have a principal variable.

$\left( z x - z^2 \right) y^2 + \left( 2 z^3 x^2 + \left( z + 2 \right) x \right) y + x^3$

So what we have here is a multivariant polynomial with the principal variable being y, second order variable being x, and the third order variable being z. We want to go over how we could bring y from the principal to the third order variable. At a deeper look, we are going to have to choose the nesting level of the polynomial. Defaulting to swapping the order would be the most flexible, so we will pick that design choice.

$y^2 \left( 1 \right) \left( z x - z^2 \left( 1 \right) \right) + y \left( 1 \right) \left( 2 z ^3 x^2 + (z + 2) x \right) + \left( 1 \right) x^3$

Completing the multiplication, we get the following polynomial, with x as the principal variable, y as the secondary variable, and z as the last.

$\left( z y^2 x - z^2 y^2 \right) + \left( 2 z^3 y x^2 + \left( z + 2 \right) y x \right) + x^3$

We're now going to quickly add up the terms.

$x^3 + 2z^3 y x^2 + \left( z y^2 + \left( z + 2 \right) y \right) x - z^2 y^2$

Finally, to swap y with z.

$x^3 + 2 y z^3 x^2 + (y^2 z + (y z + y 2))x - y ^2 z^2$

$x^3 + 2 y z^3 x^2 + \left( \left( y^2 + y \right) z + y 2 \right) - y^2 z^2$


Doing this action, we noticed that a vital part of the algorithm is the multiplication of a polynomial of y and a polynomial of z must resolve properly. This really just means that given multiplication of two polynomials of different bases, the result must be a polynomial of one base. Although this is analysis, we'll just take a note saying that we could make a procedure that takes two polynomials of different principal variables, and multiplies them such that the principal variable of the output polynomial will be the same values as that of the first parameter. Then we write a procedure that chooses which of the polynomial will be on the left. We are taking advantage of the commutative property of polynomials here. Similarly, we need to addition for polynomials of different bases.



**** Implementation

#+name: 2.91-poly-package
#+begin_src racket :exports code
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p)
    (car p))
  (define (term-list p)
    (cdr p))
  (define (variable? p)
    (symbol? p))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (univariant-application proc error-msg p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (proc)
        (error error-msg (list p1 p2))))
  (define (add-poly p1 p2)
    (univariant-application (lambda () (make-poly (variable p1) (add (term-list p1) (term-list p2))))
                            "Polys does not have same var: ADD-POLY"
                            p1
                            p2))
  (define (mul-poly p1 p2)
    (univariant-application (lambda () (make-poly (variable p1) (mul (term-list p1) (term-list p2))))
                            "Polys not in same var: MUL-POLY"
                            p1
                            p2))
  (define (sub-poly p1 p2)
    (univariant-application (lambda () (make-poly (variable p1) (sub (term-list p1) (term-list p2))))
                            "Polys not in same var: SUB-POLY"
                            p1
                            p2))
  ;; Need to unwrap and properly convert the termlist into polynomials
  (define (div-poly p1 p2)
    (univariant-application (lambda ()
                              (let ([div-res (div (term-list p1) (term-list p2))]
                                    [poly-var (variable p1)])
                                (list (make-poly poly-var (car div-res))
                                      (make-poly poly-var (cadr div-res)))))
                            "Polys not in same var: DIV-POLY"
                            p1
                            p2))
  (define (neg-poly p)
    (make-poly (variable p) (neg (term-list p))))
  ;; Might have to do a little modification to do a linear check on empty term-list
  (define (=zero?-poly p)
    (empty-termlist? (term-list p)))
  ;; interface to rest of the system
  (define (tag p)
    (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial) (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial) (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'sub '(polynomial polynomial) (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'div
       '(polynomial polynomial)
       (lambda (p1 p2)
         (let ([div-res (div-poly p1 p2)]) (list (tag (car div-res)) (tag (cadr div-res))))))
  (put 'neg '(polynomial) (lambda (p) (tag (neg-poly p))))
  (put '=zero? '(polynomial) =zero?-poly)
  (put 'make 'polynomial (lambda (var terms) (tag (make-poly var terms))))
  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
#+end_src

***** Hashing
Thinking about it, we should first come up with a hashing function that could resolve the order of the polynomials. We might be able to hash the symbol by converting it to a string, and then converting that string into an number. We are going to make a not so good hashing function that literally converts the string into an integer, and use that as the hashing value. We need to do this because we want to be able compare the different variables so we don't have to register all the variables in a tower.

Found out that there isn't a bitwise or operation in racket, so I think I have to implement some bitwise operations.

#+name: 2.92-bitwise-operator
#+begin_src racket :exports code
;; Bitshift left
(define (<< val shift-value)
    (define (iter acc remaining-shifts)
      (if (= remaining-shifts 0)
          acc
          (iter (* acc 2) (- remaining-shifts 1))))
    (iter val shift-value))

;; Bitshift right
(define (>> val shift-value)
  (define (iter acc remaining-shifts)
    (if (= remaining-shifts 0)
        acc
        (iter (floor (/ acc 2)) (- remaining-shifts 1))))
  (iter val shift-value))
#+end_src

#+name: 2.92-hash-of-variable
#+begin_src racket :exports code
(define (hash-of-variable variable)
  (define (<< val shift-value)
    (define (iter acc remaining-shifts)
      (if (= remaining-shifts 0)
          acc
          (iter (* acc 2) (- remaining-shifts 1))))
    (iter val shift-value))
  (define (shift-byte val amount)
    (<< val (* amount 8)))
  (define (hash-of-char-list val)
    (define (iter idx acc tail)
      (if (null? tail)
          acc
          (iter (+ 1 idx) (shift-byte (car tail) idx) (cdr tail))))
    (let ([converted-list (map char->integer val)]) (iter 0 0 converted-list)))
  (hash-of-char-list (string->list (symbol->string variable))))
#+end_src

****** Testing

#+caption: Testing bitwise operations
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.92-bitwise-operator>>
<<assertion-suite>>

(display "left shift testing") (newline)
(assert-eq "1 << 0 = 1" (<< 1 0) 1)
(assert-eq "1 << 1 = 2" (<< 1 1) 2)
(assert-eq "1 << 10 = 1024" (<< 1 10) 1024)

(newline)
(display "right shift testing") (newline)
(assert-eq "1 >> 0 = 1" (>> 1 0) 1)
(assert-eq "1 >> 1 = 0" (>> 1 1) 0)
(assert-eq "9 >> 1 = 4" (>> 9 1) 4)
(assert-eq "8 >> 1 = 4" (>> 8 1) 4)
#+end_src

#+RESULTS:
#+begin_example
left shift testing
pass: 1 << 0 = 1 value: 1 expected: 1
pass: 1 << 1 = 2 value: 2 expected: 2
pass: 1 << 10 = 1024 value: 1024 expected: 1024

right shift testing
pass: 1 >> 0 = 1 value: 1 expected: 1
pass: 1 >> 1 = 0 value: 0 expected: 0
pass: 9 >> 1 = 4 value: 4 expected: 4
pass: 8 >> 1 = 4 value: 4 expected: 4
#+end_example

#+caption: Testing the hashing function
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.92-hash-of-variable>>

(hash-of-variable 'x)
(hash-of-variable 'xy)
(hash-of-variable 'xx)
(hash-of-variable 'yx)
#b0101010
#+end_src

#+RESULTS:
: 120
: 30976
: 30720
: 30720
: 42

**** Import

A centralized location for importing the source code. Left visible so readers could trace the code.
#+name: 2.92-imports
#+begin_src racket :exports code :noweb yes
#lang sicp
<<put-get-implementation>>
<<coercion-put-get-implementation>>
<<2.80-tag-system>>
<<2.85-raise-drop-apply-generic>>
<<2.88-complex-implementation>>
<<2.88-rational-implementation>>
<<2.88-generic-arithmetic>>
<<2.88-integer-type-package>>
<<2.88-real-type-package>>
<<basic-coercions-package>>
<<raise-tower-of-types>>
<<2.84-type-comparison>>
<<functional-interface>>
<<2.88-scheme-implementation>>
<<2.86-drop>>
<<2.83-type-rank>>
<<2.83-default-rank-type>>
<<2.91-poly-package>>
<<2.91-term-list>>
<<2.90-term-list-concrete>>
<<2.90-term>>

(install-rational-package)
(install-integer-package)
(install-real-package)
(install-complex-package)
(install-rectangular-package)
(install-polar-package)
(install-raise)
(install-project)
(install-scheme-number-package)
(install-polynomial-package)
(install-termlist-package)
(install-term-package)
(install-dense-termlist-package)
(install-sparse-termlist-package)

(define (display-hline-=)
  (display "=========================================")
  (newline))
(define (display-hline--)
  (display "-----------------------------------------")
  (newline))
#+end_src

**** Testing
***** Regression
