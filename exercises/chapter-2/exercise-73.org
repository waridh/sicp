#+title: Exercise 73
* Prompt
We have just covered dispatches, and now we are working on data-directed style of generic procedures. For this exercise, we will review the symbolic differentiation procedure that was designed in sicp section 2.3.2.

#+caption: Previous version of the symbolic differentiation procedure
#+name: 2.73-old-dispatch
#+begin_src racket :exports code
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [else (error "Unknown expression type: DERIV" exp)]))
#+end_src

We can convert the old version of the symbolic differentiation to the data-directed procedure by doing the following to it.

#+caption: Data-driven implementation of deriv
#+name: 2.73-data-driven
#+begin_src racket :exports code
(define (deriv exp var)
 (cond [(number? exp) 0]
       [(variable? exp) (if (same-variable? exp var) 1 0)]
       [else ((get 'deriv (operator exp)) (operand exp) var)]))

(define (operator exp) (car exp))
(define (operand exp) (cdr exp))
#+end_src

There are now a few questions that must be answered.

a. Explain what was done above, and explain why ~number?~ and ~variable?~ cannot be moved into data-driven dispatch.
b. Write the procedure for derivatives of sums and products, and the auxiliary code required to install them in the table used by the program above.
c. Choose any additional differentiation rule that you like, such as exponents, and install it into this data-directed system.
d. Right now, the type of the expression is the algebraic operator that binds the expression together. What if we index the procedure in the opposite way, such that the dispatch line in the ~deriv~ procedure look like the following. ~((get (operator exp) 'deriv') (operands exp) var)~.
* Solution
** Part a
The data driven solution is to check for the primitives, which are numbers and variables, and if the it was found that the exp is an actual registered expression, then use the data-driven table to lookup the corresponding procedure, and then dispatch it. Lookup process is done with ~deriv~ as the operation, and the expression operator as the type being used in the lookup. Following this, selectors for the data and the operation were defined. ~number?~ and ~variable?~ cannot be moved to the data-driven dispatch because we are dispatching with algebraic expressions as the type. ~variable~ and ~nubmer~ in this representation do not have operators, therefore, lookup cannot occur.
** Part b
Writing an implementation for the sum and product implementation of ~deriv~, we must first setup our test script. We could just reuse a testing script from the ~deriv~ exercises.


#+caption: Test for old version of the ~deriv~ procedure for regression testing.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-old-dispatch>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))

With this value here, we could get to implementing the data-driven dispatch version of the ~deriv~ procedure.

#+name: 2.73-data-driven-sum
#+begin_src racket :exports code
(define (install-data-driven-sum)
  (define (deriv-sum operand var)
    (make-sum (deriv (car operand) var)
              (deriv (cadr operand) var)))
  (put 'deriv '+ deriv-sum))
#+end_src

#+name: 2.73-data-driven-product
#+begin_src racket :exports code
(define (install-data-driven-product)
  (define (deriv-product operand var)
    (make-sum (make-product (car operand) (deriv (cadr operand) var))
              (make-product (deriv (car operand) var) (cadr operand))))
  (put 'deriv '* deriv-product))
#+end_src

Awkward thing we found here is that the racket implementation of ~sicp~ is missing the ~put~ and ~get~ procedure, therefore, we must implement this ourselves.
#+caption: With help from the stack overflow answer provided here: https://stackoverflow.com/questions/5499005/how-do-i-get-the-functions-put-and-get-in-sicp-scheme-exercise-2-78-and-on.
#+name: put-get-implementation
#+begin_src racket :exports code
(define *op-table* '())

(define (make-entry k v) (list k v))
(define (key entry) (car entry))
(define (value entry) (cadr entry))
;; Checks if the entry of the table has a matching parameter key
(define (key? k entry)
  (equal? (key entry) k))

(define (put op type item)
  (define (putter k array)
    (cond [(null? array) (list (make-entry k item))]
          [(key? k (car array)) array]
          [else (cons (car array) (putter k (cdr array)))]))
  (set! *op-table* (putter (list op type) *op-table*)))

(define (get op type)
  (define (getter k array)
    (cond [(null? array) #f]
          [(key? k (car array)) (value (car array))]
          [else (getter k (cdr array))]))
  (getter (list op type) *op-table*))

#+end_src

#+RESULTS: put-get-implementation

#+caption: Test for data-driven version of the ~deriv~ procedure
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-data-driven>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<put-get-implementation>>
<<2.73-data-driven-sum>>
<<2.73-data-driven-product>>

(install-data-driven-sum)
(install-data-driven-product)

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))

This is the expected result, but with one caveat. We had to stop using the selectors for the operands in the old implementation, as those selectors are working with the assumption that there is an operator at the front of the expression. The new interface does not have that.
** Part c
Add the rule back in.

Using data-driven dispatch, this should be easy to do.

#+name: 2.73-data-driven-exponentiation
#+begin_src racket :exports code
(define (install-data-driven-exponentiation)
  (define (deriv-exponentiation operand var)
    (make-product (cadr operand) (make-exponentiation (car operand) (- (cadr operand) 1))))
  (put 'deriv '** deriv-exponentiation))
#+end_src

#+caption: Test for data-driven version of the ~deriv~ procedure with exponentiation.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-data-driven>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<deriv-base-exponentiation>>
<<put-get-implementation>>
<<2.73-data-driven-sum>>
<<2.73-data-driven-product>>
<<2.73-data-driven-exponentiation>>

(install-data-driven-sum)
(install-data-driven-product)
(install-data-driven-exponentiation)

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
(deriv '(+ (* x y) (** x 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))

Result came out as expected.
** Part d
Suppose that we swapped the op and the type, so that the operation is now the operator in the expression and the type is ~'deriv~. What are the changes that are required?

Well, we are now trying to implement ~'deriv~ for the different operations that could be described in an expression. The schema of the table will change, and both the installation and the retrieval of the procedure would change, but otherwise, ~deriv~ itself stays relatively the same. What we could do here is just implement this, and test it.

#+caption: swapped data-driven implementation of deriv
#+name: 2.73-data-driven-swapped
#+begin_src racket :exports code
(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [else ((get (operator exp) 'deriv) (operand exp) var)]))

(define (operator exp)
  (car exp))
(define (operand exp)
  (cdr exp))
#+end_src

#+name: 2.73-data-driven-sum-swapped
#+begin_src racket :exports code
(define (install-data-driven-sum)
  (define (deriv-sum operand var)
    (make-sum (deriv (car operand) var)
              (deriv (cadr operand) var)))
  (put '+ 'deriv deriv-sum))
#+end_src

#+name: 2.73-data-driven-product-swapped
#+begin_src racket :exports code
(define (install-data-driven-product)
  (define (deriv-product operand var)
    (make-sum (make-product (car operand) (deriv (cadr operand) var))
              (make-product (deriv (car operand) var) (cadr operand))))
  (put '* 'deriv deriv-product))
#+end_src

#+name: 2.73-data-driven-exponentiation-swapped
#+begin_src racket :exports code
(define (install-data-driven-exponentiation)
  (define (deriv-exponentiation operand var)
    (make-product (cadr operand) (make-exponentiation (car operand) (- (cadr operand) 1))))
  (put '** 'deriv deriv-exponentiation))
#+end_src

#+caption: Test for swapped operator and type for data-driven version of the ~deriv~ procedure.
#+begin_src racket :exports both :noweb yes
#lang sicp
<<2.73-data-driven-swapped>>
<<deriv-base-dependencies>>
<<deriv-base-sum>>
<<deriv-base-product>>
<<deriv-base-exponentiation>>
<<put-get-implementation>>
<<2.73-data-driven-sum-swapped>>
<<2.73-data-driven-product-swapped>>
<<2.73-data-driven-exponentiation-swapped>>

(install-data-driven-sum)
(install-data-driven-product)
(install-data-driven-exponentiation)

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
(deriv '(+ (* x y) (** x 8)) 'x)
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ y (* 8 (** x 7)))

And just like that, we are done the exercise.
