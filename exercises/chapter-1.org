#+title: Chapter 1 Exercises
* Exercise 1.2
#+begin_src racket :exports both
#lang sicp

; Exercise 1.2
( /
  ( + 5 4 ( - 2 ( - 3 ( + 6 ( / 4 5)))))
  ( * 3 ( - 6 2) ( - 2 7)))
#+end_src

#+RESULTS:
: -37/150
* Exercise 1.3
#+begin_src racket :exports both
#lang sicp
; Planning:
; If less than or equal to, we will cover the case where they are all equal,
; and the case where there are two smallest
(define (sum-of-square x y) (+ (* x x) (* y y)))
(define (<= x y) (or (< x y) (= x y)))
(define (less-than-others a b c) (and ( <= a b) ( <= a c)))
(define (exercise-1-3 x y z)
  (cond ((less-than-others x y z) (sum-of-square y z))
        ((less-than-others y x z) (sum-of-square x z))
        ((less-than-others z x y) (sum-of-square x y))
        ))

(= (exercise-1-3 1 2 3) 13)
(= (exercise-1-3 3 2 1) 13)
(= (exercise-1-3 3 1 2) 13)
(= (exercise-1-3 2 3 1) 13)
(= (exercise-1-3 3 2 2) 13)
(= (exercise-1-3 2 2 2) 8)
#+end_src

#+RESULTS:
: #t
: #t
: #t
: #t
: #t
: #t
* Exercise 1.4
If b is greater than 0, add a and b, else subtract a and b
* Exercise 1.6
Using the re-implementation of the if special method will cause the operator to be evaluated, increasing total evaluations to increase by around 25%.

* Exercise 1.7

#+begin_src racket :exports both
#lang sicp

(define
  (average x y)
  (/ (+ x y) 2))

(define (abs x) (if (< x 0) (- x) x))

;; Returns a guess that is closer to the sqrt of the value
(define (improve guess value)
  (average guess (/ value guess)))

;; Predicate that returns true if the guess was close enough to the sqrt of
;; the value
(define (close-enough? guess value)
  (< (abs (- value (* guess guess))) 0.001))

(define (sqrt-iter guess value)
  (if (close-enough? guess value)
      guess
      (sqrt-iter (improve guess value) value)))

;; This is the user interface for the function
(define (sqrt value) (sqrt-iter 1.0 value))

(sqrt 9)

;; Here is the edge case that would break the previous version
;; This should be 0.01, but it will evaluate to around 0.03
(sqrt 0.0001)

;; With this many zeros, the line below actually just does not evaluate
;; (sqrt 1000000000000000)

(define (new-close-enough? guess prev-guess)
  (< (abs (- guess prev-guess)) 0.001))

(define (new-sqrt-iter guess prev-guess value)
  (if (new-close-enough? guess prev-guess)
      guess
      (new-sqrt-iter (improve guess value) guess value)))

(define (new-sqrt value) (new-sqrt-iter 1.0 0 value))

;; The following calls will return the correct values
(new-sqrt 9)
(new-sqrt 0.0001)
(new-sqrt 1000000000000000)

;; This is the test for very large and very small values
(new-sqrt 0.00000000000001)
(new-sqrt 10000000000000000000000000)

;; Conclusion from running this procedure on a very small and a very large
;; value is that the new method works better on very large values
#+end_src

#+RESULTS:
: 3.00009155413138
: 0.03230844833048122
: 3.000000001396984
: 0.010000714038711746
: 31622776.601683795
: 0.00097656250341333
: 3162277660168.3794
* Exercise 1.8
** Problem statement
Create a procedure for cube root using the Newton method
** Implementation
#+begin_src racket :exports both
#lang sicp

(define (abs x) (if (< x 0) (- x) x))
(define (square x) (* x x))

;; Returns a guess that is closer to the sqrt of the value
(define (improve guess value)
  (/ (+ (/ value (square guess)) (* 2 guess)) 3))

(define (new-close-enough? guess prev-guess)
  (< (abs (- guess prev-guess)) 0.001))

(define (cube-root-iter guess prev-guess value)
  (if (new-close-enough? guess prev-guess)
      guess
      (cube-root-iter (improve guess value) guess value)))

(define (cube-root value) (cube-root-iter 1.0 0 value))

(cube-root 27)
#+end_src

#+RESULTS:
: 3.0000000000000977
* Exercise 1.9
** Program 1
#+begin_src racket :exports both
#lang sicp
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc  5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+end_src

#+RESULTS:
#+begin_example
9
9
9
9
9
9
9
9
9
9
#+end_example
- In this version of the program, we can see that the previous "call stack" is waiting for the result of the next step of the process, therefore, this is as recursive process.
** Program 2
#+begin_src racket :exports both
#lang sicp
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
#+end_src

#+RESULTS:
: 9
: 9
: 9
: 9
: 9
: 9

- In this version of the program, all the relevant states are passed into the next iteration of the process, therefore, this a iterative process
* Exercise 1.10
We are working with Ackermann's function, which has the following form
#+begin_src racket :exports both
#lang sicp
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
#+end_src
** Finding the values for the expressions
We are not going to evaluate this procedure yet. Let's answer some questions first.

~(A 1 10)~ will do the following.
#+begin_src racket :exports code
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
;; Expansion as we reduce the value of y
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
;; Expansion is now done, it can reduce down by multiplying by 2
1024
;; When x is 1, the function acts like 2 to the power of y
#+end_src
When ~x~ is 1, we see that the function is \(2^{y}\)

~(A 2 4)~ will do the following
#+begin_src racket :exports code
(A 2 4)
(A 1 (A 2 3))
;; Expansion as we reduce the value of y
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
;; (A 1 4) is 2 to the power of 4
(A 1 16)
;; Expansion is now done,
65536
#+end_src

When ~x~ is 2, we see that the function is 2 pow 2 (y - 1) times

~(A 3 3)~ will do the following
#+begin_src racket :exports code
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
;; Now we already know what is function is when x is 2, so we can just solve mathematically
(A 2 4)
;; This is a similar value
65536
#+end_src
** Mathematical definition
#+begin_src racket :exports code
(define (f n) (A 0 n))
#+end_src

\[f \left( n \right) = 2 \times n\]

#+begin_src racket :exports code
(define (g n) (A 1 n))
#+end_src

\[g \left( n \right) = 2 ^{n} \]

#+begin_src racket :exports code
(define (h n) (A 2 n))
#+end_src

\[h \left( n \right) = {^{n}2} \]

Looks like this is a concept for [[https://en.wikipedia.org/wiki/Tetration][tetration]]
* Exercise 1.11
** Definition
\[f \left( n \right) = \begin{cases} n ~ \text{if} ~ n < 3 \\ f \left( n - 1 \right) + 2 f \left( n -2  \right) + 3 f \left( n - 3 \right) ~ \text{if} ~ n \geq 3 \end{cases}
\]
** Recursive process
#+begin_src racket :exports both
#lang sicp
(define (f n) (if (< n 3) n
                     (+ (f (- n 1))
                        (* 2 (f (- n 2)))
                        (* 3 (f (- n 3))))))
(f 0)
(f 1)
(f 2)
(f 3)
(f 4)
(f 5)
(f 6)
(f 7)
(f 8)
#+end_src

#+RESULTS:
: 0
: 1
: 2
: 4
: 11
: 25
: 59
: 142
: 335

** Iterative process
#+begin_src racket :exports both
#lang sicp
(define (f n)
  (define (f-aux f-1-aux f-2-aux f-3-aux) (+ f-1-aux (* 2 f-2-aux) (* 3 f-3-aux)))
  (define (f-iter cnt f-1 f-2 f-3)
    (if (= n cnt)
        (f-aux f-1 f-2 f-3)
        (f-iter (inc cnt) (f-aux f-1 f-2 f-3) f-1 f-2)))
  (if (< n 3) n (f-iter 3 2 1 0)))
(f 0)
(f 1)
(f 2)
(f 3)
(f 4)
(f 5)
(f 6)
(f 7)
(f 8)
(f 100)
#+end_src

#+RESULTS:
#+begin_example
0
1
2
4
11
25
59
142
335
11937765839880230562825561449279733086
#+end_example

* Exercise 1.12
Make pascal's triangle using a recursive process. Question does not define the parameters of the triangle, so we will do that. Since we have to be able to retrieve any element of Pascal's triangle, we need to make the origin start at the tip of the triangle.

#+caption: Coordinate system being used.
#+begin_example
1 | 1
2 | 1 1
3 | 1 2 1
4 | 1 3 3 1
5 | 1 4 6 4 1
===============
  | 1 2 3 4 5

(pascal row col)
#+end_example

- Base cases
  - If row is 1, then return 1
  - If col is 1, then return 1
  - If row and col are equal, then return 1
- Recursive case
  - ~(+ (pascal (- row 1) (- col 1)) (pascal (- row 1) col))~

#+begin_src racket :exports both
#lang sicp
(define (pascal row col)
  (if (or (< row 2)
          (< col 2)
          (> col (- row 1))) 1
      (+ (pascal (- row 1) (- col 1))
         (pascal (- row 1) col))))

(= (pascal 1 1) 1)
(= (pascal 5 1) 1)
(= (pascal 3 3) 1)
(= (pascal 4 2) 3)
(= (pascal 5 4) 4)
(= (pascal 5 3) 6)
#+end_src

#+RESULTS:
: #t
: #t
: #t
: #t
: #t
: #t

* Exercise 1.13
Prove that \(\text{fib} \left( n \right)\) is the closest integer to \(\varphi^{n} / \sqrt{5} \), where

\[ \varphi = \frac{1 + \sqrt{5}}{2} \approx 1.6180
\]

is the golden ratio that satisfies the following equation

\[\varphi^{2} = \varphi + 1
\]

** Solution

I don't have a very rigorous mathematical background, so my proof will end up being strange looking.

Let \(\psi = (1 - \sqrt{5} ) / 2\)

Prove that \(\text{fib} \left( n \right) = \left( \varphi^{n} - \psi^{n} \right) / \sqrt{5}\) using induction and the definition of \(\text{fib} \left( n \right)\).

\begin{equation}
\text{fib} \left( n \right) = \begin{cases}0 & \text{if}~n=0\\
1 & \text{if} ~ n=1 \\ \text{fib} \left( n - 1 \right) +
\text{fib} \left( n -2 \right) & \text{otherwise}\end{cases}
\end{equation}

base cases:

\begin{align*}
\frac{\varphi^{0} - \psi^{0}}{\sqrt{5}} &= 0 \\
\therefore \frac{\varphi^{0} - \psi^{0}}{\sqrt{5}} &= \text{fib} \left( 0 \right) \\
\frac{\varphi^{1} - \psi^{1}}{\sqrt{5}} &= \frac{\frac{1 + \sqrt{5}}{2} - \frac{1 - \sqrt{5}}{2}}{ \sqrt{5}} \\
&= \frac{\frac{1 + \sqrt{5} - 1 + \sqrt{5}}{2}}{\sqrt{5}} \\
&= \frac{2 \sqrt{5}}{2\sqrt{5}} \\
&= 1 \\
\therefore \frac{\varphi^{1} - \psi^{1}}{\sqrt{5}} &= \text{fib} \left( 1 \right) \\
\end{align*}

Inductive case:
- We need to prove the following

\begin{equation*}
\frac{\varphi^{n-1} - \psi^{n -1}}{\sqrt{5}} + \frac{\varphi^{n-2} - \psi^{n -2}}{\sqrt{5}} = \frac{\varphi^{n} - \psi^{n}}{\sqrt{5}}
\end{equation*}

\begin{align*}
\frac{\varphi^{n-1} - \psi^{n -1}+ \varphi^{n-2} - \psi^{n -2}}{\sqrt{5}} &= \frac{\varphi^{n-1}+ \varphi^{n-2} - \psi^{n -1} - \psi^{n -2}}{\sqrt{5}} \\
&= \frac{ \varphi^{n} \left( \varphi^{-1}+ \varphi^{-2} \right)  - \psi^{n}\left(  \psi^{ -1} + \psi^{ -2}\right) }{\sqrt{5}}
\end{align*}

Like the good programmer we are, we will solve the sub problem separately.
\begin{align*}
\varphi^{-1} + \varphi^{-2} &= \frac{2}{1 + \sqrt{5}} + \frac{4}{\left( 1 + \sqrt{5} \right)^{2}} \\
&= \frac{2 \left( 1 + \sqrt{5} \right) + 4}{\left( 1 + \sqrt{5} \right)^{2}} \\
&= \frac{ \left( 2 + 2\sqrt{5} \right) + 4}{\left( 1 + 2\sqrt{5} + 5 \right)} \\
&= \frac{  6 + 2\sqrt{5} }{ 6 + 2\sqrt{5}   } \\
&= 1 \\
\end{align*}

\begin{align*}
\psi^{-1} + \psi^{-2} &= \frac{2}{1 - \sqrt{5}} + \frac{4}{\left( 1 - \sqrt{5} \right)^{2}} \\
&= \frac{2 \left( 1 - \sqrt{5} \right) + 4}{\left( 1 - \sqrt{5} \right)^{2}} \\
&= \frac{ \left( 2 - 2\sqrt{5} \right) + 4}{\left( 1 - 2\sqrt{5} + 5 \right)} \\
&= \frac{  6 - 2\sqrt{5} }{ 6 - 2\sqrt{5}   } \\
&= 1 \\
\end{align*}

Substituting this back

\begin{align*}
\frac{\varphi^{n-1} - \psi^{n -1}+ \varphi^{n-2} - \psi^{n -2}}{\sqrt{5}} &= \frac{ \varphi^{n}  - \psi^{n} }{\sqrt{5}} \\
\therefore \frac{ \varphi^{n}  - \psi^{n} }{\sqrt{5}} &= \text{fib} \left( n \right)
\end{align*}

The distance between \(\varphi^{2}/\sqrt{5}\) and \(\text{fib} \left( n \right)\) is therefore \(\psi^{2}/\sqrt{5}\), which when calculated is around 0.4472 at \(n=0\). Since this value at \(n=0\) is less than 0.5, \(\text{fib} \left( 0 \right)\) is the closest integer to \(\varphi^{2}/2\). Since the term is exponentiated, the distance between \(\text{fib} \left( n \right)\) and \(\varphi^{2}/2\) will only shrink, making \(\text{fib} \left( n \right)\) the closest integer to \(\varphi^{2} / \sqrt{5}\)

* Exercise 1.14
Draw the process tree for the count-change program, defined below, and define the order of growth of the process.
#+begin_src racket :exports both
#lang sicp
(define (value-of-kind x)
  (cond ((= x 5) 50)
        ((= x 4) 25)
        ((= x 3) 10)
        ((= x 2) 5)
        ((= x 1) 1)))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount (- kinds-of-coins 1))
                 (cc (- amount (value-of-kind kinds-of-coins)) kinds-of-coins)
                 ))
        ))
(define (count-change amount) (cc amount 5))
(count-change 11)
#+end_src

#+RESULTS:
: 4


Evaluation tree was drawn off screen. This is a \(\Theta(n^{2})\) step algorithm with a \(\Theta(n)\) space complexity.
* Exercise 1.15
Approximating sine using software. We have the following identity.

\[
\sin (x) = 3 \sin \left(\frac{x}{3}\right) - 4 \sin^{3} \left( \frac{x}{3} \right)
\]

This definition leaverages the fact that at small enough x, \(\sin(x) \approx x\).

We are provided the following procedure.
#+begin_src racket :exports both
#lang sicp
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine x) (if (not (> (abs x) 0.1))
                     x
                     (p (sine (/ x 3.0)))))
#+end_src
** Question a
*** Question
How many times does the procedure p get applied when calling ~(sine 12.15)~.

*** Answer
This question is really asking how many times do we have to call sine before it recursively gets to a value below 0.1. I manually pressed the divide by 3 button on my calculator 5 times before getting to 0.05, which would be our target value to would prevent the p procedure from being called.
** Question b
*** Question
What is the order of growth of this procedure in both steps and space.
*** Answer
This procedure is a linear recursive function, meaning that there is not tail call strategy, but evaluation does not navigate a tree. Getting to the approximation case is logarithmic, as a division by 3 is used to get there. Nature of this program is that space grows exactly as the steps do, therefore space order of growth is also logarithmic. \(\Theta(\log(n))\).
* Exercise 1.16
Make an iterative version of the fast exponential process.
#+begin_src racket :exports both
#lang sicp
(define (fast-expt b n)
  (define (square x) (* x x))
  (define (even? x) (= (remainder x 2) 0))
  (define (fast-expt-iter b n a)
    (if (= n 0) a (if (even? n)
                      (fast-expt-iter (square b) (/ n 2) a)
                      (fast-expt-iter b (- n 1) (* a b)))))
  (fast-expt-iter b n 1))

(fast-expt 2 100)
#+end_src

#+RESULTS:
: 1267650600228229401496703205376
* Exercise 1.17
Make an analogous version of ~fast-expt~, but using addition to achieve multiplication.

#+begin_src racket :exports both
#lang sicp
(define (double x) (+ x x))
(define (halve x) (/ x 2))
(define (even? x) (= (remainder x 2) 0))
(define (fast-multi x y)
  (cond ((or (= y 0) (= x 0)) 0)
        ((even? y) (double (fast-multi x (halve y))))
        (else (+ x (fast-multi x (- y 1))))))

(fast-multi 2 1000000000000)
#+end_src

#+RESULTS:
: 2000000000000

* Exercise 1.18
#+begin_src racket :exports both
#lang sicp
(define (double x) (+ x x))
(define (halve x) (/ x 2))
(define (even? x) (= (remainder x 2) 0))
(define (fast-multi x y)
  (define (fast-multi-iter x y a)
    (if (= y 0) a
        (if (even? y)
            (fast-multi-iter (double x) (halve y) a)
            (fast-multi-iter x (- y 1) (+ x a)))))
  (fast-multi-iter x y 0))

(fast-multi 10 100000000000000)
#+end_src

#+RESULTS:
: 1000000000000000
* Exercise 1.19
Make logarithmic order of growth Fibonacci implementation.
** Find the transformation equivalent to applying fib twice
We can just try applying the generic transformation case twice, and finding what ~p'~ and ~q'~ is.

#+begin_example
a_1 = bq + aq + ap, b_1 = aq + bp
a_2 = b_1 q + a_1 q + a_1 p, b_2 = a_1 q + b_1 p
a_2 = (aq + bp)q + (bq + aq + ap)q + (bq+ aq + ap) p, b_2 = (bq + aq + ap)q + (aq + bp)p
a_2 = aq^2 + bpq + bq^2 + aq^2 + apq + bqp + aqp + ap^2, b_2 = bq^2 + aq^2 + apq + aqp + bp^2
a_2 = 2aq^2 + 2bpq + + bq^2 + 2apq + ap^2, b_2 = bq^2 + aq^2 + 2apq + bp^2
b_2 = a q' + b p' = a(q^2 + 2pq) + b (q^2 + p^2)

Check with a_2

a_2 = a(q^2 + 2pq) + b(q^2 + 2pq) + a(p^2 + q^2)

therefore p'=(q^2 + p^2), and q'=(q^2 + 2pq)
#+end_example

** Completing logarithmic fib iter

Here is the implementation.
#+begin_src racket :exports both
#lang sicp
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q counter)
  (cond ((= counter 0) b)
        ((even? counter) (fib-iter a b (+ (square q) (square p)) (+ (square q) (* 2 p q)) (/ counter 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* a q) (* b p)) p q (- counter 1)))))
(define (square x) (* x x))

(fib 10)
#+end_src

#+RESULTS:
: 55
* Exercise 1.20
How many remainder operation actually runs using both normal order and applicative order evaluation on ~( gcd 206 40 )~?

#+begin_src racket
#lang sicp
(define (gcd a b)
  (if (= b 0) a
      (gcd b (remainder a b))))
#+end_src
** Normal order evaluation
#+begin_src racket :exports code
(gcd 206 40)
(gcd 40 (remainder 206 40)) ; 1 remainder evaluated: 6
(gcd (remainder 206 40) (remainder 40 (remainder 206 40))) ; 3 remainder evaluated: 4
(gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; 7 remainder evaluated: 2
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40))
                (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; 14 remainder evaluated: 0
(remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; 18 remainders evaluated -> output 2
#+end_src

** Applicative order evaluation
#+begin_src racket :exports code
(gcd 206 40) ; 1 remainder evaluated
(gcd 40 6) ; 2 remainder evaluated
(gcd 6 4) ; 3 remainder evaluated
(gcd 4 2) ; 4 remainder evaluated
(gcd 2 0) ; -> output 2
#+end_src

Only three remainders are evaluated in applicative order evaluation.
* Exercise 1.21
Use the ~smallest-divisor~ procedure to find the smallest divisor of each of the following numbers: 199, 1999, 19999
#+begin_src racket :exports both
#lang sicp
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? x y) (= (remainder y x) 0))
(define (square x) (* x x))

(smallest-divisor 199)
(smallest-divisor 1999)
(smallest-divisor 19999)
#+end_src

#+RESULTS:
: 199
: 1999
: 7
* Exercise 1.22
#+begin_src racket :exports code
#lang sicp
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime) (- (runtime) start-time)))
(define (report-prime elasped-time)
  (display " *** ")
  (display elapsed-time))
#+end_src

Using this procedure, write a procedure that searches for the three smallest primes larger than 1000, 10000, 100000, 1000000.

#+begin_src racket :exports both
#lang sicp
;; Importing prime?
(define (square x) (* x x))
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? x y) (= (remainder y x) 0))
(define (prime? n)
  (= n (smallest-divisor n)))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

;; Where lower is the start location, and n is the number of prime numbers
;; being searched for.

;; Here is what can be done. Iterate n down to 0
(define (search-for-primes lower n)
  (if (even? lower) (search-for-primes-aux (+ lower 1) n) (search-for-primes-aux lower n)))

;; Invariant: Lower will always be a positive odd integer
(define (search-for-primes-aux lower n)
  (define (print-completion) (newline) (display "Search complete"))
  (cond ((= n 0) (print-completion))
        ((prime? lower) (timed-prime-test lower) (search-for-primes-aux (+ lower 2) (- n 1)))
        (else (search-for-primes-aux (+ lower 2) n))
        ))

(search-for-primes 1000 3)
(search-for-primes 10000 3)
(search-for-primes 100000 3)
(search-for-primes 1000000 3)
(search-for-primes 10000000 3)
(search-for-primes 100000000 3)
(search-for-primes 1000000000 3)
#+end_src

#+RESULTS:
#+begin_example

1009 *** 2
1013 *** 0
1019 *** 1
Search complete
10007 *** 0
10009 *** 0
10037 *** 1
Search complete
100003 *** 1
100019 *** 1
100043 *** 2
Search complete
1000003 *** 4
1000033 *** 3
1000037 *** 4
Search complete
10000019 *** 10
10000079 *** 10
10000103 *** 11
Search complete
100000007 *** 33
100000037 *** 34
100000039 *** 34
Search complete
1000000007 *** 107
1000000009 *** 104
1000000021 *** 103
Search complete
#+end_example

* Example 1.23

Improve the performance of ~smallest-divisor~.

#+begin_src racket :exports both
#lang sicp
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))
(define (divides? x y) (= (remainder y x) 0))
(define (square x) (* x x))
(define (next x)
  (if (< x 3) (+ x 1) (+ x 2)))
(define (prime? n)
  (= n (smallest-divisor n)))

(smallest-divisor 199)
(smallest-divisor 1999)
(smallest-divisor 19999)

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

;; Where lower is the start location, and n is the number of prime numbers
;; being searched for.

;; Here is what can be done. Iterate n down to 0
(define (search-for-primes lower n)
  (if (even? lower) (search-for-primes-aux (+ lower 1) n) (search-for-primes-aux lower n)))

;; Invariant: Lower will always be a positive odd integer
(define (search-for-primes-aux lower n)
  (define (print-completion) (newline) (display "Search complete"))
  (cond ((= n 0) (print-completion))
        ((prime? lower) (timed-prime-test lower) (search-for-primes-aux (+ lower 2) (- n 1)))
        (else (search-for-primes-aux (+ lower 2) n))
        ))

(search-for-primes 1000 3)
(search-for-primes 10000 3)
(search-for-primes 100000 3)
(search-for-primes 1000000 3)
(search-for-primes 10000000 3)
(search-for-primes 100000000 3)
(search-for-primes 1000000000 3)
#+end_src

#+RESULTS:
#+begin_example
199
1999
7

1009 *** 2
1013 *** 0
1019 *** 0
Search complete
10007 *** 1
10009 *** 0
10037 *** 0
Search complete
100003 *** 1
100019 *** 1
100043 *** 0
Search complete
1000003 *** 7
1000033 *** 2
1000037 *** 2
Search complete
10000019 *** 6
10000079 *** 5
10000103 *** 6
Search complete
100000007 *** 19
100000037 *** 18
100000039 *** 17
Search complete
1000000007 *** 68
1000000009 *** 60
1000000021 *** 64
Search complete
#+end_example

Result is as we expect, the runtime does halves.
* Exercise 1.24
Now we are testing the algorithm using ~fast-prime?~ using the code from exercise 1.22. Also analyze the runtime complexity of the program.

Since the ~fast-prime?~ algorithm is \(\Theta \left( \log \left( n \right) \right)\), we expect the growths of the steps to slow down when \(n\) is large, and the number of steps to increase rapidly when \(n\) is small. We can see that this does indeed happen in the implementation below, with 100 retries.

#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))
;; importing fast-prime?
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(define (fermat-test n)
  (define (try-it a) (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
(define (expmod base expo m)
  (cond ((= expo 0) 1)
        ((even? expo) (remainder (square (expmod base (/ expo 2) m)) m))
        (else (remainder (* base (expmod base (- expo 1) m)) m))))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (fast-prime? n 100)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

;; Where lower is the start location, and n is the number of prime numbers
;; being searched for.

;; Here is what can be done. Iterate n down to 0
(define (search-for-primes lower n)
  (if (even? lower) (search-for-primes-aux (+ lower 1) n) (search-for-primes-aux lower n)))

;; Invariant: Lower will always be a positive odd integer
(define (search-for-primes-aux lower n)
  (define (print-completion) (newline) (display "Search complete"))
  (cond ((= n 0) (print-completion))
        ((fast-prime? lower 100) (timed-prime-test lower) (search-for-primes-aux (+ lower 2) (- n 1)))
        (else (search-for-primes-aux (+ lower 2) n))
        ))

(search-for-primes 1000 3)
(search-for-primes 10000 3)
(search-for-primes 100000 3)
(search-for-primes 1000000 3)
(search-for-primes 10000000 3)
(search-for-primes 100000000 3)
(search-for-primes 1000000000 3)
#+end_src

#+RESULTS:
#+begin_example

1009 *** 22
1013 *** 21
1019 *** 27
Search complete
10007 *** 25
10009 *** 25
10037 *** 26
Search complete
100003 *** 29
100019 *** 30
100043 *** 29
Search complete
1000003 *** 33
1000033 *** 33
1000037 *** 33
Search complete
10000019 *** 38
10000079 *** 40
10000103 *** 40
Search complete
100000007 *** 46
100000037 *** 46
100000039 *** 46
Search complete
1000000007 *** 49
1000000009 *** 48
1000000021 *** 49
Search complete
#+end_example
* Exercise 1.25
Alyssa P. Hacker is correct, we could leverage the ~fast-expt~ procedure. This would make our program reuse code. The main question is how this could affect the performance. One would think that one modulus operation would be cheaper than doing a modulus operation every iteration. We can test this now.

#+begin_src racket :exports both
#lang sicp
(define (fast-expt b n)
  (define (square x) (* x x))
  (define (even? x) (= (remainder x 2) 0))
  (define (fast-expt-iter b n a)
    (if (= n 0) a (if (even? n)
                      (fast-expt-iter (square b) (/ n 2) a)
                      (fast-expt-iter b (- n 1) (* a b)))))
  (fast-expt-iter b n 1))

(fast-expt 2 100)
(define (square x) (* x x))
;; importing fast-prime?
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(define (fermat-test n)
  (define (try-it a) (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
(define (expmod base expo m)
  (remainder (fast-expt base expo) m))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (fast-prime? n 100)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

;; Where lower is the start location, and n is the number of prime numbers
;; being searched for.

;; Here is what can be done. Iterate n down to 0
(define (search-for-primes lower n)
  (if (even? lower) (search-for-primes-aux (+ lower 1) n) (search-for-primes-aux lower n)))

;; Invariant: Lower will always be a positive odd integer
(define (search-for-primes-aux lower n)
  (define (print-completion) (newline) (display "Search complete"))
  (cond ((= n 0) (print-completion))
        ((fast-prime? lower 100) (timed-prime-test lower) (search-for-primes-aux (+ lower 2) (- n 1)))
        (else (search-for-primes-aux (+ lower 2) n))
        ))

(search-for-primes 1000 3)
(search-for-primes 10000 3)
(search-for-primes 100000 3)
(search-for-primes 1000000 3)
#+end_src

#+RESULTS:
#+begin_example
1267650600228229401496703205376

1009 *** 3317
1013 *** 3100
1019 *** 3135
Search complete
10007 *** 265895
10009 *** 259676
10037 *** 281835
Search complete
100003 *** 8611319
100019 *** 8332395
100043 *** 9391137
Search complete
1000003 *** 274889154
1000033
#+end_example

We can see that re-using ~fast-exp~ actually decreases performance by an obscene amount. Why is this? Unfortunately, I spoiled myself by googling, but it has to do with how we are testing with very large value of n. If we fully evaluate the entire exponential before finding the remainder, we will end up calculating values that have over hundreds of zeros. After passing 2^64, we change value types from fixed length integers to dynamic integers. This breaks the operations from being constant time, which will slow down our runtime significantly. Therefore, for this type of extremely large problems, it is faster to break the result down.

* Exercise 1.26
The following procedure is \( \Theta \left( n \right)\) instead of \( \Theta \left( \log \left( n \right) \right)\). Why is this?

#+begin_src racket :exports code
(define (expmod base expo m)
  (cond ((= expo 0) 1)
        ((even? expo)
         (remainder (* (expmod base (/ expo 2) m)
                       (expmod base (/ expo 2) m))))
        (else (remainder (*
                          base
                          (expmod base (- expo 1) m)))))))
#+end_src

We can see that in the even branch, where we could use square property to cut the current exponent in half, our friend accidentally made the interpreter evaluate the half exponent case twice, exactly negating the number of steps that would have been reduced.
* Exercise 1.27
Show that Carmichael numbers fools the fermat test. Do this by writing a procedure that checks that the number n is congruent to a modulo n for all a < n. You can find the code below.

#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))

;; importing fast-prime?
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(define (fermat-test n)
  (define (fermat-test-iter n a)
    (cond ((= a 0) true)
          ((= (expmod a n n) a) (fermat-test-iter n (- a 1)))
          (else false)))
  (fermat-test-iter n (- n 1)))
(define (expmod base expo m)
  (cond ((= expo 0) 1)
        ((even? expo) (remainder (square (expmod base (/ expo 2) m)) m))
        (else (remainder (* base (expmod base (- expo 1) m)) m))))

(fermat-test 561)
(fermat-test 1105)
(fermat-test 1729)
(fermat-test 2465)
(fermat-test 2821)
(fermat-test 6601)
(fermat-test 6)
#+end_src

#+RESULTS:
: #t
: #t
: #t
: #t
: #t
: #t
: #f
* Exercise 1.28
Miller-Rabin test. A prime test that is based off the Fermat test, but it will catch all the prime values. We're going to follow the steps of the exercise, and modify expmod.
#+begin_src racket :exports both
#lang sicp
(define (square x) (* x x))

;; importing fast-prime?
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((miller-rabin-test n) (fast-prime? n (- times 1)))
        (else false)))

;; expmod condition changed
(define (miller-rabin-test n)
  (define (try-it a) (= (expmod a (- n 1) n) 1))
  (try-it (+ 1 (random (- n 1)))))

;; remainder square is now testing for nontrivial square root of 1 mod n
(define (expmod base expo m)
  (cond ((= expo 0) 1)
        ((even? expo) (remainder-square (expmod base (/ expo 2) m) m))
        (else (remainder (* base (expmod base (- expo 1) m)) m))))

(define (remainder-square v n)
  (if (and
       (not (or (= v 1) (= v (- n 1))))
       (= (remainder (square v) n) 1))
      0
      (remainder (square v) n)))

(define (assert-eq test-name value expected)
  (display (if (eq? value expected) "pass: " "fail: "))
  (display test-name)
  (newline))

(assert-eq "561 is not prime" (fast-prime? 561 10) #f)
(assert-eq "1105 is not prime" (fast-prime? 1105 10) #f)
(assert-eq "1729 is not prime" (fast-prime? 1729 10) #f)
(assert-eq "2465 is not prime" (fast-prime? 2465 10) #f)
(assert-eq "2821 is not prime" (fast-prime? 2821 10) #f)
(assert-eq "6601 is not prime" (fast-prime? 6601 10) #f)
(assert-eq "6 is not prime" (fast-prime? 6 10) #f)
(assert-eq "7 is prime" (fast-prime? 7 10) #t)
(assert-eq "5 is prime" (fast-prime? 5 10) #t)
(assert-eq "2 is prime" (fast-prime? 2 10) #t)
(assert-eq "17 is prime" (fast-prime? 17 10) #t)
(assert-eq "1000000021 is prime" (fast-prime? 1000000021 10) #t)
#+end_src

#+RESULTS:
#+begin_example
pass: 561 is not prime
pass: 1105 is not prime
pass: 1729 is not prime
pass: 2465 is not prime
pass: 2821 is not prime
pass: 6601 is not prime
pass: 6 is not prime
pass: 7 is prime
pass: 5 is prime
pass: 2 is prime
pass: 17 is prime
pass: 1000000021 is prime
#+end_example
* Exercise 1.29
We have just unlocked higher-order functions. Now we are going to use Simpson's rule for numerical integration.

Simpson's rule is as follows:

\[\frac{h}{3} \left( y_{0} + 4 y_{1} + 2y_{2} + 4 y_{3} + 2 y_{4} + \dots + 2 y_{n-2} + 4 y_{n-1} + y_{n} \right)
\]

where \(h = \left( b - a \right) / n\) for some even integer \(n\) and \(y_{k} = f \left( a + k h \right)\).

To do this, we should leverage sum.

#+begin_src racket :exports both
#lang sicp
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (integrate f a b n)
  (define h (/ (- b a) n))
  (define (fn-odd x) (* 4 (f (+ a (* x h)))))
  (define (fn-even x) (* 2 (f (+ a (* x h)))))
  (define (next x) (+ x 2))
  (* (/ h 3) (+
              (f a)
              (f (+ a (* n h)))
              (sum fn-odd 1 next (- n 1))
              (sum fn-even 2 next (- n 1))))
  )

(define (cube x) (* x x x))
(integrate cube 0.0 1.0 100)
(integrate cube 0.0 1.0 1000)
#+end_src

#+RESULTS:
: 0.25000000000000006
: 0.2500000000000002

Doing this, we were able to achieve better accuracy than the ~integral~ procedure.
