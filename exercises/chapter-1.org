#+title: Chapter 1 Exercises
* Exercise 1.2
#+begin_src racket :exports both
#lang sicp

; Exercise 1.2
( /
  ( + 5 4 ( - 2 ( - 3 ( + 6 ( / 4 5)))))
  ( * 3 ( - 6 2) ( - 2 7)))
#+end_src

#+RESULTS:
: -37/150
* Exercise 1.3
#+begin_src racket :exports both
#lang sicp
; Planning:
; If less than or equal to, we will cover the case where they are all equal,
; and the case where there are two smallest
(define (sum-of-square x y) (+ (* x x) (* y y)))
(define (<= x y) (or (< x y) (= x y)))
(define (less-than-others a b c) (and ( <= a b) ( <= a c)))
(define (exercise-1-3 x y z)
  (cond ((less-than-others x y z) (sum-of-square y z))
        ((less-than-others y x z) (sum-of-square x z))
        ((less-than-others z x y) (sum-of-square x y))
        ))

(= (exercise-1-3 1 2 3) 13)
(= (exercise-1-3 3 2 1) 13)
(= (exercise-1-3 3 1 2) 13)
(= (exercise-1-3 2 3 1) 13)
(= (exercise-1-3 3 2 2) 13)
(= (exercise-1-3 2 2 2) 8)
#+end_src

#+RESULTS:
: #t
: #t
: #t
: #t
: #t
: #t
* Exercise 1.4
If b is greater than 0, add a and b, else subtract a and b
* Exercise 1.6
Using the re-implementation of the if special method will cause the operator to be evaluated, increasing total evaluations to increase by around 25%.

* Exercise 1.7

#+begin_src racket :exports both
#lang sicp

(define
  (average x y)
  (/ (+ x y) 2))

(define (abs x) (if (< x 0) (- x) x))

;; Returns a guess that is closer to the sqrt of the value
(define (improve guess value)
  (average guess (/ value guess)))

;; Predicate that returns true if the guess was close enough to the sqrt of
;; the value
(define (close-enough? guess value)
  (< (abs (- value (* guess guess))) 0.001))

(define (sqrt-iter guess value)
  (if (close-enough? guess value)
      guess
      (sqrt-iter (improve guess value) value)))

;; This is the user interface for the function
(define (sqrt value) (sqrt-iter 1.0 value))

(sqrt 9)

;; Here is the edge case that would break the previous version
;; This should be 0.01, but it will evaluate to around 0.03
(sqrt 0.0001)

;; With this many zeros, the line below actually just does not evaluate
;; (sqrt 1000000000000000)

(define (new-close-enough? guess prev-guess)
  (< (abs (- guess prev-guess)) 0.001))

(define (new-sqrt-iter guess prev-guess value)
  (if (new-close-enough? guess prev-guess)
      guess
      (new-sqrt-iter (improve guess value) guess value)))

(define (new-sqrt value) (new-sqrt-iter 1.0 0 value))

;; The following calls will return the correct values
(new-sqrt 9)
(new-sqrt 0.0001)
(new-sqrt 1000000000000000)

;; This is the test for very large and very small values
(new-sqrt 0.00000000000001)
(new-sqrt 10000000000000000000000000)

;; Conclusion from running this procedure on a very small and a very large
;; value is that the new method works better on very large values
#+end_src

#+RESULTS:
: 3.00009155413138
: 0.03230844833048122
: 3.000000001396984
: 0.010000714038711746
: 31622776.601683795
: 0.00097656250341333
: 3162277660168.3794
* Exercise 1.8
** Problem statement
Create a procedure for cube root using the Newton method
** Implementation
#+begin_src racket :exports both
#lang sicp

(define (abs x) (if (< x 0) (- x) x))
(define (square x) (* x x))

;; Returns a guess that is closer to the sqrt of the value
(define (improve guess value)
  (/ (+ (/ value (square guess)) (* 2 guess)) 3))

(define (new-close-enough? guess prev-guess)
  (< (abs (- guess prev-guess)) 0.001))

(define (cube-root-iter guess prev-guess value)
  (if (new-close-enough? guess prev-guess)
      guess
      (cube-root-iter (improve guess value) guess value)))

(define (cube-root value) (cube-root-iter 1.0 0 value))

(cube-root 27)
#+end_src

#+RESULTS:
: 3.0000000000000977
* Exercise 1.9
** Program 1
#+begin_src racket :exports both
#lang sicp
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc  5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+end_src

#+RESULTS:
#+begin_example
9
9
9
9
9
9
9
9
9
9
#+end_example
- In this version of the program, we can see that the previous "call stack" is waiting for the result of the next step of the process, therefore, this is as recursive process.
** Program 2
#+begin_src racket :exports both
#lang sicp
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
#+end_src

#+RESULTS:
: 9
: 9
: 9
: 9
: 9
: 9

- In this version of the program, all the relevant states are passed into the next iteration of the process, therefore, this a iterative process
* Exercise 1.10
We are working with Ackermann's function, which has the following form
#+begin_src racket :exports both
#lang sicp
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
#+end_src
** Finding the values for the expressions
We are not going to evaluate this procedure yet. Let's answer some questions first.

~(A 1 10)~ will do the following.
#+begin_src racket :exports code
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
;; Expansion as we reduce the value of y
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
;; Expansion is now done, it can reduce down by multiplying by 2
1024
;; When x is 1, the function acts like 2 to the power of y
#+end_src
When ~x~ is 1, we see that the function is \(2^{y}\)

~(A 2 4)~ will do the following
#+begin_src racket :exports code
(A 2 4)
(A 1 (A 2 3))
;; Expansion as we reduce the value of y
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
;; (A 1 4) is 2 to the power of 4
(A 1 16)
;; Expansion is now done,
65536
#+end_src

When ~x~ is 2, we see that the function is 2 pow 2 (y - 1) times

~(A 3 3)~ will do the following
#+begin_src racket :exports code
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
;; Now we already know what is function is when x is 2, so we can just solve mathematically
(A 2 4)
;; This is a similar value
65536
#+end_src
** Mathematical definition
#+begin_src racket :exports code
(define (f n) (A 0 n))
#+end_src

\[f \left( n \right) = 2 \times n\]

#+begin_src racket :exports code
(define (g n) (A 1 n))
#+end_src

\[g \left( n \right) = 2 ^{n} \]

#+begin_src racket :exports code
(define (h n) (A 2 n))
#+end_src

\[h \left( n \right) = {^{n}2} \]

Looks like this is a concept for [[https://en.wikipedia.org/wiki/Tetration][tetration]]
* Exercise 1.11
** Definition
\[f \left( n \right) = \begin{cases} n ~ \text{if} ~ n < 3 \\ f \left( n - 1 \right) + 2 f \left( n -2  \right) + 3 f \left( n - 3 \right) ~ \text{if} ~ n \geq 3 \end{cases}
\]
** Recursive process
#+begin_src racket :exports both
#lang sicp
(define (f n) (if (< n 3) n
                     (+ (f (- n 1))
                        (* 2 (f (- n 2)))
                        (* 3 (f (- n 3))))))
(f 0)
(f 1)
(f 2)
(f 3)
(f 4)
(f 5)
(f 6)
(f 7)
(f 8)
#+end_src

#+RESULTS:
: 0
: 1
: 2
: 4
: 11
: 25
: 59
: 142
: 335

** Iterative process
#+begin_src racket :exports both
#lang sicp
(define (f n)
  (define (f-aux f-1-aux f-2-aux f-3-aux) (+ f-1-aux (* 2 f-2-aux) (* 3 f-3-aux)))
  (define (f-iter cnt f-1 f-2 f-3)
    (if (= n cnt)
        (f-aux f-1 f-2 f-3)
        (f-iter (inc cnt) (f-aux f-1 f-2 f-3) f-1 f-2)))
  (if (< n 3) n (f-iter 3 2 1 0)))
(f 0)
(f 1)
(f 2)
(f 3)
(f 4)
(f 5)
(f 6)
(f 7)
(f 8)
(f 100)
#+end_src

#+RESULTS:
#+begin_example
0
1
2
4
11
25
59
142
335
11937765839880230562825561449279733086
#+end_example

* Exercise 1.12
Make pascal's triangle using a recursive process. Question does not define the parameters of the triangle, so we will do that. Since we have to be able to retrieve any element of Pascal's triangle, we need to make the origin start at the tip of the triangle.

#+caption: Coordinate system being used.
#+begin_example
1 | 1
2 | 1 1
3 | 1 2 1
4 | 1 3 3 1
5 | 1 4 6 4 1
===============
  | 1 2 3 4 5

(pascal row col)
#+end_example

- Base cases
  - If row is 1, then return 1
  - If col is 1, then return 1
  - If row and col are equal, then return 1
- Recursive case
  - ~(+ (pascal (- row 1) (- col 1)) (pascal (- row 1) col))~

#+begin_src racket :exports both
#lang sicp
(define (pascal row col)
  (if (or (< row 2)
          (< col 2)
          (> col (- row 1))) 1
      (+ (pascal (- row 1) (- col 1))
         (pascal (- row 1) col))))

(= (pascal 1 1) 1)
(= (pascal 5 1) 1)
(= (pascal 3 3) 1)
(= (pascal 4 2) 3)
(= (pascal 5 4) 4)
(= (pascal 5 3) 6)
#+end_src

#+RESULTS:
: #t
: #t
: #t
: #t
: #t
: #t

* Exercise 1.13
Prove that \(\text{fib} \left( n \right)\) is the closest integer to \(\varphi^{n} / \sqrt{5} \), where

\[ \varphi = \frac{1 + \sqrt{5}}{2} \approx 1.6180
\]

is the golden ratio that satisfies the following equation

\[\varphi^{2} = \varphi + 1
\]

** Solution

I don't have a very rigorous mathematical background, so my proof will end up being strange looking.

Let \(\psi = (1 - \sqrt{5} ) / 2\)

Prove that \(\text{fib} \left( n \right) = \left( \varphi^{n} - \psi^{n} \right) / \sqrt{5}\) using induction and the definition of \(\text{fib} \left( n \right)\).

\begin{equation}
\text{fib} \left( n \right) = \begin{cases}0 & \text{if}~n=0\\
1 & \text{if} ~ n=1 \\ \text{fib} \left( n - 1 \right) +
\text{fib} \left( n -2 \right) & \text{otherwise}\end{cases}
\end{equation}

base cases:

\begin{align*}
\frac{\varphi^{0} - \psi^{0}}{\sqrt{5}} &= 0 \\
\therefore \frac{\varphi^{0} - \psi^{0}}{\sqrt{5}} &= \text{fib} \left( 0 \right) \\
\frac{\varphi^{1} - \psi^{1}}{\sqrt{5}} &= \frac{\frac{1 + \sqrt{5}}{2} - \frac{1 - \sqrt{5}}{2}}{ \sqrt{5}} \\
&= \frac{\frac{1 + \sqrt{5} - 1 + \sqrt{5}}{2}}{\sqrt{5}} \\
&= \frac{2 \sqrt{5}}{2\sqrt{5}} \\
&= 1 \\
\therefore \frac{\varphi^{1} - \psi^{1}}{\sqrt{5}} &= \text{fib} \left( 1 \right) \\
\end{align*}

Inductive case:
- We need to prove the following

\begin{equation*}
\frac{\varphi^{n-1} - \psi^{n -1}}{\sqrt{5}} + \frac{\varphi^{n-2} - \psi^{n -2}}{\sqrt{5}} = \frac{\varphi^{n} - \psi^{n}}{\sqrt{5}}
\end{equation*}

\begin{align*}
\frac{\varphi^{n-1} - \psi^{n -1}+ \varphi^{n-2} - \psi^{n -2}}{\sqrt{5}} &= \frac{\varphi^{n-1}+ \varphi^{n-2} - \psi^{n -1} - \psi^{n -2}}{\sqrt{5}} \\
&= \frac{ \varphi^{n} \left( \varphi^{-1}+ \varphi^{-2} \right)  - \psi^{n}\left(  \psi^{ -1} + \psi^{ -2}\right) }{\sqrt{5}}
\end{align*}

Like the good programmer we are, we will solve the sub problem separately.
\begin{align*}
\varphi^{-1} + \varphi^{-2} &= \frac{2}{1 + \sqrt{5}} + \frac{4}{\left( 1 + \sqrt{5} \right)^{2}} \\
&= \frac{2 \left( 1 + \sqrt{5} \right) + 4}{\left( 1 + \sqrt{5} \right)^{2}} \\
&= \frac{ \left( 2 + 2\sqrt{5} \right) + 4}{\left( 1 + 2\sqrt{5} + 5 \right)} \\
&= \frac{  6 + 2\sqrt{5} }{ 6 + 2\sqrt{5}   } \\
&= 1 \\
\end{align*}

\begin{align*}
\psi^{-1} + \psi^{-2} &= \frac{2}{1 - \sqrt{5}} + \frac{4}{\left( 1 - \sqrt{5} \right)^{2}} \\
&= \frac{2 \left( 1 - \sqrt{5} \right) + 4}{\left( 1 - \sqrt{5} \right)^{2}} \\
&= \frac{ \left( 2 - 2\sqrt{5} \right) + 4}{\left( 1 - 2\sqrt{5} + 5 \right)} \\
&= \frac{  6 - 2\sqrt{5} }{ 6 - 2\sqrt{5}   } \\
&= 1 \\
\end{align*}

Substituting this back

\begin{align*}
\frac{\varphi^{n-1} - \psi^{n -1}+ \varphi^{n-2} - \psi^{n -2}}{\sqrt{5}} &= \frac{ \varphi^{n}  - \psi^{n} }{\sqrt{5}} \\
\therefore \frac{ \varphi^{n}  - \psi^{n} }{\sqrt{5}} &= \text{fib} \left( n \right)
\end{align*}

The distance between \(\varphi^{2}/\sqrt{5}\) and \(\text{fib} \left( n \right)\) is therefore \(\psi^{2}/\sqrt{5}\), which when calculated is around 0.4472 at \(n=0\). Since this value at \(n=0\) is less than 0.5, \(\text{fib} \left( 0 \right)\) is the closest integer to \(\varphi^{2}/2\). Since the term is exponentiated, the distance between \(\text{fib} \left( n \right)\) and \(\varphi^{2}/2\) will only shrink, making \(\text{fib} \left( n \right)\) the closest integer to \(\varphi^{2} / \sqrt{5}\)

* Exercise 1.14
Draw the process tree for the count-change program, defined below, and define the order of growth of the process.
#+begin_src racket :exports both
#lang sicp
(define (value-of-kind x)
  (cond ((= x 5) 50)
        ((= x 4) 25)
        ((= x 3) 10)
        ((= x 2) 5)
        ((= x 1) 1)))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount (- kinds-of-coins 1))
                 (cc (- amount (value-of-kind kinds-of-coins)) kinds-of-coins)
                 ))
        ))
(define (count-change amount) (cc amount 5))
(count-change 11)
#+end_src

#+RESULTS:
: 4


Evaluation tree was drawn off screen. This is a \(\Theta(n^{2})\) step algorithm with a \(\Theta(n)\) space complexity.
* Exercise 1.15
Approximating sine using software. We have the following identity.

\[
\sin (x) = 3 \sin \left(\frac{x}{3}\right) - 4 \sin^{3} \left( \frac{x}{3} \right)
\]

This definition leaverages the fact that at small enough x, \(\sin(x) \approx x\).

We are provided the following procedure.
#+begin_src racket :exports both
#lang sicp
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine x) (if (not (> (abs x) 0.1))
                     x
                     (p (sine (/ x 3.0)))))
#+end_src
** Question a
*** Question
How many times does the procedure p get applied when calling ~(sine 12.15)~.

*** Answer
This question is really asking how many times do we have to call sine before it recursively gets to a value below 0.1. I manually pressed the divide by 3 button on my calculator 5 times before getting to 0.05, which would be our target value to would prevent the p procedure from being called.
** Question b
*** Question
What is the order of growth of this procedure in both steps and space.
*** Answer
This procedure is a linear recursive function, meaning that there is not tail call strategy, but evaluation does not navigate a tree. Getting to the approximation case is logarithmic, as a division by 3 is used to get there. Nature of this program is that space grows exactly as the steps do, therefore space order of growth is also logarithmic. \(\Theta(\log(n))\).
* Exercise 1.16
Make an iterative version of the fast exponential process.
#+begin_src racket :exports both
#lang sicp
(define (fast-expt b n)
  (define (square x) (* x x))
  (define (even? x) (= (remainder x 2) 0))
  (define (fast-expt-iter b n a)
    (if (= n 0) a (if (even? n)
                      (fast-expt-iter (square b) (/ n 2) a)
                      (fast-expt-iter b (- n 1) (* a b)))))
  (fast-expt-iter b n 1))

(fast-expt 2 100)
#+end_src

#+RESULTS:
: 1267650600228229401496703205376
* Exercise 1.17
Make an analogous version of ~fast-expt~, but using addition to achieve multiplication.

#+begin_src racket :exports both
#lang sicp
(define (double x) (+ x x))
(define (halve x) (/ x 2))
(define (even? x) (= (remainder x 2) 0))
(define (fast-multi x y)
  (cond ((or (= y 0) (= x 0)) 0)
        ((even? y) (double (fast-multi x (halve y))))
        (else (+ x (fast-multi x (- y 1))))))

(fast-multi 2 1000000000000)
#+end_src

#+RESULTS:
: 2000000000000

* Exercise 1.18
#+begin_src racket :exports both
#lang sicp
(define (double x) (+ x x))
(define (halve x) (/ x 2))
(define (even? x) (= (remainder x 2) 0))
(define (fast-multi x y)
  (define (fast-multi-iter x y a)
    (if (= y 0) a
        (if (even? y)
            (fast-multi-iter (double x) (halve y) a)
            (fast-multi-iter x (- y 1) (+ x a)))))
  (fast-multi-iter x y 0))

(fast-multi 10 100000000000000)
#+end_src

#+RESULTS:
: 1000000000000000
* Exercise 1.19
Make logarithmic order of growth Fibonacci implementation.
** Find the transformation equivalent to applying fib twice
We can just try applying the generic transformation case twice, and finding what ~p'~ and ~q'~ is.

#+begin_example
a_1 = bq + aq + ap, b_1 = aq + bp
a_2 = b_1 q + a_1 q + a_1 p, b_2 = a_1 q + b_1 p
a_2 = (aq + bp)q + (bq + aq + ap)q + (bq+ aq + ap) p, b_2 = (bq + aq + ap)q + (aq + bp)p
a_2 = aq^2 + bpq + bq^2 + aq^2 + apq + bqp + aqp + ap^2, b_2 = bq^2 + aq^2 + apq + aqp + bp^2
a_2 = 2aq^2 + 2bpq + + bq^2 + 2apq + ap^2, b_2 = bq^2 + aq^2 + 2apq + bp^2
b_2 = a q' + b p' = a(q^2 + 2pq) + b (q^2 + p^2)

Check with a_2

a_2 = a(q^2 + 2pq) + b(q^2 + 2pq) + a(p^2 + q^2)

therefore p'=(q^2 + p^2), and q'=(q^2 + 2pq)
#+end_example

** Completing logarithmic fib iter

Here is the implementation.
#+begin_src racket :exports both
#lang sicp
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q counter)
  (cond ((= counter 0) b)
        ((even? counter) (fib-iter a b (+ (square q) (square p)) (+ (square q) (* 2 p q)) (/ counter 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* a q) (* b p)) p q (- counter 1)))))
(define (square x) (* x x))

(fib 10)
#+end_src

#+RESULTS:
: 55
* Exercise 1.20
How many remainder operation actually runs using both normal order and applicative order evaluation on ~( gcd 206 40 )~?

#+begin_src racket
#lang sicp
(define (gcd a b)
  (if (= b 0) a
      (gcd b (remainder a b))))
#+end_src
** Normal order evaluation
#+begin_src racket :exports code
(gcd 206 40)
(gcd 40 (remainder 206 40)) ; 1 remainder evaluated: 6
(gcd (remainder 206 40) (remainder 40 (remainder 206 40))) ; 3 remainder evaluated: 4
(gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; 7 remainder evaluated: 2
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40))
                (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; 14 remainder evaluated: 0
(remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; 18 remainders evaluated -> output 2
#+end_src

** Applicative order evaluation
#+begin_src racket :exports code
(gcd 206 40) ; 1 remainder evaluated
(gcd 40 6) ; 2 remainder evaluated
(gcd 6 4) ; 3 remainder evaluated
(gcd 4 2) ; 4 remainder evaluated
(gcd 2 0) ; -> output 2
#+end_src

Only three remainders are evaluated in applicative order evaluation.
* Exercise 1.21
Use the ~smallest-divisor~ procedure to find the smallest divisor of each of the following numbers: 199, 1999, 19999
#+begin_src racket :exports both
#lang sicp
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? x y) (= (remainder y x) 0))
(define (square x) (* x x))

(smallest-divisor 199)
(smallest-divisor 1999)
(smallest-divisor 19999)
#+end_src

#+RESULTS:
: 199
: 1999
: 7
* Exercise 1.22
#+begin_src racket :exports code
#lang sicp
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime) (- (runtime) start-time)))
(define (report-prime elasped-time)
  (display " *** ")
  (display elapsed-time))
#+end_src

Using this procedure, write a procedure that searches for the three smallest primes larger than 1000, 10000, 100000, 1000000.

#+begin_src racket :exports both
#lang sicp
;; Importing prime?
(define (square x) (* x x))
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? x y) (= (remainder y x) 0))
(define (prime? n)
  (= n (smallest-divisor n)))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

;; Where lower is the start location, and n is the number of prime numbers
;; being searched for.

;; Here is what can be done. Iterate n down to 0
(define (search-for-primes lower n)
  (if (even? lower) (search-for-primes-aux (+ lower 1) n) (search-for-primes-aux lower n)))

;; Invariant: Lower will always be a positive odd integer
(define (search-for-primes-aux lower n)
  (define (print-completion) (newline) (display "Search complete"))
  (cond ((= n 0) (print-completion))
        ((prime? lower) (timed-prime-test lower) (search-for-primes-aux (+ lower 2) (- n 1)))
        (else (search-for-primes-aux (+ lower 2) n))
        ))

(search-for-primes 1000 3)
(search-for-primes 10000 3)
(search-for-primes 100000 3)
(search-for-primes 1000000 3)
(search-for-primes 10000000 3)
(search-for-primes 100000000 3)
(search-for-primes 1000000000 3)
#+end_src

#+RESULTS:
#+begin_example

1009 *** 2
1013 *** 0
1019 *** 1
Search complete
10007 *** 0
10009 *** 0
10037 *** 1
Search complete
100003 *** 1
100019 *** 1
100043 *** 2
Search complete
1000003 *** 4
1000033 *** 3
1000037 *** 4
Search complete
10000019 *** 10
10000079 *** 10
10000103 *** 11
Search complete
100000007 *** 33
100000037 *** 34
100000039 *** 34
Search complete
1000000007 *** 107
1000000009 *** 104
1000000021 *** 103
Search complete
#+end_example

* Example 1.23

Improve the performance of ~smallest-divisor~.

#+begin_src racket :exports both
#lang sicp
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))
(define (divides? x y) (= (remainder y x) 0))
(define (square x) (* x x))
(define (next x)
  (if (< x 3) (+ x 1) (+ x 2)))
(define (prime? n)
  (= n (smallest-divisor n)))

(smallest-divisor 199)
(smallest-divisor 1999)
(smallest-divisor 19999)

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

;; Where lower is the start location, and n is the number of prime numbers
;; being searched for.

;; Here is what can be done. Iterate n down to 0
(define (search-for-primes lower n)
  (if (even? lower) (search-for-primes-aux (+ lower 1) n) (search-for-primes-aux lower n)))

;; Invariant: Lower will always be a positive odd integer
(define (search-for-primes-aux lower n)
  (define (print-completion) (newline) (display "Search complete"))
  (cond ((= n 0) (print-completion))
        ((prime? lower) (timed-prime-test lower) (search-for-primes-aux (+ lower 2) (- n 1)))
        (else (search-for-primes-aux (+ lower 2) n))
        ))

(search-for-primes 1000 3)
(search-for-primes 10000 3)
(search-for-primes 100000 3)
(search-for-primes 1000000 3)
(search-for-primes 10000000 3)
(search-for-primes 100000000 3)
(search-for-primes 1000000000 3)
#+end_src

#+RESULTS:
#+begin_example
199
1999
7

1009 *** 2
1013 *** 0
1019 *** 0
Search complete
10007 *** 1
10009 *** 0
10037 *** 0
Search complete
100003 *** 1
100019 *** 1
100043 *** 0
Search complete
1000003 *** 7
1000033 *** 2
1000037 *** 2
Search complete
10000019 *** 6
10000079 *** 5
10000103 *** 6
Search complete
100000007 *** 19
100000037 *** 18
100000039 *** 17
Search complete
1000000007 *** 68
1000000009 *** 60
1000000021 *** 64
Search complete
#+end_example

Result is as we expect, the runtime does halves.
