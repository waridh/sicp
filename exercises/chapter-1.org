#+title: Chapter 1 Exercises
* Exercise 1.2
#+begin_src racket :exports both
#lang sicp

; Exercise 1.2
( /
  ( + 5 4 ( - 2 ( - 3 ( + 6 ( / 4 5)))))
  ( * 3 ( - 6 2) ( - 2 7)))
#+end_src

#+RESULTS:
: -37/150
* Exercise 1.3
#+begin_src racket :exports both
#lang sicp
; Planning:
; If less than or equal to, we will cover the case where they are all equal,
; and the case where there are two smallest
(define (sum-of-square x y) (+ (* x x) (* y y)))
(define (<= x y) (or (< x y) (= x y)))
(define (less-than-others a b c) (and ( <= a b) ( <= a c)))
(define (exercise-1-3 x y z)
  (cond ((less-than-others x y z) (sum-of-square y z))
        ((less-than-others y x z) (sum-of-square x z))
        ((less-than-others z x y) (sum-of-square x y))
        ))

(= (exercise-1-3 1 2 3) 13)
(= (exercise-1-3 3 2 1) 13)
(= (exercise-1-3 3 1 2) 13)
(= (exercise-1-3 2 3 1) 13)
(= (exercise-1-3 3 2 2) 13)
(= (exercise-1-3 2 2 2) 8)
#+end_src

#+RESULTS:
: #t
: #t
: #t
: #t
: #t
: #t
* Exercise 1.4
If b is greater than 0, add a and b, else subtract a and b
* Exercise 1.6
Using the re-implementation of the if special method will cause the operator to be evaluated, increasing total evaluations to increase by around 25%.

* Exercise 1.7

#+begin_src racket :exports both
#lang sicp

(define
  (average x y)
  (/ (+ x y) 2))

(define (abs x) (if (< x 0) (- x) x))

;; Returns a guess that is closer to the sqrt of the value
(define (improve guess value)
  (average guess (/ value guess)))

;; Predicate that returns true if the guess was close enough to the sqrt of
;; the value
(define (close-enough? guess value)
  (< (abs (- value (* guess guess))) 0.001))

(define (sqrt-iter guess value)
  (if (close-enough? guess value)
      guess
      (sqrt-iter (improve guess value) value)))

;; This is the user interface for the function
(define (sqrt value) (sqrt-iter 1.0 value))

(sqrt 9)

;; Here is the edge case that would break the previous version
;; This should be 0.01, but it will evaluate to around 0.03
(sqrt 0.0001)

;; With this many zeros, the line below actually just does not evaluate
;; (sqrt 1000000000000000)

(define (new-close-enough? guess prev-guess)
  (< (abs (- guess prev-guess)) 0.001))

(define (new-sqrt-iter guess prev-guess value)
  (if (new-close-enough? guess prev-guess)
      guess
      (new-sqrt-iter (improve guess value) guess value)))

(define (new-sqrt value) (new-sqrt-iter 1.0 0 value))

;; The following calls will return the correct values
(new-sqrt 9)
(new-sqrt 0.0001)
(new-sqrt 1000000000000000)

;; This is the test for very large and very small values
(new-sqrt 0.00000000000001)
(new-sqrt 10000000000000000000000000)

;; Conclusion from running this procedure on a very small and a very large
;; value is that the new method works better on very large values
#+end_src

#+RESULTS:
: 3.00009155413138
: 0.03230844833048122
: 3.000000001396984
: 0.010000714038711746
: 31622776.601683795
: 0.00097656250341333
: 3162277660168.3794
* Exercise 1.8
** Problem statement
Create a procedure for cube root using the Newton method
** Implementation
#+begin_src racket :exports both
#lang sicp

(define (abs x) (if (< x 0) (- x) x))
(define (square x) (* x x))

;; Returns a guess that is closer to the sqrt of the value
(define (improve guess value)
  (/ (+ (/ value (square guess)) (* 2 guess)) 3))

(define (new-close-enough? guess prev-guess)
  (< (abs (- guess prev-guess)) 0.001))

(define (cube-root-iter guess prev-guess value)
  (if (new-close-enough? guess prev-guess)
      guess
      (cube-root-iter (improve guess value) guess value)))

(define (cube-root value) (cube-root-iter 1.0 0 value))

(cube-root 27)
#+end_src

#+RESULTS:
: 3.0000000000000977
* Exercise 1.9
** Program 1
#+begin_src racket :exports both
#lang sicp
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc  5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+end_src

#+RESULTS:
#+begin_example
9
9
9
9
9
9
9
9
9
9
#+end_example
- In this version of the program, we can see that the previous "call stack" is waiting for the result of the next step of the process, therefore, this is as recursive process.
** Program 2
#+begin_src racket :exports both
#lang sicp
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
#+end_src

#+RESULTS:
: 9
: 9
: 9
: 9
: 9
: 9

- In this version of the program, all the relevant states are passed into the next iteration of the process, therefore, this a iterative process
* Exercise 1.10
We are working with Ackermann's function, which has the following form
#+begin_src racket :exports both
#lang sicp
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
#+end_src
** Finding the values for the expressions
We are not going to evaluate this procedure yet. Let's answer some questions first.

~(A 1 10)~ will do the following.
#+begin_src racket :exports code
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
;; Expansion as we reduce the value of y
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
;; Expansion is now done, it can reduce down by multiplying by 2
1024
;; When x is 1, the function acts like 2 to the power of y
#+end_src
When ~x~ is 1, we see that the function is \(2^{y}\)

~(A 2 4)~ will do the following
#+begin_src racket :exports code
(A 2 4)
(A 1 (A 2 3))
;; Expansion as we reduce the value of y
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
;; (A 1 4) is 2 to the power of 4
(A 1 16)
;; Expansion is now done,
65536
#+end_src

When ~x~ is 2, we see that the function is 2 pow 2 (y - 1) times

~(A 3 3)~ will do the following
#+begin_src racket :exports code
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
;; Now we already know what is function is when x is 2, so we can just solve mathematically
(A 2 4)
;; This is a similar value
65536
#+end_src
** Mathematical definition
#+begin_src racket :exports code
(define (f n) (A 0 n))
#+end_src

\[f \left( n \right) = 2 \times n\]

#+begin_src racket :exports code
(define (g n) (A 1 n))
#+end_src

\[g \left( n \right) = 2 ^{n} \]

#+begin_src racket :exports code
(define (h n) (A 2 n))
#+end_src

\[h \left( n \right) = {^{n}2} \]

Looks like this is a concept for [[https://en.wikipedia.org/wiki/Tetration][tetration]]
* Exercise 1.11
** Definition
\[f \left( n \right) = \begin{cases} n ~ \text{if} ~ n < 3 \\ f \left( n - 1 \right) + 2 f \left( n -2  \right) + 3 f \left( n - 3 \right) ~ \text{if} ~ n \geq 3 \end{cases}
\]
** Recursive process
#+begin_src racket :exports both
#lang sicp
(define (f n) (if (< n 3) n
                     (+ (f (- n 1))
                        (* 2 (f (- n 2)))
                        (* 3 (f (- n 3))))))
(f 0)
(f 1)
(f 2)
(f 3)
(f 4)
(f 5)
(f 6)
(f 7)
(f 8)
#+end_src

#+RESULTS:
: 0
: 1
: 2
: 4
: 11
: 25
: 59
: 142
: 335

** Iterative process
#+begin_src racket :exports both
#lang sicp
(define (f n)
  (define (f-aux f-1-aux f-2-aux f-3-aux) (+ f-1-aux (* 2 f-2-aux) (* 3 f-3-aux)))
  (define (f-iter cnt f-1 f-2 f-3)
    (if (= n cnt)
        (f-aux f-1 f-2 f-3)
        (f-iter (inc cnt) (f-aux f-1 f-2 f-3) f-1 f-2)))
  (if (< n 3) n (f-iter 3 2 1 0)))
(f 0)
(f 1)
(f 2)
(f 3)
(f 4)
(f 5)
(f 6)
(f 7)
(f 8)
(f 100)
#+end_src

#+RESULTS:
#+begin_example
0
1
2
4
11
25
59
142
335
11937765839880230562825561449279733086
#+end_example

* Exercise 1.12
Make pascal's triangle using a recursive process. Question does not define the parameters of the triangle, so we will do that. Since we have to be able to retrieve any element of Pascal's triangle, we need to make the origin start at the tip of the triangle.

#+caption: Coordinate system being used.
#+begin_example
1 | 1
2 | 1 1
3 | 1 2 1
4 | 1 3 3 1
5 | 1 4 6 4 1
===============
  | 1 2 3 4 5

(pascal row col)
#+end_example

- Base cases
  - If row is 1, then return 1
  - If col is 1, then return 1
  - If row and col are equal, then return 1
- Recursive case
  - ~(+ (pascal (- row 1) (- col 1)) (pascal (- row 1) col))~

#+begin_src racket :exports both
#lang sicp
(define (pascal row col)
  (if (or (< row 2)
          (< col 2)
          (> col (- row 1))) 1
      (+ (pascal (- row 1) (- col 1))
         (pascal (- row 1) col))))

(= (pascal 1 1) 1)
(= (pascal 5 1) 1)
(= (pascal 3 3) 1)
(= (pascal 4 2) 3)
(= (pascal 5 4) 4)
(= (pascal 5 3) 6)
#+end_src

#+RESULTS:
: #t
: #t
: #t
: #t
: #t
: #t

* Exercise 1.13
Prove that \(\text{fib} \left( n \right)\) is the closest integer to \(\varphi^{n} / \sqrt{5} \), where

\[ \varphi = \frac{1 + \sqrt{5}}{2} \approx 1.6180
\]

is the golden ratio that satisfies the following equation

\[\varphi^{2} = \varphi + 1
\]

** Solution

I don't have a very rigorous mathematical background, so my proof will end up being strange looking.

Let \(\psi = (1 - \sqrt{5} ) / 2\)

Prove that \(\text{fib} \left( n \right) = \left( \varphi^{n} - \psi^{n} \right) / \sqrt{5}\) using induction and the definition of \(\text{fib} \left( n \right)\).

\begin{equation}
\text{fib} \left( n \right) = \begin{cases}0 & \text{if}~n=0\\
1 & \text{if} ~ n=1 \\ \text{fib} \left( n - 1 \right) +
\text{fib} \left( n -2 \right) & \text{otherwise}\end{cases}
\end{equation}

base cases:

\begin{align*}
\frac{\varphi^{0} - \psi^{0}}{\sqrt{5}} &= 0 \\
\therefore \frac{\varphi^{0} - \psi^{0}}{\sqrt{5}} &= \text{fib} \left( 0 \right) \\
\frac{\varphi^{1} - \psi^{1}}{\sqrt{5}} &= \frac{\frac{1 + \sqrt{5}}{2} - \frac{1 - \sqrt{5}}{2}}{ \sqrt{5}} \\
&= \frac{\frac{1 + \sqrt{5} - 1 + \sqrt{5}}{2}}{\sqrt{5}} \\
&= \frac{2 \sqrt{5}}{2\sqrt{5}} \\
&= 1 \\
\therefore \frac{\varphi^{1} - \psi^{1}}{\sqrt{5}} &= \text{fib} \left( 1 \right) \\
\end{align*}

Inductive case:
- We need to prove the following

\begin{equation*}
\frac{\varphi^{n-1} - \psi^{n -1}}{\sqrt{5}} + \frac{\varphi^{n-2} - \psi^{n -2}}{\sqrt{5}} = \frac{\varphi^{n} - \psi^{n}}{\sqrt{5}}
\end{equation*}

\begin{align*}
\frac{\varphi^{n-1} - \psi^{n -1}+ \varphi^{n-2} - \psi^{n -2}}{\sqrt{5}} &= \frac{\varphi^{n-1}+ \varphi^{n-2} - \psi^{n -1} - \psi^{n -2}}{\sqrt{5}} \\
&= \frac{ \varphi^{n} \left( \varphi^{-1}+ \varphi^{-2} \right)  - \psi^{n}\left(  \psi^{ -1} + \psi^{ -2}\right) }{\sqrt{5}}
\end{align*}

Like the good programmer we are, we will solve the sub problem separately.
\begin{align*}
\varphi^{-1} + \varphi^{-2} &= \frac{2}{1 + \sqrt{5}} + \frac{4}{\left( 1 + \sqrt{5} \right)^{2}} \\
&= \frac{2 \left( 1 + \sqrt{5} \right) + 4}{\left( 1 + \sqrt{5} \right)^{2}} \\
&= \frac{ \left( 2 + 2\sqrt{5} \right) + 4}{\left( 1 + 2\sqrt{5} + 5 \right)} \\
&= \frac{  6 + 2\sqrt{5} }{ 6 + 2\sqrt{5}   } \\
&= 1 \\
\end{align*}

\begin{align*}
\psi^{-1} + \psi^{-2} &= \frac{2}{1 - \sqrt{5}} + \frac{4}{\left( 1 - \sqrt{5} \right)^{2}} \\
&= \frac{2 \left( 1 - \sqrt{5} \right) + 4}{\left( 1 - \sqrt{5} \right)^{2}} \\
&= \frac{ \left( 2 - 2\sqrt{5} \right) + 4}{\left( 1 - 2\sqrt{5} + 5 \right)} \\
&= \frac{  6 - 2\sqrt{5} }{ 6 - 2\sqrt{5}   } \\
&= 1 \\
\end{align*}

Substituting this back

\begin{align*}
\frac{\varphi^{n-1} - \psi^{n -1}+ \varphi^{n-2} - \psi^{n -2}}{\sqrt{5}} &= \frac{ \varphi^{n}  - \psi^{n} }{\sqrt{5}} \\
\therefore \frac{ \varphi^{n}  - \psi^{n} }{\sqrt{5}} &= \text{fib} \left( n \right)
\end{align*}

The distance between \(\varphi^{2}/\sqrt{5}\) and \(\text{fib} \left( n \right)\) is therefore \(\psi^{2}/\sqrt{5}\), which when calculated is around 0.4472 at \(n=0\). Since this value at \(n=0\) is less than 0.5, \(\text{fib} \left( 0 \right)\) is the closest integer to \(\varphi^{2}/2\). Since the term is exponentiated, the distance between \(\text{fib} \left( n \right)\) and \(\varphi^{2}/2\) will only shrink, making \(\text{fib} \left( n \right)\) the closest integer to \(\varphi^{2} / \sqrt{5}\)

* Exercise 1.14
Draw the process tree for the count-change program, defined below, and define the order of growth of the process.
#+begin_src racket :exports both
#lang sicp
(define (value-of-kind x)
  (cond ((= x 5) 50)
        ((= x 4) 25)
        ((= x 3) 10)
        ((= x 2) 5)
        ((= x 1) 1)))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount (- kinds-of-coins 1))
                 (cc (- amount (value-of-kind kinds-of-coins)) kinds-of-coins)
                 ))
        ))
(define (count-change amount) (cc amount 5))
(count-change 11)
#+end_src

#+RESULTS:
: 4


Evaluation tree was drawn off screen. This is a \(\Theta(n^{2})\) step algorithm with a \(\Theta(n)\) space complexity.
* Exercise 1.15
Approximating sine using software. We have the following identity.

\[
\sin (x) = 3 \sin \left(\frac{x}{3}\right) - 4 \sin^{3} \left( \frac{x}{3} \right)
\]

This definition leaverages the fact that at small enough x, \(\sin(x) \approx x\).

We are provided the following procedure.
#+begin_src racket :exports both
#lang sicp
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine x) (if (not (> (abs x) 0.1))
                     x
                     (p (sine (/ x 3.0)))))
#+end_src
** Question a
*** Question
How many times does the procedure p get applied when calling ~(sine 12.15)~.

*** Answer
This question is really asking how many times do we have to call sine before it recursively gets to a value below 0.1. I manually pressed the divide by 3 button on my calculator 5 times before getting to 0.05, which would be our target value to would prevent the p procedure from being called.
** Question b
*** Question
What is the order of growth of this procedure in both steps and space.
*** Answer
This procedure is a linear recursive function, meaning that there is not tail call strategy, but evaluation does not navigate a tree. Getting to the approximation case is logarithmic, as a division by 3 is used to get there. Nature of this program is that space grows exactly as the steps do, therefore space order of growth is also logarithmic. \(\Theta(\log(n))\).
* Exercise 1.16
Make an iterative version of the fast exponential process.
#+begin_src racket :exports both
#lang sicp
(define (fast-expt b n)
  (define (square x) (* x x))
  (define (even? x) (= (remainder x 2) 0))
  (define (fast-expt-iter b n a)
    (if (= n 0) a (if (even? n)
                      (fast-expt-iter (square b) (/ n 2) a)
                      (fast-expt-iter b (- n 1) (* a b)))))
  (fast-expt-iter b n 1))

(fast-expt 2 100)
#+end_src

#+RESULTS:
: 1267650600228229401496703205376
* Exercise 1.17
Make an analogous version of ~fast-expt~, but using addition to achieve multiplication.

#+begin_src racket :exports both
#lang sicp
(define (double x) (+ x x))
(define (halve x) (/ x 2))
(define (even? x) (= (remainder x 2) 0))
(define (fast-multi x y)
  (cond ((or (= y 0) (= x 0)) 0)
        ((even? y) (double (fast-multi x (halve y))))
        (else (+ x (fast-multi x (- y 1))))))

(fast-multi 2 1000000000000)
#+end_src

#+RESULTS:
: 2000000000000

* Exercise 1.18
#+begin_src racket :exports both
#lang sicp
(define (double x) (+ x x))
(define (halve x) (/ x 2))
(define (even? x) (= (remainder x 2) 0))
(define (fast-multi x y)
  (define (fast-multi-iter x y a)
    (if (= y 0) a
        (if (even? y)
            (fast-multi-iter (double x) (halve y) a)
            (fast-multi-iter x (- y 1) (+ x a)))))
  (fast-multi-iter x y 0))

(fast-multi 10 100000000000000)
#+end_src

#+RESULTS:
: 1000000000000000
